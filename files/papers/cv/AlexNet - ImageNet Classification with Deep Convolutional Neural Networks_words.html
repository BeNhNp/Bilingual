<html>
<head>
<meta charset="utf-8">
<title> AlexNet - ImageNet Classification with Deep Convolutional Neural Networks </title>
<style type="text/css">
.inline-ul { font-size:0;}
.inline-ul ul li{ font-size: 12px; letter-spacing: normal; word-spacing: normal;
vertical-align:top; display: inline-block; *display:inline; *zoom:1;}
.inline-ul{ letter-spacing:-5px; }
.widget-title { font-size: 13px; font-weight: normal; color: #888888; padding: 20px 20px 0px; }
.widget-tab .widget-title{font-size: 0;}
.widget-tab .widget-title ul li{margin-left:3%;width:40%;text-align:center;margin-right:2%;padding:4px 1%;}
.widget-tab .widget-title ul li:hover{background:#F7F7F7}
.widget-tab .widget-title label{cursor:pointer;display:block; font-size: 0.8em;}
.widget-tab .widget-title ul li.active{background:#F0F0F0}
.widget-tab input{display:none}
.widget-tab .widget-box div{display:none}
#one:checked ~ .widget-title .one,#two:checked ~ .widget-title .two{background:#F7F7F7}
#one:checked ~ .widget-box .one-list,#two:checked ~ .widget-box .two-list{display:block}

body {font-family: arial,verdana,geneva,sans-serif; font-size: 1.25em; color: #000; word-wrap:break-word;}
table { border-collapse: collapse; margin: 0 auto; }
table td, table th { border: 1px solid #cad9ea; height: 30px; }
table thead th, table thead td { background-color: #CCE8EB; text-align: center; }
table tr:nth-child(odd) { background: #fff; }
table tr:nth-child(even) { background: #F5FAFA; }
table tr td:not(:last-child){ text-align: center; }
</style>
</head>
<body>
<div class="widget-tab">
<input type="radio" name="widget-tab" id="one" checked="checked"/>
<input type="radio" name="widget-tab" id="two"/>
<div class="widget-title inline-ul">
    <ul> <li class="one"> <label for="one">In order of appearance</label> </li>
        <li class="two"> <label for="two">In order of frequency</label> </li>
    </ul>
</div>
<div class="widget-box">
<div class="one-list">
<table>
<caption>
    <h2> Words List (appearance)</h2>
</caption>
<thead>
<tr>
<td> # </td> <td> word </td> <td> phonetic </td> <td> sentence </td>
</tr>
</thead>
<tr>
<td> 1 </td> <td> Krizhevsky </td> <td>  </td> <td> 
<ul><li>Authors: <font color=forestgreen>Krizhevsky</font>, Alex (University of Toronto, Canada); Sutskever, Ilya; Hinton, Geoffrey E.<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 2 </td> <td> Alex </td> <td> ['ælɪkʃ] </td> <td> 
<ul><li>Authors: Krizhevsky, <font color=orangered>Alex</font> (University of Toronto, Canada); Sutskever, Ilya; Hinton, Geoffrey E.<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 3 </td> <td> Toronto </td> <td> [tə'rɔntəu] </td> <td> 
<ul><li>Authors: Krizhevsky, Alex (University of <font color=orangered>Toronto</font>, Canada); Sutskever, Ilya; Hinton, Geoffrey E.<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 4 </td> <td> Sutskever </td> <td>  </td> <td> 
<ul><li>Authors: Krizhevsky, Alex (University of Toronto, Canada); <font color=forestgreen>Sutskever</font>, Ilya; Hinton, Geoffrey E.<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 5 </td> <td> ilya </td> <td>  </td> <td> 
<ul><li>Authors: Krizhevsky, Alex (University of Toronto, Canada); Sutskever, <font color=forestgreen>Ilya</font>; Hinton, Geoffrey E.<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 6 </td> <td> hinton </td> <td>  </td> <td> 
<ul><li>Authors: Krizhevsky, Alex (University of Toronto, Canada); Sutskever, Ilya; <font color=forestgreen>Hinton</font>, Geoffrey E.<span style="font-size:80%;opacity:0.8"></span></li><li>Following Nair and <font color=forestgreen>Hinton</font> [20], we refer to neurons with this nonlinearity as Rectified Linear Units (ReLUs).<span style="font-size:80%;opacity:0.8">根据Nair和Hinton[20]的说法，我们将这种非线性神经元称为修正线性单元(ReLU)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 7 </td> <td> Geoffrey </td> <td> ['dʒefrɪ] </td> <td> 
<ul><li>Authors: Krizhevsky, Alex (University of Toronto, Canada); Sutskever, Ilya; Hinton, <font color=orangered>Geoffrey</font> E.<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 8 </td> <td> nip </td> <td> [nɪp] </td> <td> 
<ul><li>Source: Advances in Neural Information Processing Systems, v 2, p 1097-1105, 2012, 26th Annual Conference on Neural Information Processing Systems 2012, <font color=orangered>NIPS</font> 2012<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 9 </td> <td> LSVRC </td> <td>  </td> <td> 
<ul><li>We trained a large, deep convolutional neural network to classify the 1.2 million high-resolution images in the ImageNet <font color=forestgreen>LSVRC</font>-2010 contest into the 1000 different classes.<span style="font-size:80%;opacity:0.8">我们训练了一个大型深度卷积神经网络来将ImageNet LSVRC-2010竞赛的120万高分辨率的图像分到1000不同的类别中。</span></li></ul>
 </td>
</tr>
<tr>
<td> 10 </td> <td> max-pooling </td> <td>  </td> <td> 
<ul><li>The neural network, which has 60 million parameters and 650,000 neurons, consists of five convolutional layers, some of which are followed by <font color=forestgreen>max-pooling</font> layers, and three fully-connected layers with a final 1000-way softmax.<span style="font-size:80%;opacity:0.8">这个神经网络有6000万参数和650000个神经元，包含5个卷积层（某些卷积层后面带有池化层）和3个全连接层，最后是一个1000维的softmax。</span></li><li><font color=forestgreen>Max-pooling</font> layers, of the kind described in Section 3.4, follow both response-normalization layers as well as the fifth convolutional layer.<span style="font-size:80%;opacity:0.8">3.4节描述的这种最大池化层在响应归一化层和第5卷积层之后。</span></li></ul>
 </td>
</tr>
<tr>
<td> 11 </td> <td> non-saturating </td> <td>  </td> <td> 
<ul><li>To make training faster, we used <font color=forestgreen>non-saturating</font> neurons and a very efficient GPU implementation of the convolution operation.<span style="font-size:80%;opacity:0.8">为了训练的更快，我们使用了非饱和神经元并对卷积操作进行了非常有效的GPU实现。</span></li><li>In terms of training time with gradient descent, these saturating nonlinearities are much slower than the <font color=forestgreen>non-saturating</font> nonlinearity $f(x) = \max(0,x)$.<span style="font-size:80%;opacity:0.8">考虑到梯度下降的训练时间，这些饱和的非线性比非饱和非线性$f(x) = \max(0,x)$更慢。</span></li></ul>
 </td>
</tr>
<tr>
<td> 12 </td> <td> variant </td> <td> [ˈveəriənt] </td> <td> 
<ul><li>We also entered a <font color=orangered>variant</font> of this model in the ILSVRC-2012 competition and achieved a winning top-5 test error rate of 15.3%, compared to 26.2% achieved by the second-best entry.<span style="font-size:80%;opacity:0.8">我们也使用这个模型的一个变种参加了ILSVRC-2012竞赛，赢得了冠军并且与第二名 top-5 26.2%的错误率相比，我们取得了top-5 15.3%的错误率。</span></li></ul>
 </td>
</tr>
<tr>
<td> 13 </td> <td> ILSVRC </td> <td>  </td> <td> 
<ul><li>We also entered a variant of this model in the <font color=forestgreen>ILSVRC</font>-2012 competition and achieved a winning top-5 test error rate of 15.3%, compared to 26.2% achieved by the second-best entry.<span style="font-size:80%;opacity:0.8">我们也使用这个模型的一个变种参加了ILSVRC-2012竞赛，赢得了冠军并且与第二名 top-5 26.2%的错误率相比，我们取得了top-5 15.3%的错误率。</span></li><li>The specific contributions of this paper are as follows: we trained one of the largest convolutional neural networks to date on the subsets of ImageNet used in the <font color=forestgreen>ILSVRC</font>-2010 and <font color=forestgreen>ILSVRC</font>-2012 competitions [2] and achieved by far the best results ever reported on these datasets.<span style="font-size:80%;opacity:0.8">本文具体的贡献如下：我们在ILSVRC-2010和ILSVRC-2012[2]的ImageNet子集上训练了到目前为止最大的神经网络之一，并取得了迄今为止在这些数据集上报道过的最好结果。</span></li><li>Starting in 2010, as part of the Pascal Visual Object Challenge, an annual competition called the ImageNet Large-Scale Visual Recognition Challenge (<font color=forestgreen>ILSVRC</font>) has been held.<span style="font-size:80%;opacity:0.8">从2010年起，作为Pascal视觉对象挑战赛的一部分，每年都会举办ImageNet大规模视觉识别挑战赛（ILSVRC）。</span></li><li><font color=forestgreen>ILSVRC</font> uses a subset of ImageNet with roughly 1000 images in each of 1000 categories.<span style="font-size:80%;opacity:0.8">ILSVRC使用ImageNet的一个子集，1000个类别每个类别大约1000张图像。</span></li><li>ILSVRC-2010 is the only version of <font color=forestgreen>ILSVRC</font> for which the test set labels are available, so this is the version on which we performed most of our experiments.<span style="font-size:80%;opacity:0.8">ILSVRC-2010是ILSVRC竞赛中唯一可以获得测试集标签的版本，因此我们大多数实验都是在这个版本上运行的。</span></li><li>Since we also entered our model in the <font color=forestgreen>ILSVRC</font>-2012 competition, in Section 6 we report our results on this version of the dataset as well, for which test set labels are unavailable.<span style="font-size:80%;opacity:0.8">由于我们也使用我们的模型参加了ILSVRC-2012竞赛，因此在第六节我们也报告了模型在这个版本的数据集上的结果，这个版本的测试标签是不可获得的。</span></li><li>Although the 1000 classes of <font color=forestgreen>ILSVRC</font> make each training example impose 10 bits of constraint on the mapping from image to label, this turns out to be insufficient to learn so many parameters without considerable overfitting.<span style="font-size:80%;opacity:0.8">尽管ILSVRC的1000类使每个训练样本从图像到标签的映射上强加了10比特的约束，但这不足以学习这么多的参数而没有相当大的过拟合。</span></li><li>Our results on <font color=forestgreen>ILSVRC</font>-2010 are summarized in Table 1.<span style="font-size:80%;opacity:0.8">我们在ILSVRC-2010上的结果概括为表1。</span></li><li>The best performance achieved during the <font color=forestgreen>ILSVRC</font>-2010 competition was 47.1% and 28.2% with an approach that averages the predictions produced from six sparse-coding models trained on different features [2], and since then the best published results are 45.7% and 25.7% with an approach that averages the predictions of two classifiers trained on Fisher Vectors (FVs) computed from two types of densely-sampled features [24].<span style="font-size:80%;opacity:0.8">在ILSVRC-2010竞赛中最佳结果是top-1 47.1%，top-5 28.2%，使用的方法是对6个在不同特征上训练的稀疏编码模型生成的预测进行平均，从那时起已公布的最好结果是top-1 45.7%，top-5 25.7%，使用的方法是平均在Fisher向量（FV）上训练的两个分类器的预测结果，Fisher向量是通过两种密集采样特征计算得到的[24]。</span></li><li>Table 1: Comparison of results on <font color=forestgreen>ILSVRC</font>-2010 test set.<span style="font-size:80%;opacity:0.8">表1：ILSVRC-2010测试集上的结果对比。</span></li><li>We also entered our model in the <font color=forestgreen>ILSVRC</font>-2012 competition and report our results in Table 2.<span style="font-size:80%;opacity:0.8">我们也用我们的模型参加了ILSVRC-2012竞赛并在表2中报告了我们的结果。</span></li><li>Since the <font color=forestgreen>ILSVRC</font>-2012 test set labels are not publicly available, we cannot report test error rates for all the models that we tried.<span style="font-size:80%;opacity:0.8">由于ILSVRC-2012的测试集标签不可以公开得到，我们不能报告我们尝试的所有模型的测试错误率。</span></li><li>Training one CNN, with an extra sixth convolutional layer over the last pooling layer, to classify the entire ImageNet Fall 2011 release (15M images, 22K categories), and then “fine-tuning” it on <font color=forestgreen>ILSVRC</font>-2012 gives an error rate of 16.6%.<span style="font-size:80%;opacity:0.8">为了对ImageNet 2011秋季发布的整个数据集（1500万图像，22000个类别）进行分类，我们在最后的池化层之后有一个额外的第6卷积层，训练了一个CNN，然后在它上面进行“fine-tuning”，在ILSVRC-2012取得了16.6%的错误率。</span></li><li>Table 2: Comparison of error rates on <font color=forestgreen>ILSVRC</font>-2012 validation and test sets.<span style="font-size:80%;opacity:0.8">表2：ILSVRC-2012验证集和测试集的误差对比。</span></li><li>Figure 4: (Left) Eight <font color=forestgreen>ILSVRC</font>-2010 test images and the five labels considered most probable by our model.<span style="font-size:80%;opacity:0.8">图4：（左）8张ILSVRC-2010测试图像和我们的模型认为最可能的5个标签。</span></li><li>(Right) Five <font color=forestgreen>ILSVRC</font>-2010 test images in the first column.<span style="font-size:80%;opacity:0.8">（右）第一列是5张ILSVRC-2010测试图像。</span></li></ul>
 </td>
</tr>
<tr>
<td> 14 </td> <td> NORB </td> <td>  </td> <td> 
<ul><li>Until recently, datasets of labeled images were relatively small -- on the order of tens of thousands of images (e.g., <font color=forestgreen>NORB</font> [16], Caltech-101/256 [8, 9], and CIFAR-10/100 [12]). Simple recognition tasks can be solved quite well with datasets of this size, especially if they are augmented with label-preserving transformations.<span style="font-size:80%;opacity:0.8">直到最近，标注图像的数据集都相对较小--在几万张图像的数量级上（例如，NORB[16]，Caltech-101/256 [8, 9]和CIFAR-10/100 [12]）。简单的识别任务在这样大小的数据集上可以被解决的相当好，尤其是如果通过标签保留变换进行数据增强的情况下。</span></li></ul>
 </td>
</tr>
<tr>
<td> 15 </td> <td> Caltech </td> <td> ['kæltek] </td> <td> 
<ul><li>Until recently, datasets of labeled images were relatively small -- on the order of tens of thousands of images (e.g., NORB [16], <font color=orangered>Caltech</font>-101/256 [8, 9], and CIFAR-10/100 [12]). Simple recognition tasks can be solved quite well with datasets of this size, especially if they are augmented with label-preserving transformations.<span style="font-size:80%;opacity:0.8">直到最近，标注图像的数据集都相对较小--在几万张图像的数量级上（例如，NORB[16]，Caltech-101/256 [8, 9]和CIFAR-10/100 [12]）。简单的识别任务在这样大小的数据集上可以被解决的相当好，尤其是如果通过标签保留变换进行数据增强的情况下。</span></li><li>For example, Jarrett et al. [11] claim that the nonlinearity $f(x) = \lvert \tanh(x) \rvert$ works particularly well with their type of contrast normalization followed by local average pooling on the <font color=orangered>Caltech</font>-101 dataset.<span style="font-size:80%;opacity:0.8">例如，Jarrett等人[11]声称非线性函数$f(x) = \lvert \tanh(x) \rvert$与其对比度归一化一起，然后是局部均值池化，在Caltech-101数据集上工作的非常好。</span></li></ul>
 </td>
</tr>
<tr>
<td> 16 </td> <td> CIFAR </td> <td>  </td> <td> 
<ul><li>Until recently, datasets of labeled images were relatively small -- on the order of tens of thousands of images (e.g., NORB [16], Caltech-101/256 [8, 9], and <font color=forestgreen>CIFAR</font>-10/100 [12]). Simple recognition tasks can be solved quite well with datasets of this size, especially if they are augmented with label-preserving transformations.<span style="font-size:80%;opacity:0.8">直到最近，标注图像的数据集都相对较小--在几万张图像的数量级上（例如，NORB[16]，Caltech-101/256 [8, 9]和CIFAR-10/100 [12]）。简单的识别任务在这样大小的数据集上可以被解决的相当好，尤其是如果通过标签保留变换进行数据增强的情况下。</span></li><li>This is demonstrated in Figure 1, which shows the number of iterations required to reach 25% training error on the <font color=forestgreen>CIFAR</font>-10 dataset for a particular four-layer convolutional network.<span style="font-size:80%;opacity:0.8">在图1中，对于一个特定的四层卷积网络，在CIFAR-10数据集上达到25%的训练误差所需要的迭代次数可以证实这一点。</span></li><li>Figure 1: A four-layer convolutional neural network with ReLUs (solid line) reaches a 25% training error rate on <font color=forestgreen>CIFAR</font>-10 six times faster than an equivalent network with tanh neurons (dashed line).<span style="font-size:80%;opacity:0.8">图1：使用ReLU的四层卷积神经网络在CIFAR-10数据集上达到25%的训练误差比使用tanh神经元的等价网络（虚线）快六倍。</span></li><li>We also verified the effectiveness of this scheme on the <font color=forestgreen>CIFAR</font>-10 dataset: a four-layer CNN achieved a 13% test error rate without normalization and 11% with normalization.<span style="font-size:80%;opacity:0.8">我们也在CIFAR-10数据集上验证了这个方案的有效性：一个乜嘢归一化的四层CNN取得了13%的错误率，而使用归一化取得了11%的错误率。</span></li></ul>
 </td>
</tr>
<tr>
<td> 17 </td> <td> augment </td> <td> [ɔ:gˈment] </td> <td> 
<ul><li>Until recently, datasets of labeled images were relatively small -- on the order of tens of thousands of images (e.g., NORB [16], Caltech-101/256 [8, 9], and CIFAR-10/100 [12]). Simple recognition tasks can be solved quite well with datasets of this size, especially if they are <font color=orangered>augmented</font> with label-preserving transformations.<span style="font-size:80%;opacity:0.8">直到最近，标注图像的数据集都相对较小--在几万张图像的数量级上（例如，NORB[16]，Caltech-101/256 [8, 9]和CIFAR-10/100 [12]）。简单的识别任务在这样大小的数据集上可以被解决的相当好，尤其是如果通过标签保留变换进行数据增强的情况下。</span></li></ul>
 </td>
</tr>
<tr>
<td> 18 </td> <td> label-preserving </td> <td>  </td> <td> 
<ul><li>Until recently, datasets of labeled images were relatively small -- on the order of tens of thousands of images (e.g., NORB [16], Caltech-101/256 [8, 9], and CIFAR-10/100 [12]). Simple recognition tasks can be solved quite well with datasets of this size, especially if they are augmented with <font color=forestgreen>label-preserving</font> transformations.<span style="font-size:80%;opacity:0.8">直到最近，标注图像的数据集都相对较小--在几万张图像的数量级上（例如，NORB[16]，Caltech-101/256 [8, 9]和CIFAR-10/100 [12]）。简单的识别任务在这样大小的数据集上可以被解决的相当好，尤其是如果通过标签保留变换进行数据增强的情况下。</span></li><li>The easiest and most common method to reduce overfitting on image data is to artificially enlarge the dataset using <font color=forestgreen>label-preserving</font> transformations (e.g., [25, 4, 5]).<span style="font-size:80%;opacity:0.8">图像数据上最简单常用的用来减少过拟合的方法是使用标签保留变换（例如[25, 4, 5]）来人工增大数据集。</span></li></ul>
 </td>
</tr>
<tr>
<td> 19 </td> <td> MNIST </td> <td>  </td> <td> 
<ul><li>For example, the current best error rate on the <font color=forestgreen>MNIST</font> digit-recognition task (<0.3%) approaches human performance [4].<span style="font-size:80%;opacity:0.8">例如，目前在MNIST数字识别任务上（<0.3%）的最好准确率已经接近了人类水平[4]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 20 </td> <td> digit-recognition </td> <td>  </td> <td> 
<ul><li>For example, the current best error rate on the MNIST <font color=forestgreen>digit-recognition</font> task (<0.3%) approaches human performance [4].<span style="font-size:80%;opacity:0.8">例如，目前在MNIST数字识别任务上（<0.3%）的最好准确率已经接近了人类水平[4]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 21 </td> <td> variability </td> <td> [ˌveəriəˈbɪləti] </td> <td> 
<ul><li>But objects in realistic settings exhibit considerable <font color=orangered>variability</font>, so to learn to recognize them it is necessary to use much larger training sets.<span style="font-size:80%;opacity:0.8">但真实环境中的对象表现出了相当大的可变性，因此为了学习识别它们，有必要使用更大的训练数据集。</span></li></ul>
 </td>
</tr>
<tr>
<td> 22 </td> <td> pinto </td> <td> [ˈpɪntəʊ] </td> <td> 
<ul><li>And indeed, the shortcomings of small image datasets have been widely recognized (e.g., <font color=orangered>Pinto</font> et al. [21]), but it has only recently become possible to collect labeled datasets with millions of images.<span style="font-size:80%;opacity:0.8">实际上，小图像数据集的缺点已经被广泛认识到（例如，Pinto et al. [21]），但收集上百万图像的标注数据仅在最近才变得的可能。</span></li></ul>
 </td>
</tr>
<tr>
<td> 23 </td> <td> LabelMe </td> <td>  </td> <td> 
<ul><li>The new larger datasets include <font color=forestgreen>LabelMe</font> [23], which consists of hundreds of thousands of fully-segmented images, and ImageNet [6], which consists of over 15 million labeled high-resolution images in over 22,000 categories.<span style="font-size:80%;opacity:0.8">新的更大的数据集包括LabelMe [23]，它包含了数十万张完全分割的图像，ImageNet[6]，它包含了22000个类别上的超过1500万张标注的高分辨率的图像。</span></li></ul>
 </td>
</tr>
<tr>
<td> 24 </td> <td> immense </td> <td> [ɪˈmens] </td> <td> 
<ul><li>However, the <font color=orangered>immense</font> complexity of the object recognition task means that this problem cannot be specified even by a dataset as large as ImageNet, so our model should also have lots of prior knowledge to compensate for all the data we don’t have.<span style="font-size:80%;opacity:0.8">然而对象识别任务的巨大复杂性意味着这个问题不能被指定，即使通过像ImageNet这样的大数据集，因此我们的模型应该也有许多先验知识来补偿我们所没有的数据。</span></li></ul>
 </td>
</tr>
<tr>
<td> 25 </td> <td> constitute </td> <td> [ˈkɒnstɪtju:t] </td> <td> 
<ul><li>Convolutional neural networks (CNNs) <font color=orangered>constitute</font> one such class of models [16, 11, 13, 18, 15, 22, 26].<span style="font-size:80%;opacity:0.8">卷积神经网络(CNNs)构成了一个这样的模型[16, 11, 13, 18, 15, 22, 26]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 26 </td> <td> stationarity </td> <td> [steɪʃə'nærɪtɪ] </td> <td> 
<ul><li>Their capacity can be controlled by varying their depth and breadth, and they also make strong and mostly correct assumptions about the nature of images (namely, <font color=orangered>stationarity</font> of statistics and locality of pixel dependencies).<span style="font-size:80%;opacity:0.8">它们的能力可以通过改变它们的广度和深度来控制，它们也可以对图像的本质进行强大且通常正确的假设（也就是说，统计的稳定性和像素依赖的局部性）。</span></li></ul>
 </td>
</tr>
<tr>
<td> 27 </td> <td> feedforward </td> <td> [fi:d'fɔ:wəd] </td> <td> 
<ul><li>Thus, compared to standard <font color=orangered>feedforward</font> neural networks with similarly-sized layers, CNNs have much fewer connections and parameters and so they are easier to train, while their theoretically-best performance is likely to be only slightly worse.<span style="font-size:80%;opacity:0.8">因此，与具有层次大小相似的标准前馈神经网络，CNNs有更少的连接和参数，因此它们更容易训练，而它们理论上的最佳性能可能仅比标准前馈神经网络差一点。</span></li></ul>
 </td>
</tr>
<tr>
<td> 28 </td> <td> similarly-sized </td> <td>  </td> <td> 
<ul><li>Thus, compared to standard feedforward neural networks with <font color=forestgreen>similarly-sized</font> layers, CNNs have much fewer connections and parameters and so they are easier to train, while their theoretically-best performance is likely to be only slightly worse.<span style="font-size:80%;opacity:0.8">因此，与具有层次大小相似的标准前馈神经网络，CNNs有更少的连接和参数，因此它们更容易训练，而它们理论上的最佳性能可能仅比标准前馈神经网络差一点。</span></li></ul>
 </td>
</tr>
<tr>
<td> 29 </td> <td> theoretically-best </td> <td>  </td> <td> 
<ul><li>Thus, compared to standard feedforward neural networks with similarly-sized layers, CNNs have much fewer connections and parameters and so they are easier to train, while their <font color=forestgreen>theoretically-best</font> performance is likely to be only slightly worse.<span style="font-size:80%;opacity:0.8">因此，与具有层次大小相似的标准前馈神经网络，CNNs有更少的连接和参数，因此它们更容易训练，而它们理论上的最佳性能可能仅比标准前馈神经网络差一点。</span></li></ul>
 </td>
</tr>
<tr>
<td> 30 </td> <td> prohibitively </td> <td> [prəʊˈhɪbɪtɪvlɪ] </td> <td> 
<ul><li>Despite the attractive qualities of CNNs, and despite the relative efficiency of their local architecture, they have still been <font color=orangered>prohibitively</font> expensive to apply in large scale to high-resolution images.<span style="font-size:80%;opacity:0.8">尽管CNN具有引人注目的特性，尽管CNN的局部架构相当有效，但将它们大规模的应用到到高分辨率图像中仍然是代价极高的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 31 </td> <td> interestingly-large </td> <td>  </td> <td> 
<ul><li>Luckily, current GPUs, paired with a highly-optimized implementation of 2D convolution, are powerful enough to facilitate the training of <font color=forestgreen>interestingly-large</font> CNNs, and recent datasets such as ImageNet contain enough labeled examples to train such models without severe overfitting.<span style="font-size:80%;opacity:0.8">幸运的是，目前的GPU，搭配了高度优化的2D卷积实现，强大到足够促进有趣地大量CNN的训练，最近的数据集例如ImageNet包含足够的标注样本来训练这样的模型而没有严重的过拟合。</span></li></ul>
 </td>
</tr>
<tr>
<td> 32 </td> <td> GTX </td> <td>  </td> <td> 
<ul><li>Our network takes between five and six days to train on two <font color=forestgreen>GTX</font> 580 3GB GPUs.<span style="font-size:80%;opacity:0.8">我们的网络在两个GTX 580 3GB GPU上训练五六天。</span></li><li>A single <font color=forestgreen>GTX</font> 580 GPU has only 3GB of memory, which limits the maximum size of the networks that can be trained on it.<span style="font-size:80%;opacity:0.8">单个GTX580 GPU只有3G内存，这限制了可以在GTX580上进行训练的网络最大尺寸。</span></li><li>We trained the network for roughly 90 cycles through the training set of 1.2 million images, which took five to six days on two NVIDIA <font color=forestgreen>GTX</font> 580 3GB GPUs.<span style="font-size:80%;opacity:0.8">我们在120万图像的训练数据集上训练神经网络大约90个循环，在两个NVIDIA GTX 580 3GB GPU上花费了五到六天。</span></li></ul>
 </td>
</tr>
<tr>
<td> 33 </td> <td> GB </td> <td>  </td> <td> 
<ul><li>Our network takes between five and six days to train on two GTX 580 3GB GPUs.<span style="font-size:80%;opacity:0.8">我们的网络在两个GTX 580 3GB GPU上训练五六天。</span></li><li>A single GTX 580 GPU has only 3GB of memory, which limits the maximum size of the networks that can be trained on it.<span style="font-size:80%;opacity:0.8">单个GTX580 GPU只有3G内存，这限制了可以在GTX580上进行训练的网络最大尺寸。</span></li><li>We trained the network for roughly 90 cycles through the training set of 1.2 million images, which took five to six days on two NVIDIA GTX 580 3GB GPUs.<span style="font-size:80%;opacity:0.8">我们在120万图像的训练数据集上训练神经网络大约90个循环，在两个NVIDIA GTX 580 3GB GPU上花费了五到六天。</span></li></ul>
 </td>
</tr>
<tr>
<td> 34 </td> <td> labelers </td> <td>  </td> <td> 
<ul><li>The images were collected from the web and labeled by human <font color=forestgreen>labelers</font> using Amazon’s Mechanical Turk crowd-sourcing tool.<span style="font-size:80%;opacity:0.8">这些图像是从网上收集的，使用了Amazon’s Mechanical Turk的众包工具通过人工标注的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 35 </td> <td> turk </td> <td> [tә:k] </td> <td> 
<ul><li>The images were collected from the web and labeled by human labelers using Amazon’s Mechanical <font color=orangered>Turk</font> crowd-sourcing tool.<span style="font-size:80%;opacity:0.8">这些图像是从网上收集的，使用了Amazon’s Mechanical Turk的众包工具通过人工标注的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 36 </td> <td> crowd-sourcing </td> <td>  </td> <td> 
<ul><li>The images were collected from the web and labeled by human labelers using Amazon’s Mechanical Turk <font color=forestgreen>crowd-sourcing</font> tool.<span style="font-size:80%;opacity:0.8">这些图像是从网上收集的，使用了Amazon’s Mechanical Turk的众包工具通过人工标注的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 37 </td> <td> pascal </td> <td> ['pæskәl] </td> <td> 
<ul><li>Starting in 2010, as part of the <font color=orangered>Pascal</font> Visual Object Challenge, an annual competition called the ImageNet Large-Scale Visual Recognition Challenge (ILSVRC) has been held.<span style="font-size:80%;opacity:0.8">从2010年起，作为Pascal视觉对象挑战赛的一部分，每年都会举办ImageNet大规模视觉识别挑战赛（ILSVRC）。</span></li></ul>
 </td>
</tr>
<tr>
<td> 38 </td> <td> variable-resolution </td> <td>  </td> <td> 
<ul><li>ImageNet consists of <font color=forestgreen>variable-resolution</font> images, while our system requires a constant input dimensionality.<span style="font-size:80%;opacity:0.8">ImageNet包含各种分辨率的图像，而我们的系统要求不变的输入维度。</span></li></ul>
 </td>
</tr>
<tr>
<td> 39 </td> <td> down-sampled </td> <td>  </td> <td> 
<ul><li>Therefore, we <font color=forestgreen>down-sampled</font> the images to a fixed resolution of 256 × 256.<span style="font-size:80%;opacity:0.8">因此，我们将图像进行下采样到固定的256×256分辨率。</span></li></ul>
 </td>
</tr>
<tr>
<td> 40 </td> <td> rectangular </td> <td> [rek'tæŋɡjələ(r)] </td> <td> 
<ul><li>Given a <font color=orangered>rectangular</font> image, we first rescaled the image such that the shorter side was of length 256, and then cropped out the central 256×256 patch from the resulting image.<span style="font-size:80%;opacity:0.8">给定一个矩形图像，我们首先缩放图像短边长度为256，然后从结果图像中裁剪中心的256×256大小的图像块。</span></li></ul>
 </td>
</tr>
<tr>
<td> 41 </td> <td> rescale </td> <td> [ri:'skeɪl] </td> <td> 
<ul><li>Given a rectangular image, we first <font color=orangered>rescaled</font> the image such that the shorter side was of length 256, and then cropped out the central 256×256 patch from the resulting image.<span style="font-size:80%;opacity:0.8">给定一个矩形图像，我们首先缩放图像短边长度为256，然后从结果图像中裁剪中心的256×256大小的图像块。</span></li></ul>
 </td>
</tr>
<tr>
<td> 42 </td> <td> patch </td> <td> [pætʃ] </td> <td> 
<ul><li>Given a rectangular image, we first rescaled the image such that the shorter side was of length 256, and then cropped out the central 256×256 <font color=orangered>patch</font> from the resulting image.<span style="font-size:80%;opacity:0.8">给定一个矩形图像，我们首先缩放图像短边长度为256，然后从结果图像中裁剪中心的256×256大小的图像块。</span></li><li>We do this by extracting random 224 × 224 <font color=orangered>patches</font> (and their horizontal reflections) from the 256×256 images and training our network on these extracted <font color=orangered>patches</font>.<span style="font-size:80%;opacity:0.8">我们从256×256图像上通过随机提取224 × 224的图像块实现了这种方式，然后在这些提取的图像块上进行训练。</span></li><li>At test time, the network makes a prediction by extracting five 224 × 224 <font color=orangered>patches</font> (the four corner <font color=orangered>patches</font> and the center patch) as well as their horizontal reflections (hence ten <font color=orangered>patches</font> in all), and averaging the predictions made by the network’s softmax layer on the ten <font color=orangered>patches</font>.<span style="font-size:80%;opacity:0.8">在测试时，网络会提取5个224 × 224的图像块（四个角上的图像块和中心的图像块）和它们的水平翻转（因此总共10个图像块）进行预测，然后对网络在10个图像块上的softmax层进行平均。</span></li><li>At test time, the network makes a prediction by extracting five 224 × 224 patches (the four corner patches and the center <font color=orangered>patch</font>) as well as their horizontal reflections (hence ten patches in all), and averaging the predictions made by the network’s softmax layer on the ten patches.<span style="font-size:80%;opacity:0.8">在测试时，网络会提取5个224 × 224的图像块（四个角上的图像块和中心的图像块）和它们的水平翻转（因此总共10个图像块）进行预测，然后对网络在10个图像块上的softmax层进行平均。</span></li><li>At test time, the network makes a prediction by extracting five 224 × 224 <font color=orangered>patches</font> (the four corner <font color=orangered>patches</font> and the center patch) as well as their horizontal reflections (hence ten <font color=orangered>patches</font> in all), and averaging the predictions made by the network’s softmax layer on the ten <font color=orangered>patches</font>.<span style="font-size:80%;opacity:0.8">在测试时，网络会提取5个224 × 224的图像块（四个角上的图像块和中心的图像块）和它们的水平翻转（因此总共10个图像块）进行预测，然后对网络在10个图像块上的softmax层进行平均。</span></li></ul>
 </td>
</tr>
<tr>
<td> 43 </td> <td> ReLU </td> <td>  </td> <td> 
<ul><li>3.1 <font color=forestgreen>ReLU</font> Nonlinearity<span style="font-size:80%;opacity:0.8">3.1 ReLU非线性</span></li><li>If at least some training examples produce a positive input to a <font color=forestgreen>ReLU</font>, learning will happen in that neuron.<span style="font-size:80%;opacity:0.8">如果至少一些训练样本对ReLU产生了正输入，那么那个神经元上将发生学习。</span></li><li>Denoting by $a_{x,y}^i$ the activity of a neuron computed by applying kernel $i$ at position $(x, y)$ and then applying the <font color=forestgreen>ReLU</font> nonlinearity, the response-normalized activity $b^i_{x,y}$ is given by the expression<span style="font-size:80%;opacity:0.8">$a_{x,y}^i$表示神经元激活，通过在$(x, y)$位置应用核i，然后应用ReLU非线性来计算，响应归一化激活$b^i_{x,y}$通过下式给定：</span></li><li>We applied this normalization after applying the <font color=forestgreen>ReLU</font> nonlinearity in certain layers (see Section 3.5).<span style="font-size:80%;opacity:0.8">我们在特定的层使用的ReLU非线性之后应用了这种归一化（请看3.5小节）。</span></li><li>The <font color=forestgreen>ReLU</font> non-linearity is applied to the output of every convolutional and fully-connected layer.<span style="font-size:80%;opacity:0.8">ReLU非线性应用在每个卷积层和全连接层的输出上。</span></li></ul>
 </td>
</tr>
<tr>
<td> 44 </td> <td> descent </td> <td> [dɪˈsent] </td> <td> 
<ul><li>In terms of training time with gradient <font color=orangered>descent</font>, these saturating nonlinearities are much slower than the non-saturating nonlinearity $f(x) = \max(0,x)$.<span style="font-size:80%;opacity:0.8">考虑到梯度下降的训练时间，这些饱和的非线性比非饱和非线性$f(x) = \max(0,x)$更慢。</span></li><li>We trained our models using stochastic gradient <font color=orangered>descent</font> with a batch size of 128 examples, momentum of 0.9, and weight decay of 0.0005.<span style="font-size:80%;opacity:0.8">我们使用随机梯度下降来训练我们的模型，样本的batch size为128，动量为0.9，权重衰减为0.0005。</span></li></ul>
 </td>
</tr>
<tr>
<td> 45 </td> <td> saturate </td> <td> [ˈsætʃəreɪt] </td> <td> 
<ul><li>In terms of training time with gradient descent, these <font color=orangered>saturating</font> nonlinearities are much slower than the non-<font color=orangered>saturating</font> nonlinearity $f(x) = \max(0,x)$.<span style="font-size:80%;opacity:0.8">考虑到梯度下降的训练时间，这些饱和的非线性比非饱和非线性$f(x) = \max(0,x)$更慢。</span></li><li>This plot shows that we would not have been able to experiment with such large neural networks for this work if we had used traditional <font color=orangered>saturating</font> neuron models.<span style="font-size:80%;opacity:0.8">这幅图表明，如果我们采用传统的饱和神经元模型，我们将不能在如此大的神经网络上实验该工作。</span></li><li>The magnitude of the effect demonstrated here varies with network architecture, but networks with ReLUs consistently learn several times faster than equivalents with <font color=orangered>saturating</font> neurons.<span style="font-size:80%;opacity:0.8">影响的大小随着网络结构的变化而变化，这一点已得到证实，但使用ReLU的网络都比等价的饱和神经元快几倍。</span></li><li>ReLUs have the desirable property that they do not require input normalization to prevent them from <font color=orangered>saturating</font>.<span style="font-size:80%;opacity:0.8">ReLU具有让人满意的特性，它不需要通过输入归一化来防止饱和。</span></li></ul>
 </td>
</tr>
<tr>
<td> 46 </td> <td> nonlinearities </td> <td>  </td> <td> 
<ul><li>In terms of training time with gradient descent, these saturating <font color=forestgreen>nonlinearities</font> are much slower than the non-saturating nonlinearity $f(x) = \max(0,x)$.<span style="font-size:80%;opacity:0.8">考虑到梯度下降的训练时间，这些饱和的非线性比非饱和非线性$f(x) = \max(0,x)$更慢。</span></li></ul>
 </td>
</tr>
<tr>
<td> 47 </td> <td> nonlinearity </td> <td> [nɒnlɪnɪ'ærɪtɪ] </td> <td> 
<ul><li>In terms of training time with gradient descent, these saturating nonlinearities are much slower than the non-saturating <font color=orangered>nonlinearity</font> $f(x) = \max(0,x)$.<span style="font-size:80%;opacity:0.8">考虑到梯度下降的训练时间，这些饱和的非线性比非饱和非线性$f(x) = \max(0,x)$更慢。</span></li><li>Following Nair and Hinton [20], we refer to neurons with this <font color=orangered>nonlinearity</font> as Rectified Linear Units (ReLUs).<span style="font-size:80%;opacity:0.8">根据Nair和Hinton[20]的说法，我们将这种非线性神经元称为修正线性单元(ReLU)。</span></li><li>For example, Jarrett et al. [11] claim that the <font color=orangered>nonlinearity</font> $f(x) = \lvert \tanh(x) \rvert$ works particularly well with their type of contrast normalization followed by local average pooling on the Caltech-101 dataset.<span style="font-size:80%;opacity:0.8">例如，Jarrett等人[11]声称非线性函数$f(x) = \lvert \tanh(x) \rvert$与其对比度归一化一起，然后是局部均值池化，在Caltech-101数据集上工作的非常好。</span></li><li>Denoting by $a_{x,y}^i$ the activity of a neuron computed by applying kernel $i$ at position $(x, y)$ and then applying the ReLU <font color=orangered>nonlinearity</font>, the response-normalized activity $b^i_{x,y}$ is given by the expression<span style="font-size:80%;opacity:0.8">$a_{x,y}^i$表示神经元激活，通过在$(x, y)$位置应用核i，然后应用ReLU非线性来计算，响应归一化激活$b^i_{x,y}$通过下式给定：</span></li><li>We applied this normalization after applying the ReLU <font color=orangered>nonlinearity</font> in certain layers (see Section 3.5).<span style="font-size:80%;opacity:0.8">我们在特定的层使用的ReLU非线性之后应用了这种归一化（请看3.5小节）。</span></li><li>3.1 ReLU <font color=orangered>Nonlinearity</font><span style="font-size:80%;opacity:0.8">3.1 ReLU非线性</span></li></ul>
 </td>
</tr>
<tr>
<td> 48 </td> <td> Nair </td> <td> ['nɑ:ɪə] </td> <td> 
<ul><li>Following <font color=orangered>Nair</font> and Hinton [20], we refer to neurons with this nonlinearity as Rectified Linear Units (ReLUs).<span style="font-size:80%;opacity:0.8">根据Nair和Hinton[20]的说法，我们将这种非线性神经元称为修正线性单元(ReLU)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 49 </td> <td> rectify </td> <td> [ˈrektɪfaɪ] </td> <td> 
<ul><li>Following Nair and Hinton [20], we refer to neurons with this nonlinearity as <font color=orangered>Rectified</font> Linear Units (ReLUs).<span style="font-size:80%;opacity:0.8">根据Nair和Hinton[20]的说法，我们将这种非线性神经元称为修正线性单元(ReLU)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 50 </td> <td> ReLUs </td> <td>  </td> <td> 
<ul><li>Following Nair and Hinton [20], we refer to neurons with this nonlinearity as Rectified Linear Units (<font color=forestgreen>ReLUs</font>).<span style="font-size:80%;opacity:0.8">根据Nair和Hinton[20]的说法，我们将这种非线性神经元称为修正线性单元(ReLU)。</span></li><li>Deep convolutional neural networks with <font color=forestgreen>ReLUs</font> train several times faster than their equivalents with tanh units.<span style="font-size:80%;opacity:0.8">采用ReLU的深度卷积神经网络训练时间比等价的tanh单元要快几倍。</span></li><li>Figure 1: A four-layer convolutional neural network with <font color=forestgreen>ReLUs</font> (solid line) reaches a 25% training error rate on CIFAR-10 six times faster than an equivalent network with tanh neurons (dashed line).<span style="font-size:80%;opacity:0.8">图1：使用ReLU的四层卷积神经网络在CIFAR-10数据集上达到25%的训练误差比使用tanh神经元的等价网络（虚线）快六倍。</span></li><li>The magnitude of the effect demonstrated here varies with network architecture, but networks with <font color=forestgreen>ReLUs</font> consistently learn several times faster than equivalents with saturating neurons.<span style="font-size:80%;opacity:0.8">影响的大小随着网络结构的变化而变化，这一点已得到证实，但使用ReLU的网络都比等价的饱和神经元快几倍。</span></li><li>However, on this dataset the primary concern is preventing overfitting, so the effect they are observing is different from the accelerated ability to fit the training set which we report when using <font color=forestgreen>ReLUs</font>.<span style="font-size:80%;opacity:0.8">然而，在这个数据集上主要的关注点是防止过拟合，因此他们观测到的影响不同于我们使用ReLU拟合数据集时的加速能力。</span></li><li><font color=forestgreen>ReLUs</font> have the desirable property that they do not require input normalization to prevent them from saturating.<span style="font-size:80%;opacity:0.8">ReLU具有让人满意的特性，它不需要通过输入归一化来防止饱和。</span></li><li>This initialization accelerates the early stages of learning by providing the <font color=forestgreen>ReLUs</font> with positive inputs.<span style="font-size:80%;opacity:0.8">这个初始化通过为ReLU提供正输入加速了学习的早期阶段。</span></li></ul>
 </td>
</tr>
<tr>
<td> 51 </td> <td> dash </td> <td> [dæʃ] </td> <td> 
<ul><li>Figure 1: A four-layer convolutional neural network with ReLUs (solid line) reaches a 25% training error rate on CIFAR-10 six times faster than an equivalent network with tanh neurons (<font color=orangered>dashed</font> line).<span style="font-size:80%;opacity:0.8">图1：使用ReLU的四层卷积神经网络在CIFAR-10数据集上达到25%的训练误差比使用tanh神经元的等价网络（虚线）快六倍。</span></li></ul>
 </td>
</tr>
<tr>
<td> 52 </td> <td> consistently </td> <td> [kən'sɪstəntlɪ] </td> <td> 
<ul><li>The magnitude of the effect demonstrated here varies with network architecture, but networks with ReLUs <font color=orangered>consistently</font> learn several times faster than equivalents with saturating neurons.<span style="font-size:80%;opacity:0.8">影响的大小随着网络结构的变化而变化，这一点已得到证实，但使用ReLU的网络都比等价的饱和神经元快几倍。</span></li></ul>
 </td>
</tr>
<tr>
<td> 53 </td> <td> Jarrett </td> <td>  </td> <td> 
<ul><li>For example, <font color=forestgreen>Jarrett</font> et al. [11] claim that the nonlinearity $f(x) = \lvert \tanh(x) \rvert$ works particularly well with their type of contrast normalization followed by local average pooling on the Caltech-101 dataset.<span style="font-size:80%;opacity:0.8">例如，Jarrett等人[11]声称非线性函数$f(x) = \lvert \tanh(x) \rvert$与其对比度归一化一起，然后是局部均值池化，在Caltech-101数据集上工作的非常好。</span></li><li>This scheme bears some resemblance to the local contrast normalization scheme of <font color=forestgreen>Jarrett</font> et al. [11], but ours would be more correctly termed “brightness normalization”, since we do not subtract the mean activity.<span style="font-size:80%;opacity:0.8">这个方案与Jarrett等人[11]的局部对比度归一化方案有一定的相似性，但我们更恰当的称其为“亮度归一化”，因此我们没有减去均值。</span></li></ul>
 </td>
</tr>
<tr>
<td> 54 </td> <td> cross-GPU </td> <td>  </td> <td> 
<ul><li>Current GPUs are particularly well-suited to <font color=forestgreen>cross-GPU</font> parallelization, as they are able to read from and write to one another’s memory directly, without going through host machine memory.<span style="font-size:80%;opacity:0.8">目前的GPU非常适合跨GPU并行，因为它们可以直接互相读写内存，而不需要通过主机内存。</span></li></ul>
 </td>
</tr>
<tr>
<td> 55 </td> <td> parallelization </td> <td> [pærəlɪlaɪ'zeɪʃn] </td> <td> 
<ul><li>Current GPUs are particularly well-suited to cross-GPU <font color=orangered>parallelization</font>, as they are able to read from and write to one another’s memory directly, without going through host machine memory.<span style="font-size:80%;opacity:0.8">目前的GPU非常适合跨GPU并行，因为它们可以直接互相读写内存，而不需要通过主机内存。</span></li><li>The <font color=orangered>parallelization</font> scheme that we employ essentially puts half of the kernels (or neurons) on each GPU, with one additional trick: the GPUs communicate only in certain layers.<span style="font-size:80%;opacity:0.8">我们采用的并行方案基本上每个GPU放置一半的核（或神经元），还有一个额外的技巧：只在某些特定的层上进行GPU通信。</span></li></ul>
 </td>
</tr>
<tr>
<td> 56 </td> <td> connectivity </td> <td> [ˌkɒnekˈtɪvɪti] </td> <td> 
<ul><li>Choosing the pattern of <font color=orangered>connectivity</font> is a problem for cross-validation, but this allows us to precisely tune the amount of communication until it is an acceptable fraction of the amount of computation.<span style="font-size:80%;opacity:0.8">连接模式的选择是一个交叉验证问题，但这可以让我们准确地调整通信数量，直到它的计算量在可接受的范围内。</span></li><li>Notice the specialization exhibited by the two GPUs, a result of the restricted <font color=orangered>connectivity</font> described in Section 3.5.<span style="font-size:80%;opacity:0.8">注意两个GPU表现出的专业化，3.5小节中描述的受限连接的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 57 </td> <td> cross-validation </td> <td> [k'rɒsvælɪd'eɪʃn] </td> <td> 
<ul><li>Choosing the pattern of connectivity is a problem for <font color=orangered>cross-validation</font>, but this allows us to precisely tune the amount of communication until it is an acceptable fraction of the amount of computation.<span style="font-size:80%;opacity:0.8">连接模式的选择是一个交叉验证问题，但这可以让我们准确地调整通信数量，直到它的计算量在可接受的范围内。</span></li></ul>
 </td>
</tr>
<tr>
<td> 58 </td> <td> resultant </td> <td> [rɪˈzʌltənt] </td> <td> 
<ul><li>The <font color=orangered>resultant</font> architecture is somewhat similar to that of the “columnar” CNN employed by Ciresan et al. [5], except that our columns are not independent (see Figure 2).<span style="font-size:80%;opacity:0.8">除了我们的列不是独立的之外（看图2），最终的架构有点类似于Ciresan等人[5]采用的“columnar” CNN。</span></li></ul>
 </td>
</tr>
<tr>
<td> 59 </td> <td> columnar </td> <td> [kə'lʌmnə] </td> <td> 
<ul><li>The resultant architecture is somewhat similar to that of the “<font color=orangered>columnar</font>” CNN employed by Ciresan et al. [5], except that our columns are not independent (see Figure 2).<span style="font-size:80%;opacity:0.8">除了我们的列不是独立的之外（看图2），最终的架构有点类似于Ciresan等人[5]采用的“columnar” CNN。</span></li></ul>
 </td>
</tr>
<tr>
<td> 60 </td> <td> Ciresan </td> <td>  </td> <td> 
<ul><li>The resultant architecture is somewhat similar to that of the “columnar” CNN employed by <font color=forestgreen>Ciresan</font> et al. [5], except that our columns are not independent (see Figure 2).<span style="font-size:80%;opacity:0.8">除了我们的列不是独立的之外（看图2），最终的架构有点类似于Ciresan等人[5]采用的“columnar” CNN。</span></li></ul>
 </td>
</tr>
<tr>
<td> 61 </td> <td> delineation </td> <td> [dɪˌlɪnɪ'eɪʃn] </td> <td> 
<ul><li>Figure 2: An illustration of the architecture of our CNN, explicitly showing the <font color=orangered>delineation</font> of responsibilities between the two GPUs.<span style="font-size:80%;opacity:0.8">图 2：我们CNN架构图解，明确描述了两个GPU之间的责任。</span></li></ul>
 </td>
</tr>
<tr>
<td> 62 </td> <td> layer-parts </td> <td>  </td> <td> 
<ul><li>One GPU runs the <font color=forestgreen>layer-parts</font> at the top of the figure while the other runs the <font color=forestgreen>layer-parts</font> at the bottom.<span style="font-size:80%;opacity:0.8">在图的顶部，一个GPU运行在部分层上，而在图的底部，另一个GPU运行在部分层上。</span></li></ul>
 </td>
</tr>
<tr>
<td> 63 </td> <td> response-normalized </td> <td>  </td> <td> 
<ul><li>Denoting by $a_{x,y}^i$ the activity of a neuron computed by applying kernel $i$ at position $(x, y)$ and then applying the ReLU nonlinearity, the <font color=forestgreen>response-normalized</font> activity $b^i_{x,y}$ is given by the expression<span style="font-size:80%;opacity:0.8">$a_{x,y}^i$表示神经元激活，通过在$(x, y)$位置应用核i，然后应用ReLU非线性来计算，响应归一化激活$b^i_{x,y}$通过下式给定：</span></li><li>The second convolutional layer takes as input the (<font color=forestgreen>response-normalized</font> and pooled) output of the first convolutional layer and filters it with 256 kernels of size 5 × 5 × 48.<span style="font-size:80%;opacity:0.8">第2卷积层使用用第1卷积层的输出（响应归一化和池化）作为输入，并使用256个核进行滤波，核大小为5 × 5 × 48。</span></li></ul>
 </td>
</tr>
<tr>
<td> 64 </td> <td> arbitrary </td> <td> [ˈɑ:bɪtrəri] </td> <td> 
<ul><li>The ordering of the kernel maps is of course <font color=orangered>arbitrary</font> and determined before training begins.<span style="font-size:80%;opacity:0.8">核映射的顺序当然是任意的，在训练开始前确定。</span></li></ul>
 </td>
</tr>
<tr>
<td> 65 </td> <td> lateral </td> <td> [ˈlætərəl] </td> <td> 
<ul><li>This sort of response normalization implements a form of <font color=orangered>lateral</font> inhibition inspired by the type found in real neurons, creating competition for big activities amongst neuron outputs computed using different kernels.<span style="font-size:80%;opacity:0.8">响应归一化的顺序实现了一种侧抑制形式，灵感来自于真实神经元中发现的类型，为使用不同核进行神经元输出计算的较大活动创造了竞争。</span></li></ul>
 </td>
</tr>
<tr>
<td> 66 </td> <td> inhibition </td> <td> [ˌɪnhɪˈbɪʃn] </td> <td> 
<ul><li>This sort of response normalization implements a form of lateral <font color=orangered>inhibition</font> inspired by the type found in real neurons, creating competition for big activities amongst neuron outputs computed using different kernels.<span style="font-size:80%;opacity:0.8">响应归一化的顺序实现了一种侧抑制形式，灵感来自于真实神经元中发现的类型，为使用不同核进行神经元输出计算的较大活动创造了竞争。</span></li></ul>
 </td>
</tr>
<tr>
<td> 67 </td> <td> hyper-parameters </td> <td>  </td> <td> 
<ul><li>The constants $k, n, \alpha$, and $\beta$ are <font color=forestgreen>hyper-parameters</font> whose values are determined using a validation set; we used $k = 2, n = 5, \alpha = 0.0001$, and $\beta = 0.75$.<span style="font-size:80%;opacity:0.8">常量$k, n, \alpha, \beta$是超参数，它们的值通过验证集确定；我们设$k = 2, n = 5, \alpha = 0.0001, \beta = 0.75$。</span></li></ul>
 </td>
</tr>
<tr>
<td> 68 </td> <td> brightness </td> <td> ['braɪtnəs] </td> <td> 
<ul><li>This scheme bears some resemblance to the local contrast normalization scheme of Jarrett et al. [11], but ours would be more correctly termed “<font color=orangered>brightness</font> normalization”, since we do not subtract the mean activity.<span style="font-size:80%;opacity:0.8">这个方案与Jarrett等人[11]的局部对比度归一化方案有一定的相似性，但我们更恰当的称其为“亮度归一化”，因此我们没有减去均值。</span></li></ul>
 </td>
</tr>
<tr>
<td> 69 </td> <td> neighboring </td> <td> ['neɪbərɪŋ] </td> <td> 
<ul><li>Pooling layers in CNNs summarize the outputs of <font color=orangered>neighboring</font> groups of neurons in the same kernel map.<span style="font-size:80%;opacity:0.8">CNN中的池化层归纳了同一核映射上相邻组神经元的输出。</span></li><li>The first convolutional layer filters the 224 × 224 × 3 input image with 96 kernels of size 11 × 11 × 3 with a stride of 4 pixels (this is the distance between the receptive field centers of <font color=orangered>neighboring</font> neurons in a kernel map).<span style="font-size:80%;opacity:0.8">第1卷积层使用96个核对224 × 224 × 3的输入图像进行滤波，核大小为11 × 11 × 3，步长是4个像素（核映射中相邻神经元感受野中心之间的距离）。</span></li></ul>
 </td>
</tr>
<tr>
<td> 70 </td> <td> overfit </td> <td>  </td> <td> 
<ul><li>We generally observe during training that models with overlapping pooling find it slightly more difficult to <font color=forestgreen>overfit</font>.<span style="font-size:80%;opacity:0.8">我们在训练过程中通常观察采用重叠池化的模型，发现它更难过拟合。</span></li></ul>
 </td>
</tr>
<tr>
<td> 71 </td> <td> multinomial </td> <td> [ˌmʌltɪ'nəʊmɪəl] </td> <td> 
<ul><li>Our network maximizes the <font color=orangered>multinomial</font> logistic regression objective, which is equivalent to maximizing the average across training cases of the log-probability of the correct label under the prediction distribution.<span style="font-size:80%;opacity:0.8">我们的网络最大化多项逻辑回归的目标，这等价于最大化预测分布下训练样本正确标签的对数概率的均值。</span></li></ul>
 </td>
</tr>
<tr>
<td> 72 </td> <td> log-probability </td> <td>  </td> <td> 
<ul><li>Our network maximizes the multinomial logistic regression objective, which is equivalent to maximizing the average across training cases of the <font color=forestgreen>log-probability</font> of the correct label under the prediction distribution.<span style="font-size:80%;opacity:0.8">我们的网络最大化多项逻辑回归的目标，这等价于最大化预测分布下训练样本正确标签的对数概率的均值。</span></li></ul>
 </td>
</tr>
<tr>
<td> 73 </td> <td> response-normalization </td> <td>  </td> <td> 
<ul><li>Max-pooling layers, of the kind described in Section 3.4, follow both <font color=forestgreen>response-normalization</font> layers as well as the fifth convolutional layer.<span style="font-size:80%;opacity:0.8">3.4节描述的这种最大池化层在响应归一化层和第5卷积层之后。</span></li><li><font color=forestgreen>Response-normalization</font> layers follow the first and second convolutional layers.<span style="font-size:80%;opacity:0.8">第1，2卷积层之后是响应归一化层。</span></li></ul>
 </td>
</tr>
<tr>
<td> 74 </td> <td> non-linearity </td> <td> ['nɒnlaɪn'ərɪtɪ] </td> <td> 
<ul><li>The ReLU <font color=orangered>non-linearity</font> is applied to the output of every convolutional and fully-connected layer.<span style="font-size:80%;opacity:0.8">ReLU非线性应用在每个卷积层和全连接层的输出上。</span></li></ul>
 </td>
</tr>
<tr>
<td> 75 </td> <td> receptive </td> <td> [rɪˈseptɪv] </td> <td> 
<ul><li>The first convolutional layer filters the 224 × 224 × 3 input image with 96 kernels of size 11 × 11 × 3 with a stride of 4 pixels (this is the distance between the <font color=orangered>receptive</font> field centers of neighboring neurons in a kernel map).<span style="font-size:80%;opacity:0.8">第1卷积层使用96个核对224 × 224 × 3的输入图像进行滤波，核大小为11 × 11 × 3，步长是4个像素（核映射中相邻神经元感受野中心之间的距离）。</span></li></ul>
 </td>
</tr>
<tr>
<td> 76 </td> <td> normalize </td> <td> [ˈnɔ:məlaɪz] </td> <td> 
<ul><li>The third convolutional layer has 384 kernels of size 3 × 3 × 256 connected to the (<font color=orangered>normalized</font>, pooled) outputs of the second convolutional layer.<span style="font-size:80%;opacity:0.8">第3卷积层有384个核，核大小为3 × 3 × 256，与第2卷积层的输出（归一化的，池化的）相连。</span></li></ul>
 </td>
</tr>
<tr>
<td> 77 </td> <td> augmentation </td> <td> [ˌɔ:ɡmen'teɪʃn] </td> <td> 
<ul><li>4.1 Data <font color=orangered>Augmentation</font><span style="font-size:80%;opacity:0.8">4.1 数据增强</span></li><li>We employ two distinct forms of data <font color=orangered>augmentation</font>, both of which allow transformed images to be produced from the original images with very little computation, so the transformed images do not need to be stored on disk.<span style="font-size:80%;opacity:0.8">我们使用了两种独特的数据增强方式，这两种方式都可以从原始图像通过非常少的计算量产生变换的图像，因此变换图像不需要存储在硬盘上。</span></li><li>So these data <font color=orangered>augmentation</font> schemes are, in effect, computationally free.<span style="font-size:80%;opacity:0.8">因此，实际上这些数据增强方案是计算免费的。</span></li><li>The first form of data <font color=orangered>augmentation</font> consists of generating image translations and horizontal reflections.<span style="font-size:80%;opacity:0.8">第一种数据增强方式包括产生图像变换和水平翻转。</span></li><li>The second form of data <font color=orangered>augmentation</font> consists of altering the intensities of the RGB channels in training images.<span style="font-size:80%;opacity:0.8">第二种数据增强方式包括改变训练图像的RGB通道的强度。</span></li></ul>
 </td>
</tr>
<tr>
<td> 78 </td> <td> artificially </td> <td> [ˌɑ:tɪ'fɪʃəlɪ] </td> <td> 
<ul><li>The easiest and most common method to reduce overfitting on image data is to <font color=orangered>artificially</font> enlarge the dataset using label-preserving transformations (e.g., [25, 4, 5]).<span style="font-size:80%;opacity:0.8">图像数据上最简单常用的用来减少过拟合的方法是使用标签保留变换（例如[25, 4, 5]）来人工增大数据集。</span></li></ul>
 </td>
</tr>
<tr>
<td> 79 </td> <td> computationally </td> <td>  </td> <td> 
<ul><li>So these data augmentation schemes are, in effect, <font color=forestgreen>computationally</font> free.<span style="font-size:80%;opacity:0.8">因此，实际上这些数据增强方案是计算免费的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 80 </td> <td> interdependent </td> <td> [ˌɪntədɪˈpendənt] </td> <td> 
<ul><li>This increases the size of our training set by a factor of 2048, though the resulting training examples are, of course, highly <font color=orangered>interdependent</font>.<span style="font-size:80%;opacity:0.8">这通过一个2048因子增大了我们的训练集，尽管最终的训练样本是高度相关的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 81 </td> <td> Specifically </td> <td> [spəˈsɪfɪkli] </td> <td> 
<ul><li><font color=orangered>Specifically</font>, we perform PCA on the set of RGB pixel values throughout the ImageNet training set.<span style="font-size:80%;opacity:0.8">具体地，我们在整个ImageNet训练集上对RGB像素值集合执行PCA。</span></li></ul>
 </td>
</tr>
<tr>
<td> 82 </td> <td> pca </td> <td>  </td> <td> 
<ul><li>Specifically, we perform <font color=forestgreen>PCA</font> on the set of RGB pixel values throughout the ImageNet training set.<span style="font-size:80%;opacity:0.8">具体地，我们在整个ImageNet训练集上对RGB像素值集合执行PCA。</span></li></ul>
 </td>
</tr>
<tr>
<td> 83 </td> <td> proportional </td> <td> [prəˈpɔ:ʃənl] </td> <td> 
<ul><li>To each training image, we add multiples of the found principal components, with magnitudes <font color=orangered>proportional</font> to the corresponding eigenvalues times a random variable drawn from a Gaussian with mean zero and standard deviation 0.1.<span style="font-size:80%;opacity:0.8">对于每幅训练图像，我们加上多倍找到的主成分，大小成正比的对应特征值乘以一个随机变量，随机变量通过均值为0，标准差为0.1的高斯分布得到。</span></li></ul>
 </td>
</tr>
<tr>
<td> 84 </td> <td> eigenvalue </td> <td> ['aɪdʒənˌvælju:] </td> <td> 
<ul><li>To each training image, we add multiples of the found principal components, with magnitudes proportional to the corresponding <font color=orangered>eigenvalues</font> times a random variable drawn from a Gaussian with mean zero and standard deviation 0.1.<span style="font-size:80%;opacity:0.8">对于每幅训练图像，我们加上多倍找到的主成分，大小成正比的对应特征值乘以一个随机变量，随机变量通过均值为0，标准差为0.1的高斯分布得到。</span></li><li>where $p_i$ and $\lambda_i$ are ith eigenvector and <font color=orangered>eigenvalue</font> of the $3 × 3$ covariance matrix of RGB pixel values, respectively, and $\alpha_i$ is the aforementioned random variable.<span style="font-size:80%;opacity:0.8">$p_i$，$\lambda_i$分别是RGB像素值$3 × 3$协方差矩阵的第i个特征向量和特征值，$\alpha_i$是前面提到的随机变量。</span></li></ul>
 </td>
</tr>
<tr>
<td> 85 </td> <td> gaussian </td> <td> ['gaʊsɪən] </td> <td> 
<ul><li>To each training image, we add multiples of the found principal components, with magnitudes proportional to the corresponding eigenvalues times a random variable drawn from a <font color=orangered>Gaussian</font> with mean zero and standard deviation 0.1.<span style="font-size:80%;opacity:0.8">对于每幅训练图像，我们加上多倍找到的主成分，大小成正比的对应特征值乘以一个随机变量，随机变量通过均值为0，标准差为0.1的高斯分布得到。</span></li><li>We initialized the weights in each layer from a zero-mean <font color=orangered>Gaussian</font> distribution with standard deviation 0.01.<span style="font-size:80%;opacity:0.8">我们使用均值为0，标准差为0.01的高斯分布对每一层的权重进行初始化。</span></li></ul>
 </td>
</tr>
<tr>
<td> 86 </td> <td> deviation </td> <td> [ˌdi:viˈeɪʃn] </td> <td> 
<ul><li>To each training image, we add multiples of the found principal components, with magnitudes proportional to the corresponding eigenvalues times a random variable drawn from a Gaussian with mean zero and standard <font color=orangered>deviation</font> 0.1.<span style="font-size:80%;opacity:0.8">对于每幅训练图像，我们加上多倍找到的主成分，大小成正比的对应特征值乘以一个随机变量，随机变量通过均值为0，标准差为0.1的高斯分布得到。</span></li><li>We initialized the weights in each layer from a zero-mean Gaussian distribution with standard <font color=orangered>deviation</font> 0.01.<span style="font-size:80%;opacity:0.8">我们使用均值为0，标准差为0.01的高斯分布对每一层的权重进行初始化。</span></li></ul>
 </td>
</tr>
<tr>
<td> 87 </td> <td> ith </td> <td>  </td> <td> 
<ul><li>where $p_i$ and $\lambda_i$ are <font color=forestgreen>ith</font> eigenvector and eigenvalue of the $3 × 3$ covariance matrix of RGB pixel values, respectively, and $\alpha_i$ is the aforementioned random variable.<span style="font-size:80%;opacity:0.8">$p_i$，$\lambda_i$分别是RGB像素值$3 × 3$协方差矩阵的第i个特征向量和特征值，$\alpha_i$是前面提到的随机变量。</span></li><li>where $i$ is the iteration index, $v$ is the momentum variable, $\varepsilon$ is the learning rate, and $\langle \frac{\partial L} {\partial w} |_{w_i}\rangle _{D_i}$ is the average over the <font color=forestgreen>ith</font> batch $D_i$ of the derivative of the objective with respect to $w$, evaluated at $w_i$.<span style="font-size:80%;opacity:0.8">$i$是迭代索引，$v$是动量变量，$\varepsilon$是学习率，$\langle \frac{\partial L} {\partial w} |_{w_i}\rangle _{D_i}$是目标函数对$w$，在$w_i$上的第$i$批微分$D_i$的平均。</span></li></ul>
 </td>
</tr>
<tr>
<td> 88 </td> <td> eigenvector </td> <td> ['aɪgənvektə(r)] </td> <td> 
<ul><li>where $p_i$ and $\lambda_i$ are ith <font color=orangered>eigenvector</font> and eigenvalue of the $3 × 3$ covariance matrix of RGB pixel values, respectively, and $\alpha_i$ is the aforementioned random variable.<span style="font-size:80%;opacity:0.8">$p_i$，$\lambda_i$分别是RGB像素值$3 × 3$协方差矩阵的第i个特征向量和特征值，$\alpha_i$是前面提到的随机变量。</span></li></ul>
 </td>
</tr>
<tr>
<td> 89 </td> <td> covariance </td> <td> [kəʊ'veərɪəns] </td> <td> 
<ul><li>where $p_i$ and $\lambda_i$ are ith eigenvector and eigenvalue of the $3 × 3$ <font color=orangered>covariance</font> matrix of RGB pixel values, respectively, and $\alpha_i$ is the aforementioned random variable.<span style="font-size:80%;opacity:0.8">$p_i$，$\lambda_i$分别是RGB像素值$3 × 3$协方差矩阵的第i个特征向量和特征值，$\alpha_i$是前面提到的随机变量。</span></li></ul>
 </td>
</tr>
<tr>
<td> 90 </td> <td> aforementioned </td> <td> [əˌfɔ:ˈmenʃənd] </td> <td> 
<ul><li>where $p_i$ and $\lambda_i$ are ith eigenvector and eigenvalue of the $3 × 3$ covariance matrix of RGB pixel values, respectively, and $\alpha_i$ is the <font color=orangered>aforementioned</font> random variable.<span style="font-size:80%;opacity:0.8">$p_i$，$\lambda_i$分别是RGB像素值$3 × 3$协方差矩阵的第i个特征向量和特征值，$\alpha_i$是前面提到的随机变量。</span></li><li>Averaging the predictions of two CNNs that were pre-trained on the entire Fall 2011 release with the <font color=orangered>aforementioned</font> five CNNs gives an error rate of 15.3%.<span style="font-size:80%;opacity:0.8">对在ImageNet 2011秋季发布的整个数据集上预训练的两个CNN和前面提到的五个CNN的预测进行平均得到了15.3%的错误率。</span></li></ul>
 </td>
</tr>
<tr>
<td> 91 </td> <td> re-draw </td> <td> [ri'drɔ] </td> <td> 
<ul><li>Each $\alpha_i$ is drawn only once for all the pixels of a particular training image until that image is used for training again, at which point it is <font color=orangered>re-drawn</font>.<span style="font-size:80%;opacity:0.8">对于某个训练图像的所有像素，每个$\alpha_i$只获取一次，直到图像进行下一次训练时才重新获取。</span></li></ul>
 </td>
</tr>
<tr>
<td> 92 </td> <td> invariant </td> <td> [ɪnˈveəriənt] </td> <td> 
<ul><li>This scheme approximately captures an important property of natural images, namely, that object identity is <font color=orangered>invariant</font> to changes in the intensity and color of the illumination.<span style="font-size:80%;opacity:0.8">这个方案近似抓住了自然图像的一个重要特性，即光照的颜色和强度发生变化时，目标身份是不变的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 93 </td> <td> back-propagation </td> <td>  </td> <td> 
<ul><li>The neurons which are “dropped out” in this way do not contribute to the forward pass and do not participate in <font color=forestgreen>back-propagation</font>.<span style="font-size:80%;opacity:0.8">那些“失活的”的神经元不再进行前向传播并且不参与反向传播。</span></li></ul>
 </td>
</tr>
<tr>
<td> 94 </td> <td> co-adaptations </td> <td>  </td> <td> 
<ul><li>This technique reduces complex <font color=forestgreen>co-adaptations</font> of neurons, since a neuron cannot rely on the presence of particular other neurons.<span style="font-size:80%;opacity:0.8">这个技术减少了复杂的神经元互适应，因为一个神经元不能依赖特定的其它神经元的存在。</span></li></ul>
 </td>
</tr>
<tr>
<td> 95 </td> <td> conjunction </td> <td> [kənˈdʒʌŋkʃn] </td> <td> 
<ul><li>It is, therefore, forced to learn more robust features that are useful in <font color=orangered>conjunction</font> with many different random subsets of the other neurons.<span style="font-size:80%;opacity:0.8">因此，神经元被强迫学习更鲁棒的特征，它在与许多不同的其它神经元的随机子集结合时是有用的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 96 </td> <td> approximation </td> <td> [əˌprɒksɪˈmeɪʃn] </td> <td> 
<ul><li>At test time, we use all the neurons but multiply their outputs by 0.5, which is a reasonable <font color=orangered>approximation</font> to taking the geometric mean of the predictive distributions produced by the exponentially-many dropout networks.<span style="font-size:80%;opacity:0.8">在测试时，我们使用所有的神经元但它们的输出乘以0.5，对指数级的许多失活网络的预测分布进行几何平均，这是一种合理的近似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 97 </td> <td> geometric </td> <td> [ˌdʒi:əˈmetrɪk] </td> <td> 
<ul><li>At test time, we use all the neurons but multiply their outputs by 0.5, which is a reasonable approximation to taking the <font color=orangered>geometric</font> mean of the predictive distributions produced by the exponentially-many dropout networks.<span style="font-size:80%;opacity:0.8">在测试时，我们使用所有的神经元但它们的输出乘以0.5，对指数级的许多失活网络的预测分布进行几何平均，这是一种合理的近似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 98 </td> <td> predictive </td> <td> [prɪˈdɪktɪv] </td> <td> 
<ul><li>At test time, we use all the neurons but multiply their outputs by 0.5, which is a reasonable approximation to taking the geometric mean of the <font color=orangered>predictive</font> distributions produced by the exponentially-many dropout networks.<span style="font-size:80%;opacity:0.8">在测试时，我们使用所有的神经元但它们的输出乘以0.5，对指数级的许多失活网络的预测分布进行几何平均，这是一种合理的近似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 99 </td> <td> exponentially-many </td> <td>  </td> <td> 
<ul><li>At test time, we use all the neurons but multiply their outputs by 0.5, which is a reasonable approximation to taking the geometric mean of the predictive distributions produced by the <font color=forestgreen>exponentially-many</font> dropout networks.<span style="font-size:80%;opacity:0.8">在测试时，我们使用所有的神经元但它们的输出乘以0.5，对指数级的许多失活网络的预测分布进行几何平均，这是一种合理的近似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 100 </td> <td> stochastic </td> <td> [stə'kæstɪk] </td> <td> 
<ul><li>We trained our models using <font color=orangered>stochastic</font> gradient descent with a batch size of 128 examples, momentum of 0.9, and weight decay of 0.0005.<span style="font-size:80%;opacity:0.8">我们使用随机梯度下降来训练我们的模型，样本的batch size为128，动量为0.9，权重衰减为0.0005。</span></li></ul>
 </td>
</tr>
<tr>
<td> 101 </td> <td> momentum </td> <td> [məˈmentəm] </td> <td> 
<ul><li>We trained our models using stochastic gradient descent with a batch size of 128 examples, <font color=orangered>momentum</font> of 0.9, and weight decay of 0.0005.<span style="font-size:80%;opacity:0.8">我们使用随机梯度下降来训练我们的模型，样本的batch size为128，动量为0.9，权重衰减为0.0005。</span></li><li>where $i$ is the iteration index, $v$ is the <font color=orangered>momentum</font> variable, $\varepsilon$ is the learning rate, and $\langle \frac{\partial L} {\partial w} |_{w_i}\rangle _{D_i}$ is the average over the ith batch $D_i$ of the derivative of the objective with respect to $w$, evaluated at $w_i$.<span style="font-size:80%;opacity:0.8">$i$是迭代索引，$v$是动量变量，$\varepsilon$是学习率，$\langle \frac{\partial L} {\partial w} |_{w_i}\rangle _{D_i}$是目标函数对$w$，在$w_i$上的第$i$批微分$D_i$的平均。</span></li></ul>
 </td>
</tr>
<tr>
<td> 102 </td> <td> regularizer </td> <td>  </td> <td> 
<ul><li>In other words, weight decay here is not merely a <font color=forestgreen>regularizer</font>: it reduces the model’s training error.<span style="font-size:80%;opacity:0.8">换句话说，权重衰减不仅仅是一个正则项：它减少了模型的训练误差。</span></li></ul>
 </td>
</tr>
<tr>
<td> 103 </td> <td> derivative </td> <td> [dɪˈrɪvətɪv] </td> <td> 
<ul><li>where $i$ is the iteration index, $v$ is the momentum variable, $\varepsilon$ is the learning rate, and $\langle \frac{\partial L} {\partial w} |_{w_i}\rangle _{D_i}$ is the average over the ith batch $D_i$ of the <font color=orangered>derivative</font> of the objective with respect to $w$, evaluated at $w_i$.<span style="font-size:80%;opacity:0.8">$i$是迭代索引，$v$是动量变量，$\varepsilon$是学习率，$\langle \frac{\partial L} {\partial w} |_{w_i}\rangle _{D_i}$是目标函数对$w$，在$w_i$上的第$i$批微分$D_i$的平均。</span></li></ul>
 </td>
</tr>
<tr>
<td> 104 </td> <td> initialize </td> <td> [ɪˈnɪʃəlaɪz] </td> <td> 
<ul><li>We <font color=orangered>initialized</font> the weights in each layer from a zero-mean Gaussian distribution with standard deviation 0.01.<span style="font-size:80%;opacity:0.8">我们使用均值为0，标准差为0.01的高斯分布对每一层的权重进行初始化。</span></li><li>We <font color=orangered>initialized</font> the neuron biases in the second, fourth, and fifth convolutional layers, as well as in the fully-connected hidden layers, with the constant 1.<span style="font-size:80%;opacity:0.8">我们在第2，4，5卷积层和全连接隐层将神经元偏置初始化为常量1。</span></li><li>We <font color=orangered>initialized</font> the neuron biases in the remaining layers with the constant 0.<span style="font-size:80%;opacity:0.8">我们在剩下的层将神经元偏置初始化为0。</span></li><li>The learning rate was <font color=orangered>initialized</font> at 0.01 and reduced three times prior to termination.<span style="font-size:80%;opacity:0.8">学习率初始化为0.01，在训练停止之前降低三次。</span></li></ul>
 </td>
</tr>
<tr>
<td> 105 </td> <td> initialization </td> <td> [ɪˌnɪʃəlaɪ'zeɪʃn] </td> <td> 
<ul><li>This <font color=orangered>initialization</font> accelerates the early stages of learning by providing the ReLUs with positive inputs.<span style="font-size:80%;opacity:0.8">这个初始化通过为ReLU提供正输入加速了学习的早期阶段。</span></li><li>This kind of specialization occurs during every run and is independent of any particular random weight <font color=orangered>initialization</font> (modulo a renumbering of the GPUs).<span style="font-size:80%;opacity:0.8">这种专业化在每次运行时都会发生，并且是与任何特别的随机权重初始化（以GPU的重新编号为模）无关的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 106 </td> <td> heuristic </td> <td> [hjuˈrɪstɪk] </td> <td> 
<ul><li>The <font color=orangered>heuristic</font> which we followed was to divide the learning rate by 10 when the validation error rate stopped improving with the current learning rate.<span style="font-size:80%;opacity:0.8">当验证误差在当前的学习率下停止提供时，我们遵循启发式的方法将学习率除以10。</span></li></ul>
 </td>
</tr>
<tr>
<td> 107 </td> <td> termination </td> <td> [ˌtɜ:mɪˈneɪʃn] </td> <td> 
<ul><li>The learning rate was initialized at 0.01 and reduced three times prior to <font color=orangered>termination</font>.<span style="font-size:80%;opacity:0.8">学习率初始化为0.01，在训练停止之前降低三次。</span></li></ul>
 </td>
</tr>
<tr>
<td> 108 </td> <td> NVIDIA </td> <td> [ɪn'vɪdɪə] </td> <td> 
<ul><li>We trained the network for roughly 90 cycles through the training set of 1.2 million images, which took five to six days on two <font color=orangered>NVIDIA</font> GTX 580 3GB GPUs.<span style="font-size:80%;opacity:0.8">我们在120万图像的训练数据集上训练神经网络大约90个循环，在两个NVIDIA GTX 580 3GB GPU上花费了五到六天。</span></li></ul>
 </td>
</tr>
<tr>
<td> 109 </td> <td> sparse-coding </td> <td>  </td> <td> 
<ul><li>The best performance achieved during the ILSVRC-2010 competition was 47.1% and 28.2% with an approach that averages the predictions produced from six <font color=forestgreen>sparse-coding</font> models trained on different features [2], and since then the best published results are 45.7% and 25.7% with an approach that averages the predictions of two classifiers trained on Fisher Vectors (FVs) computed from two types of densely-sampled features [24].<span style="font-size:80%;opacity:0.8">在ILSVRC-2010竞赛中最佳结果是top-1 47.1%，top-5 28.2%，使用的方法是对6个在不同特征上训练的稀疏编码模型生成的预测进行平均，从那时起已公布的最好结果是top-1 45.7%，top-5 25.7%，使用的方法是平均在Fisher向量（FV）上训练的两个分类器的预测结果，Fisher向量是通过两种密集采样特征计算得到的[24]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 110 </td> <td> vector </td> <td> [ˈvektə(r)] </td> <td> 
<ul><li>The best performance achieved during the ILSVRC-2010 competition was 47.1% and 28.2% with an approach that averages the predictions produced from six sparse-coding models trained on different features [2], and since then the best published results are 45.7% and 25.7% with an approach that averages the predictions of two classifiers trained on Fisher <font color=orangered>Vectors</font> (FVs) computed from two types of densely-sampled features [24].<span style="font-size:80%;opacity:0.8">在ILSVRC-2010竞赛中最佳结果是top-1 47.1%，top-5 28.2%，使用的方法是对6个在不同特征上训练的稀疏编码模型生成的预测进行平均，从那时起已公布的最好结果是top-1 45.7%，top-5 25.7%，使用的方法是平均在Fisher向量（FV）上训练的两个分类器的预测结果，Fisher向量是通过两种密集采样特征计算得到的[24]。</span></li><li>The remaining columns show the six training images that produce feature <font color=orangered>vectors</font> in the last hidden layer with the smallest Euclidean distance from the feature vector for the test image.<span style="font-size:80%;opacity:0.8">剩下的列展示了6张训练图像，这些图像在最后的隐藏层的特征向量与测试图像的特征向量有最小的欧氏距离。</span></li><li>The remaining columns show the six training images that produce feature vectors in the last hidden layer with the smallest Euclidean distance from the feature <font color=orangered>vector</font> for the test image.<span style="font-size:80%;opacity:0.8">剩下的列展示了6张训练图像，这些图像在最后的隐藏层的特征向量与测试图像的特征向量有最小的欧氏距离。</span></li><li>If two images produce feature activation <font color=orangered>vectors</font> with a small Euclidean separation, we can say that the higher levels of the neural network consider them to be similar.<span style="font-size:80%;opacity:0.8">如果两幅图像生成的特征激活向量之间有较小的欧式距离，我们可以认为神经网络的更高层特征认为它们是相似的。</span></li><li>Computing similarity by using Euclidean distance between two 4096-dimensional, real-valued <font color=orangered>vectors</font> is inefficient, but it could be made efficient by training an auto-encoder to compress these <font color=orangered>vectors</font> to short binary codes.<span style="font-size:80%;opacity:0.8">通过两个4096维实值向量间的欧氏距离来计算相似性是效率低下的，但通过训练一个自动编码器将这些向量压缩为短二值编码可以使其变得高效。</span></li></ul>
 </td>
</tr>
<tr>
<td> 111 </td> <td> FVs </td> <td>  </td> <td> 
<ul><li>The best performance achieved during the ILSVRC-2010 competition was 47.1% and 28.2% with an approach that averages the predictions produced from six sparse-coding models trained on different features [2], and since then the best published results are 45.7% and 25.7% with an approach that averages the predictions of two classifiers trained on Fisher Vectors (<font color=forestgreen>FVs</font>) computed from two types of densely-sampled features [24].<span style="font-size:80%;opacity:0.8">在ILSVRC-2010竞赛中最佳结果是top-1 47.1%，top-5 28.2%，使用的方法是对6个在不同特征上训练的稀疏编码模型生成的预测进行平均，从那时起已公布的最好结果是top-1 45.7%，top-5 25.7%，使用的方法是平均在Fisher向量（FV）上训练的两个分类器的预测结果，Fisher向量是通过两种密集采样特征计算得到的[24]。</span></li><li>The second-best contest entry achieved an error rate of 26.2% with an approach that averages the predictions of several classifiers trained on <font color=forestgreen>FVs</font> computed from different types of densely-sampled features [7].<span style="font-size:80%;opacity:0.8">第二名的最好竞赛输入取得了26.2%的错误率，他的方法是对FV上训练的一些分类器的预测结果进行平均，FV在不同类型密集采样特征计算得到的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 112 </td> <td> densely-sampled </td> <td>  </td> <td> 
<ul><li>The best performance achieved during the ILSVRC-2010 competition was 47.1% and 28.2% with an approach that averages the predictions produced from six sparse-coding models trained on different features [2], and since then the best published results are 45.7% and 25.7% with an approach that averages the predictions of two classifiers trained on Fisher Vectors (FVs) computed from two types of <font color=forestgreen>densely-sampled</font> features [24].<span style="font-size:80%;opacity:0.8">在ILSVRC-2010竞赛中最佳结果是top-1 47.1%，top-5 28.2%，使用的方法是对6个在不同特征上训练的稀疏编码模型生成的预测进行平均，从那时起已公布的最好结果是top-1 45.7%，top-5 25.7%，使用的方法是平均在Fisher向量（FV）上训练的两个分类器的预测结果，Fisher向量是通过两种密集采样特征计算得到的[24]。</span></li><li>The second-best contest entry achieved an error rate of 26.2% with an approach that averages the predictions of several classifiers trained on FVs computed from different types of <font color=forestgreen>densely-sampled</font> features [7].<span style="font-size:80%;opacity:0.8">第二名的最好竞赛输入取得了26.2%的错误率，他的方法是对FV上训练的一些分类器的预测结果进行平均，FV在不同类型密集采样特征计算得到的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 113 </td> <td> italic </td> <td> [ɪˈtælɪk] </td> <td> 
<ul><li>In <font color=orangered>italics</font> are best results achieved by others.<span style="font-size:80%;opacity:0.8">斜体是其它人取得的最好结果。</span></li><li>In <font color=orangered>italics</font> are best results achieved by others.<span style="font-size:80%;opacity:0.8">斜线部分是其它人取得的最好的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 114 </td> <td> interchangeably </td> <td> [ɪntəˈtʃeɪndʒəblɪ] </td> <td> 
<ul><li>In the remainder of this paragraph, we use validation and test error rates <font color=orangered>interchangeably</font> because in our experience they do not differ by more than 0.1% (see Table 2).<span style="font-size:80%;opacity:0.8">在这段的其余部分，我们会使用验证误差率和测试误差率互换，因为在我们的实验中它们的差别不会超过0.1%（看图2）。</span></li></ul>
 </td>
</tr>
<tr>
<td> 115 </td> <td> fine-tune </td> <td> [faɪn tju:n] </td> <td> 
<ul><li>Training one CNN, with an extra sixth convolutional layer over the last pooling layer, to classify the entire ImageNet Fall 2011 release (15M images, 22K categories), and then “<font color=orangered>fine-tuning</font>” it on ILSVRC-2012 gives an error rate of 16.6%.<span style="font-size:80%;opacity:0.8">为了对ImageNet 2011秋季发布的整个数据集（1500万图像，22000个类别）进行分类，我们在最后的池化层之后有一个额外的第6卷积层，训练了一个CNN，然后在它上面进行“fine-tuning”，在ILSVRC-2012取得了16.6%的错误率。</span></li></ul>
 </td>
</tr>
<tr>
<td> 116 </td> <td> asterisk </td> <td> [ˈæstərɪsk] </td> <td> 
<ul><li>Models with an <font color=orangered>asterisk</font> were “pre-trained” to classify the entire ImageNet 2011 Fall release.<span style="font-size:80%;opacity:0.8">带星号的是“预训练的”对ImageNet 2011秋季数据集进行分类的模型。</span></li></ul>
 </td>
</tr>
<tr>
<td> 117 </td> <td> convention </td> <td> [kənˈvenʃn] </td> <td> 
<ul><li>On this dataset we follow the <font color=orangered>convention</font> in the literature of using half of the images for training and half for testing.<span style="font-size:80%;opacity:0.8">在这个数据集上我们按照惯例用一半的图像来训练，一半的图像来测试。</span></li></ul>
 </td>
</tr>
<tr>
<td> 118 </td> <td> appreciably </td> <td> [ə'pri:ʃəblɪ] </td> <td> 
<ul><li>Since there is no established test set, our split necessarily differs from the splits used by previous authors, but this does not affect the results <font color=orangered>appreciably</font>.<span style="font-size:80%;opacity:0.8">由于没有建立测试集，我们的数据集分割有必要不同于以前作者的数据集分割，但这对结果没有明显的影响。</span></li></ul>
 </td>
</tr>
<tr>
<td> 119 </td> <td> Qualitative </td> <td> [ˈkwɒlɪtətɪv] </td> <td> 
<ul><li>6.1 <font color=orangered>Qualitative</font> Evaluations<span style="font-size:80%;opacity:0.8">6.1 定性评估</span></li></ul>
 </td>
</tr>
<tr>
<td> 120 </td> <td> data-connected </td> <td>  </td> <td> 
<ul><li>Figure 3 shows the convolutional kernels learned by the network’s two <font color=forestgreen>data-connected</font> layers.<span style="font-size:80%;opacity:0.8">图3显示了网络的两个数据连接层学习到的卷积核。</span></li></ul>
 </td>
</tr>
<tr>
<td> 121 </td> <td> orientation-selective </td> <td>  </td> <td> 
<ul><li>The network has learned a variety of frequency and <font color=forestgreen>orientation-selective</font> kernels, as well as various colored blobs.<span style="font-size:80%;opacity:0.8">网络学习到了大量的频率核、方向选择核，也学到了各种颜色点。</span></li></ul>
 </td>
</tr>
<tr>
<td> 122 </td> <td> blob </td> <td> [blɒb] </td> <td> 
<ul><li>The network has learned a variety of frequency and orientation-selective kernels, as well as various colored <font color=orangered>blobs</font>.<span style="font-size:80%;opacity:0.8">网络学习到了大量的频率核、方向选择核，也学到了各种颜色点。</span></li></ul>
 </td>
</tr>
<tr>
<td> 123 </td> <td> specialization </td> <td> [ˌspeʃəlaɪ'zeɪʃn] </td> <td> 
<ul><li>Notice the <font color=orangered>specialization</font> exhibited by the two GPUs, a result of the restricted connectivity described in Section 3.5.<span style="font-size:80%;opacity:0.8">注意两个GPU表现出的专业化，3.5小节中描述的受限连接的结果。</span></li><li>This kind of <font color=orangered>specialization</font> occurs during every run and is independent of any particular random weight initialization (modulo a renumbering of the GPUs).<span style="font-size:80%;opacity:0.8">这种专业化在每次运行时都会发生，并且是与任何特别的随机权重初始化（以GPU的重新编号为模）无关的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 124 </td> <td> color-agnostic </td> <td>  </td> <td> 
<ul><li>The kernels on GPU 1 are largely <font color=forestgreen>color-agnostic</font>, while the kernels on on GPU 2 are largely color-specific.<span style="font-size:80%;opacity:0.8">GPU 1上的核主要是没有颜色的，而GPU 2上的核主要是针对颜色的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 125 </td> <td> color-specific </td> <td>  </td> <td> 
<ul><li>The kernels on GPU 1 are largely color-agnostic, while the kernels on on GPU 2 are largely <font color=forestgreen>color-specific</font>.<span style="font-size:80%;opacity:0.8">GPU 1上的核主要是没有颜色的，而GPU 2上的核主要是针对颜色的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 126 </td> <td> modulo </td> <td> ['mɒdjʊləʊ] </td> <td> 
<ul><li>This kind of specialization occurs during every run and is independent of any particular random weight initialization (<font color=orangered>modulo</font> a renumbering of the GPUs).<span style="font-size:80%;opacity:0.8">这种专业化在每次运行时都会发生，并且是与任何特别的随机权重初始化（以GPU的重新编号为模）无关的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 127 </td> <td> renumber </td> <td> ['ri:'nʌmbə] </td> <td> 
<ul><li>This kind of specialization occurs during every run and is independent of any particular random weight initialization (modulo a <font color=orangered>renumbering</font> of the GPUs).<span style="font-size:80%;opacity:0.8">这种专业化在每次运行时都会发生，并且是与任何特别的随机权重初始化（以GPU的重新编号为模）无关的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 128 </td> <td> qualitatively </td> <td> ['kwɒlɪtətɪvlɪ] </td> <td> 
<ul><li>In the left panel of Figure 4 we <font color=orangered>qualitatively</font> assess what the network has learned by computing its top-5 predictions on eight test images.<span style="font-size:80%;opacity:0.8">在图4的左边部分，我们通过在8张测试图像上计算它的top-5预测定性地评估了网络学习到的东西。</span></li></ul>
 </td>
</tr>
<tr>
<td> 129 </td> <td> off-center </td> <td> ['ɔ:fs'entə] </td> <td> 
<ul><li>Notice that even <font color=orangered>off-center</font> objects, such as the mite in the top-left, can be recognized by the net.<span style="font-size:80%;opacity:0.8">注意即使是不在图像中心的目标也能被网络识别，例如左上角的小虫。</span></li></ul>
 </td>
</tr>
<tr>
<td> 130 </td> <td> mite </td> <td> [maɪt] </td> <td> 
<ul><li>Notice that even off-center objects, such as the <font color=orangered>mite</font> in the top-left, can be recognized by the net.<span style="font-size:80%;opacity:0.8">注意即使是不在图像中心的目标也能被网络识别，例如左上角的小虫。</span></li></ul>
 </td>
</tr>
<tr>
<td> 131 </td> <td> top-left </td> <td>  </td> <td> 
<ul><li>Notice that even off-center objects, such as the mite in the <font color=forestgreen>top-left</font>, can be recognized by the net.<span style="font-size:80%;opacity:0.8">注意即使是不在图像中心的目标也能被网络识别，例如左上角的小虫。</span></li></ul>
 </td>
</tr>
<tr>
<td> 132 </td> <td> plausible </td> <td> [ˈplɔ:zəbl] </td> <td> 
<ul><li>For example, only other types of cat are considered <font color=orangered>plausible</font> labels for the leopard.<span style="font-size:80%;opacity:0.8">例如，对于美洲豹来说，只有其它类型的猫被认为是看似合理的标签。</span></li></ul>
 </td>
</tr>
<tr>
<td> 133 </td> <td> leopard </td> <td> [ˈlepəd] </td> <td> 
<ul><li>For example, only other types of cat are considered plausible labels for the <font color=orangered>leopard</font>.<span style="font-size:80%;opacity:0.8">例如，对于美洲豹来说，只有其它类型的猫被认为是看似合理的标签。</span></li></ul>
 </td>
</tr>
<tr>
<td> 134 </td> <td> grille </td> <td> [ɡrɪl] </td> <td> 
<ul><li>In some cases (<font color=orangered>grille</font>, cherry) there is genuine ambiguity about the intended focus of the photograph.<span style="font-size:80%;opacity:0.8">在某些案例（格栅，樱桃）中，网络在意的图片焦点真的很含糊。</span></li></ul>
 </td>
</tr>
<tr>
<td> 135 </td> <td> Euclidean </td> <td> [ju:ˈklidiən] </td> <td> 
<ul><li>The remaining columns show the six training images that produce feature vectors in the last hidden layer with the smallest <font color=orangered>Euclidean</font> distance from the feature vector for the test image.<span style="font-size:80%;opacity:0.8">剩下的列展示了6张训练图像，这些图像在最后的隐藏层的特征向量与测试图像的特征向量有最小的欧氏距离。</span></li><li>If two images produce feature activation vectors with a small <font color=orangered>Euclidean</font> separation, we can say that the higher levels of the neural network consider them to be similar.<span style="font-size:80%;opacity:0.8">如果两幅图像生成的特征激活向量之间有较小的欧式距离，我们可以认为神经网络的更高层特征认为它们是相似的。</span></li><li>Computing similarity by using <font color=orangered>Euclidean</font> distance between two 4096-dimensional, real-valued vectors is inefficient, but it could be made efficient by training an auto-encoder to compress these vectors to short binary codes.<span style="font-size:80%;opacity:0.8">通过两个4096维实值向量间的欧氏距离来计算相似性是效率低下的，但通过训练一个自动编码器将这些向量压缩为短二值编码可以使其变得高效。</span></li></ul>
 </td>
</tr>
<tr>
<td> 136 </td> <td> probe </td> <td> [prəʊb] </td> <td> 
<ul><li>Another way to <font color=orangered>probe</font> the network’s visual knowledge is to consider the feature activations induced by an image at the last, 4096-dimensional hidden layer.<span style="font-size:80%;opacity:0.8">探索网络可视化知识的另一种方式是思考最后的4096维隐藏层在图像上得到的特征激活。</span></li></ul>
 </td>
</tr>
<tr>
<td> 137 </td> <td> activations </td> <td> [,æktɪ'veɪʃən] </td> <td> 
<ul><li>Another way to probe the network’s visual knowledge is to consider the feature <font color=orangered>activations</font> induced by an image at the last, 4096-dimensional hidden layer.<span style="font-size:80%;opacity:0.8">探索网络可视化知识的另一种方式是思考最后的4096维隐藏层在图像上得到的特征激活。</span></li></ul>
 </td>
</tr>
<tr>
<td> 138 </td> <td> induce </td> <td> [ɪnˈdju:s] </td> <td> 
<ul><li>Another way to probe the network’s visual knowledge is to consider the feature activations <font color=orangered>induced</font> by an image at the last, 4096-dimensional hidden layer.<span style="font-size:80%;opacity:0.8">探索网络可视化知识的另一种方式是思考最后的4096维隐藏层在图像上得到的特征激活。</span></li></ul>
 </td>
</tr>
<tr>
<td> 139 </td> <td> activation </td> <td> [ˌæktɪ'veɪʃn] </td> <td> 
<ul><li>If two images produce feature <font color=orangered>activation</font> vectors with a small Euclidean separation, we can say that the higher levels of the neural network consider them to be similar.<span style="font-size:80%;opacity:0.8">如果两幅图像生成的特征激活向量之间有较小的欧式距离，我们可以认为神经网络的更高层特征认为它们是相似的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 140 </td> <td> retrieve </td> <td> [rɪˈtri:v] </td> <td> 
<ul><li>Notice that at the pixel level, the <font color=orangered>retrieved</font> training images are generally not close in L2 to the query images in the first column.<span style="font-size:80%;opacity:0.8">注意在像素级别，检索到的训练图像与第一列的查询图像在L2上通常是不接近的。</span></li><li>For example, the <font color=orangered>retrieved</font> dogs and elephants appear in a variety of poses.<span style="font-size:80%;opacity:0.8">例如，检索的狗和大象似乎有很多姿态。</span></li><li>This should produce a much better image retrieval method than applying auto-encoders to the raw pixels [14], which does not make use of image labels and hence has a tendency to <font color=orangered>retrieve</font> images with similar patterns of edges, whether or not they are semantically similar.<span style="font-size:80%;opacity:0.8">这应该会产生一种比将自动编码器应用到原始像素上[14]更好的图像检索方法，自动编码器应用到原始像素上的方法没有使用图像标签，因此会趋向于检索与要检索的图像具有相似边缘模式的图像，无论它们是否是语义上相似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 141 </td> <td> supplementary </td> <td> [ˌsʌplɪˈmentri] </td> <td> 
<ul><li>We present the results for many more test images in the <font color=orangered>supplementary</font> material.<span style="font-size:80%;opacity:0.8">我们在补充材料中对更多的测试图像呈现了这种结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 142 </td> <td> real-valued </td> <td> ['reɪɑ:lv'ælju:d] </td> <td> 
<ul><li>Computing similarity by using Euclidean distance between two 4096-dimensional, <font color=orangered>real-valued</font> vectors is inefficient, but it could be made efficient by training an auto-encoder to compress these vectors to short binary codes.<span style="font-size:80%;opacity:0.8">通过两个4096维实值向量间的欧氏距离来计算相似性是效率低下的，但通过训练一个自动编码器将这些向量压缩为短二值编码可以使其变得高效。</span></li></ul>
 </td>
</tr>
<tr>
<td> 143 </td> <td> auto-encoder </td> <td>  </td> <td> 
<ul><li>Computing similarity by using Euclidean distance between two 4096-dimensional, real-valued vectors is inefficient, but it could be made efficient by training an <font color=forestgreen>auto-encoder</font> to compress these vectors to short binary codes.<span style="font-size:80%;opacity:0.8">通过两个4096维实值向量间的欧氏距离来计算相似性是效率低下的，但通过训练一个自动编码器将这些向量压缩为短二值编码可以使其变得高效。</span></li></ul>
 </td>
</tr>
<tr>
<td> 144 </td> <td> retrieval </td> <td> [rɪˈtri:vl] </td> <td> 
<ul><li>This should produce a much better image <font color=orangered>retrieval</font> method than applying auto-encoders to the raw pixels [14], which does not make use of image labels and hence has a tendency to retrieve images with similar patterns of edges, whether or not they are semantically similar.<span style="font-size:80%;opacity:0.8">这应该会产生一种比将自动编码器应用到原始像素上[14]更好的图像检索方法，自动编码器应用到原始像素上的方法没有使用图像标签，因此会趋向于检索与要检索的图像具有相似边缘模式的图像，无论它们是否是语义上相似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 145 </td> <td> auto-encoders </td> <td>  </td> <td> 
<ul><li>This should produce a much better image retrieval method than applying <font color=forestgreen>auto-encoders</font> to the raw pixels [14], which does not make use of image labels and hence has a tendency to retrieve images with similar patterns of edges, whether or not they are semantically similar.<span style="font-size:80%;opacity:0.8">这应该会产生一种比将自动编码器应用到原始像素上[14]更好的图像检索方法，自动编码器应用到原始像素上的方法没有使用图像标签，因此会趋向于检索与要检索的图像具有相似边缘模式的图像，无论它们是否是语义上相似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 146 </td> <td> semantically </td> <td> [sɪ'mæntɪklɪ] </td> <td> 
<ul><li>This should produce a much better image retrieval method than applying auto-encoders to the raw pixels [14], which does not make use of image labels and hence has a tendency to retrieve images with similar patterns of edges, whether or not they are <font color=orangered>semantically</font> similar.<span style="font-size:80%;opacity:0.8">这应该会产生一种比将自动编码器应用到原始像素上[14]更好的图像检索方法，自动编码器应用到原始像素上的方法没有使用图像标签，因此会趋向于检索与要检索的图像具有相似边缘模式的图像，无论它们是否是语义上相似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 147 </td> <td> record-breaking </td> <td> ['rekɔ:d,breikiŋ, 'rekəd-] </td> <td> 
<ul><li>Our results show that a large, deep convolutional neural network is capable of achieving <font color=orangered>record-breaking</font> results on a highly challenging dataset using purely supervised learning.<span style="font-size:80%;opacity:0.8">我们的结果表明一个大型深度卷积神经网络在一个具有高度挑战性的数据集上使用纯有监督学习可以取得破纪录的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 148 </td> <td> unsupervised </td> <td> [ˌʌn'sju:pəvaɪzd] </td> <td> 
<ul><li>To simplify our experiments, we did not use any <font color=orangered>unsupervised</font> pre-training even though we expect that it will help, especially if we obtain enough computational power to significantly increase the size of the network without obtaining a corresponding increase in the amount of labeled data.<span style="font-size:80%;opacity:0.8">为了简化我们的实验，我们没有使用任何无监督的预训练，尽管我们希望它会有所帮助，特别是在如果我们能获得足够的计算能力来显著增加网络的大小而标注的数据量没有对应增加的情况下。</span></li></ul>
 </td>
</tr>
<tr>
<td> 149 </td> <td> computational </td> <td> [ˌkɒmpjuˈteɪʃənl] </td> <td> 
<ul><li>To simplify our experiments, we did not use any unsupervised pre-training even though we expect that it will help, especially if we obtain enough <font color=orangered>computational</font> power to significantly increase the size of the network without obtaining a corresponding increase in the amount of labeled data.<span style="font-size:80%;opacity:0.8">为了简化我们的实验，我们没有使用任何无监督的预训练，尽管我们希望它会有所帮助，特别是在如果我们能获得足够的计算能力来显著增加网络的大小而标注的数据量没有对应增加的情况下。</span></li></ul>
 </td>
</tr>
<tr>
<td> 150 </td> <td> infero-temporal </td> <td>  </td> <td> 
<ul><li>Thus far, our results have improved as we have made our network larger and trained it longer but we still have many orders of magnitude to go in order to match the <font color=forestgreen>infero-temporal</font> pathway of the human visual system.<span style="font-size:80%;opacity:0.8">到目前为止，我们的结果已经提高了，因为我们的网络更大、训练时间更长，但为了匹配人类视觉系统的下颞线（视觉专业术语）我们仍然有许多数量级要达到。</span></li></ul>
 </td>
</tr>
<tr>
<td> 151 </td> <td> pathway </td> <td> [ˈpɑ:θweɪ] </td> <td> 
<ul><li>Thus far, our results have improved as we have made our network larger and trained it longer but we still have many orders of magnitude to go in order to match the infero-temporal <font color=orangered>pathway</font> of the human visual system.<span style="font-size:80%;opacity:0.8">到目前为止，我们的结果已经提高了，因为我们的网络更大、训练时间更长，但为了匹配人类视觉系统的下颞线（视觉专业术语）我们仍然有许多数量级要达到。</span></li></ul>
 </td>
</tr>
<tr>
<td> 152 </td> <td> static </td> <td> [ˈstætɪk] </td> <td> 
<ul><li>Ultimately we would like to use very large and deep convolutional nets on video sequences where the temporal structure provides very helpful information that is missing or far less obvious in <font color=orangered>static</font> images.<span style="font-size:80%;opacity:0.8">最后我们想在视频序列上使用非常大的深度卷积网络，视频序列的时序结构会提供非常有帮助的信息，这些信息在静态图像上是缺失的或远不那么明显。</span></li></ul>
 </td>
</tr>
</table>
</div>
<div class="two-list">
<table>
<caption>
    <h2> Words List (frequency)</h2>
</caption>
<thead>
<tr>
<td> # </td> <td> word (frequency) </td> <td> phonetic </td> <td> sentence </td>
</tr>
</thead>
<tr>
<td> 1 </td> <td> ILSVRC<br>(18) </td> <td>  </td> <td> 
<ul><li>We also entered a variant of this model in the <font color=forestgreen>ILSVRC</font>-2012 competition and achieved a winning top-5 test error rate of 15.3%, compared to 26.2% achieved by the second-best entry.<span style="font-size:80%;opacity:0.8">我们也使用这个模型的一个变种参加了ILSVRC-2012竞赛，赢得了冠军并且与第二名 top-5 26.2%的错误率相比，我们取得了top-5 15.3%的错误率。</span></li><li>The specific contributions of this paper are as follows: we trained one of the largest convolutional neural networks to date on the subsets of ImageNet used in the <font color=forestgreen>ILSVRC</font>-2010 and <font color=forestgreen>ILSVRC</font>-2012 competitions [2] and achieved by far the best results ever reported on these datasets.<span style="font-size:80%;opacity:0.8">本文具体的贡献如下：我们在ILSVRC-2010和ILSVRC-2012[2]的ImageNet子集上训练了到目前为止最大的神经网络之一，并取得了迄今为止在这些数据集上报道过的最好结果。</span></li><li>Starting in 2010, as part of the Pascal Visual Object Challenge, an annual competition called the ImageNet Large-Scale Visual Recognition Challenge (<font color=forestgreen>ILSVRC</font>) has been held.<span style="font-size:80%;opacity:0.8">从2010年起，作为Pascal视觉对象挑战赛的一部分，每年都会举办ImageNet大规模视觉识别挑战赛（ILSVRC）。</span></li><li><font color=forestgreen>ILSVRC</font> uses a subset of ImageNet with roughly 1000 images in each of 1000 categories.<span style="font-size:80%;opacity:0.8">ILSVRC使用ImageNet的一个子集，1000个类别每个类别大约1000张图像。</span></li><li>ILSVRC-2010 is the only version of <font color=forestgreen>ILSVRC</font> for which the test set labels are available, so this is the version on which we performed most of our experiments.<span style="font-size:80%;opacity:0.8">ILSVRC-2010是ILSVRC竞赛中唯一可以获得测试集标签的版本，因此我们大多数实验都是在这个版本上运行的。</span></li><li>Since we also entered our model in the <font color=forestgreen>ILSVRC</font>-2012 competition, in Section 6 we report our results on this version of the dataset as well, for which test set labels are unavailable.<span style="font-size:80%;opacity:0.8">由于我们也使用我们的模型参加了ILSVRC-2012竞赛，因此在第六节我们也报告了模型在这个版本的数据集上的结果，这个版本的测试标签是不可获得的。</span></li><li>Although the 1000 classes of <font color=forestgreen>ILSVRC</font> make each training example impose 10 bits of constraint on the mapping from image to label, this turns out to be insufficient to learn so many parameters without considerable overfitting.<span style="font-size:80%;opacity:0.8">尽管ILSVRC的1000类使每个训练样本从图像到标签的映射上强加了10比特的约束，但这不足以学习这么多的参数而没有相当大的过拟合。</span></li><li>Our results on <font color=forestgreen>ILSVRC</font>-2010 are summarized in Table 1.<span style="font-size:80%;opacity:0.8">我们在ILSVRC-2010上的结果概括为表1。</span></li><li>The best performance achieved during the <font color=forestgreen>ILSVRC</font>-2010 competition was 47.1% and 28.2% with an approach that averages the predictions produced from six sparse-coding models trained on different features [2], and since then the best published results are 45.7% and 25.7% with an approach that averages the predictions of two classifiers trained on Fisher Vectors (FVs) computed from two types of densely-sampled features [24].<span style="font-size:80%;opacity:0.8">在ILSVRC-2010竞赛中最佳结果是top-1 47.1%，top-5 28.2%，使用的方法是对6个在不同特征上训练的稀疏编码模型生成的预测进行平均，从那时起已公布的最好结果是top-1 45.7%，top-5 25.7%，使用的方法是平均在Fisher向量（FV）上训练的两个分类器的预测结果，Fisher向量是通过两种密集采样特征计算得到的[24]。</span></li><li>Table 1: Comparison of results on <font color=forestgreen>ILSVRC</font>-2010 test set.<span style="font-size:80%;opacity:0.8">表1：ILSVRC-2010测试集上的结果对比。</span></li><li>We also entered our model in the <font color=forestgreen>ILSVRC</font>-2012 competition and report our results in Table 2.<span style="font-size:80%;opacity:0.8">我们也用我们的模型参加了ILSVRC-2012竞赛并在表2中报告了我们的结果。</span></li><li>Since the <font color=forestgreen>ILSVRC</font>-2012 test set labels are not publicly available, we cannot report test error rates for all the models that we tried.<span style="font-size:80%;opacity:0.8">由于ILSVRC-2012的测试集标签不可以公开得到，我们不能报告我们尝试的所有模型的测试错误率。</span></li><li>Training one CNN, with an extra sixth convolutional layer over the last pooling layer, to classify the entire ImageNet Fall 2011 release (15M images, 22K categories), and then “fine-tuning” it on <font color=forestgreen>ILSVRC</font>-2012 gives an error rate of 16.6%.<span style="font-size:80%;opacity:0.8">为了对ImageNet 2011秋季发布的整个数据集（1500万图像，22000个类别）进行分类，我们在最后的池化层之后有一个额外的第6卷积层，训练了一个CNN，然后在它上面进行“fine-tuning”，在ILSVRC-2012取得了16.6%的错误率。</span></li><li>Table 2: Comparison of error rates on <font color=forestgreen>ILSVRC</font>-2012 validation and test sets.<span style="font-size:80%;opacity:0.8">表2：ILSVRC-2012验证集和测试集的误差对比。</span></li><li>Figure 4: (Left) Eight <font color=forestgreen>ILSVRC</font>-2010 test images and the five labels considered most probable by our model.<span style="font-size:80%;opacity:0.8">图4：（左）8张ILSVRC-2010测试图像和我们的模型认为最可能的5个标签。</span></li><li>(Right) Five <font color=forestgreen>ILSVRC</font>-2010 test images in the first column.<span style="font-size:80%;opacity:0.8">（右）第一列是5张ILSVRC-2010测试图像。</span></li></ul>
 </td>
</tr>
<tr>
<td> 2 </td> <td> patch<br>(8) </td> <td> [pætʃ] </td> <td> 
<ul><li>Given a rectangular image, we first rescaled the image such that the shorter side was of length 256, and then cropped out the central 256×256 <font color=orangered>patch</font> from the resulting image.<span style="font-size:80%;opacity:0.8">给定一个矩形图像，我们首先缩放图像短边长度为256，然后从结果图像中裁剪中心的256×256大小的图像块。</span></li><li>We do this by extracting random 224 × 224 <font color=orangered>patches</font> (and their horizontal reflections) from the 256×256 images and training our network on these extracted <font color=orangered>patches</font>.<span style="font-size:80%;opacity:0.8">我们从256×256图像上通过随机提取224 × 224的图像块实现了这种方式，然后在这些提取的图像块上进行训练。</span></li><li>At test time, the network makes a prediction by extracting five 224 × 224 <font color=orangered>patches</font> (the four corner <font color=orangered>patches</font> and the center patch) as well as their horizontal reflections (hence ten <font color=orangered>patches</font> in all), and averaging the predictions made by the network’s softmax layer on the ten <font color=orangered>patches</font>.<span style="font-size:80%;opacity:0.8">在测试时，网络会提取5个224 × 224的图像块（四个角上的图像块和中心的图像块）和它们的水平翻转（因此总共10个图像块）进行预测，然后对网络在10个图像块上的softmax层进行平均。</span></li><li>At test time, the network makes a prediction by extracting five 224 × 224 patches (the four corner patches and the center <font color=orangered>patch</font>) as well as their horizontal reflections (hence ten patches in all), and averaging the predictions made by the network’s softmax layer on the ten patches.<span style="font-size:80%;opacity:0.8">在测试时，网络会提取5个224 × 224的图像块（四个角上的图像块和中心的图像块）和它们的水平翻转（因此总共10个图像块）进行预测，然后对网络在10个图像块上的softmax层进行平均。</span></li><li>At test time, the network makes a prediction by extracting five 224 × 224 <font color=orangered>patches</font> (the four corner <font color=orangered>patches</font> and the center patch) as well as their horizontal reflections (hence ten <font color=orangered>patches</font> in all), and averaging the predictions made by the network’s softmax layer on the ten <font color=orangered>patches</font>.<span style="font-size:80%;opacity:0.8">在测试时，网络会提取5个224 × 224的图像块（四个角上的图像块和中心的图像块）和它们的水平翻转（因此总共10个图像块）进行预测，然后对网络在10个图像块上的softmax层进行平均。</span></li></ul>
 </td>
</tr>
<tr>
<td> 3 </td> <td> ReLUs<br>(7) </td> <td>  </td> <td> 
<ul><li>Following Nair and Hinton [20], we refer to neurons with this nonlinearity as Rectified Linear Units (<font color=forestgreen>ReLUs</font>).<span style="font-size:80%;opacity:0.8">根据Nair和Hinton[20]的说法，我们将这种非线性神经元称为修正线性单元(ReLU)。</span></li><li>Deep convolutional neural networks with <font color=forestgreen>ReLUs</font> train several times faster than their equivalents with tanh units.<span style="font-size:80%;opacity:0.8">采用ReLU的深度卷积神经网络训练时间比等价的tanh单元要快几倍。</span></li><li>Figure 1: A four-layer convolutional neural network with <font color=forestgreen>ReLUs</font> (solid line) reaches a 25% training error rate on CIFAR-10 six times faster than an equivalent network with tanh neurons (dashed line).<span style="font-size:80%;opacity:0.8">图1：使用ReLU的四层卷积神经网络在CIFAR-10数据集上达到25%的训练误差比使用tanh神经元的等价网络（虚线）快六倍。</span></li><li>The magnitude of the effect demonstrated here varies with network architecture, but networks with <font color=forestgreen>ReLUs</font> consistently learn several times faster than equivalents with saturating neurons.<span style="font-size:80%;opacity:0.8">影响的大小随着网络结构的变化而变化，这一点已得到证实，但使用ReLU的网络都比等价的饱和神经元快几倍。</span></li><li>However, on this dataset the primary concern is preventing overfitting, so the effect they are observing is different from the accelerated ability to fit the training set which we report when using <font color=forestgreen>ReLUs</font>.<span style="font-size:80%;opacity:0.8">然而，在这个数据集上主要的关注点是防止过拟合，因此他们观测到的影响不同于我们使用ReLU拟合数据集时的加速能力。</span></li><li><font color=forestgreen>ReLUs</font> have the desirable property that they do not require input normalization to prevent them from saturating.<span style="font-size:80%;opacity:0.8">ReLU具有让人满意的特性，它不需要通过输入归一化来防止饱和。</span></li><li>This initialization accelerates the early stages of learning by providing the <font color=forestgreen>ReLUs</font> with positive inputs.<span style="font-size:80%;opacity:0.8">这个初始化通过为ReLU提供正输入加速了学习的早期阶段。</span></li></ul>
 </td>
</tr>
<tr>
<td> 4 </td> <td> nonlinearity<br>(6) </td> <td> [nɒnlɪnɪ'ærɪtɪ] </td> <td> 
<ul><li>In terms of training time with gradient descent, these saturating nonlinearities are much slower than the non-saturating <font color=orangered>nonlinearity</font> $f(x) = \max(0,x)$.<span style="font-size:80%;opacity:0.8">考虑到梯度下降的训练时间，这些饱和的非线性比非饱和非线性$f(x) = \max(0,x)$更慢。</span></li><li>Following Nair and Hinton [20], we refer to neurons with this <font color=orangered>nonlinearity</font> as Rectified Linear Units (ReLUs).<span style="font-size:80%;opacity:0.8">根据Nair和Hinton[20]的说法，我们将这种非线性神经元称为修正线性单元(ReLU)。</span></li><li>For example, Jarrett et al. [11] claim that the <font color=orangered>nonlinearity</font> $f(x) = \lvert \tanh(x) \rvert$ works particularly well with their type of contrast normalization followed by local average pooling on the Caltech-101 dataset.<span style="font-size:80%;opacity:0.8">例如，Jarrett等人[11]声称非线性函数$f(x) = \lvert \tanh(x) \rvert$与其对比度归一化一起，然后是局部均值池化，在Caltech-101数据集上工作的非常好。</span></li><li>Denoting by $a_{x,y}^i$ the activity of a neuron computed by applying kernel $i$ at position $(x, y)$ and then applying the ReLU <font color=orangered>nonlinearity</font>, the response-normalized activity $b^i_{x,y}$ is given by the expression<span style="font-size:80%;opacity:0.8">$a_{x,y}^i$表示神经元激活，通过在$(x, y)$位置应用核i，然后应用ReLU非线性来计算，响应归一化激活$b^i_{x,y}$通过下式给定：</span></li><li>We applied this normalization after applying the ReLU <font color=orangered>nonlinearity</font> in certain layers (see Section 3.5).<span style="font-size:80%;opacity:0.8">我们在特定的层使用的ReLU非线性之后应用了这种归一化（请看3.5小节）。</span></li><li>3.1 ReLU <font color=orangered>Nonlinearity</font><span style="font-size:80%;opacity:0.8">3.1 ReLU非线性</span></li></ul>
 </td>
</tr>
<tr>
<td> 5 </td> <td> vector<br>(6) </td> <td> [ˈvektə(r)] </td> <td> 
<ul><li>The best performance achieved during the ILSVRC-2010 competition was 47.1% and 28.2% with an approach that averages the predictions produced from six sparse-coding models trained on different features [2], and since then the best published results are 45.7% and 25.7% with an approach that averages the predictions of two classifiers trained on Fisher <font color=orangered>Vectors</font> (FVs) computed from two types of densely-sampled features [24].<span style="font-size:80%;opacity:0.8">在ILSVRC-2010竞赛中最佳结果是top-1 47.1%，top-5 28.2%，使用的方法是对6个在不同特征上训练的稀疏编码模型生成的预测进行平均，从那时起已公布的最好结果是top-1 45.7%，top-5 25.7%，使用的方法是平均在Fisher向量（FV）上训练的两个分类器的预测结果，Fisher向量是通过两种密集采样特征计算得到的[24]。</span></li><li>The remaining columns show the six training images that produce feature <font color=orangered>vectors</font> in the last hidden layer with the smallest Euclidean distance from the feature vector for the test image.<span style="font-size:80%;opacity:0.8">剩下的列展示了6张训练图像，这些图像在最后的隐藏层的特征向量与测试图像的特征向量有最小的欧氏距离。</span></li><li>The remaining columns show the six training images that produce feature vectors in the last hidden layer with the smallest Euclidean distance from the feature <font color=orangered>vector</font> for the test image.<span style="font-size:80%;opacity:0.8">剩下的列展示了6张训练图像，这些图像在最后的隐藏层的特征向量与测试图像的特征向量有最小的欧氏距离。</span></li><li>If two images produce feature activation <font color=orangered>vectors</font> with a small Euclidean separation, we can say that the higher levels of the neural network consider them to be similar.<span style="font-size:80%;opacity:0.8">如果两幅图像生成的特征激活向量之间有较小的欧式距离，我们可以认为神经网络的更高层特征认为它们是相似的。</span></li><li>Computing similarity by using Euclidean distance between two 4096-dimensional, real-valued <font color=orangered>vectors</font> is inefficient, but it could be made efficient by training an auto-encoder to compress these <font color=orangered>vectors</font> to short binary codes.<span style="font-size:80%;opacity:0.8">通过两个4096维实值向量间的欧氏距离来计算相似性是效率低下的，但通过训练一个自动编码器将这些向量压缩为短二值编码可以使其变得高效。</span></li></ul>
 </td>
</tr>
<tr>
<td> 6 </td> <td> ReLU<br>(5) </td> <td>  </td> <td> 
<ul><li>3.1 <font color=forestgreen>ReLU</font> Nonlinearity<span style="font-size:80%;opacity:0.8">3.1 ReLU非线性</span></li><li>If at least some training examples produce a positive input to a <font color=forestgreen>ReLU</font>, learning will happen in that neuron.<span style="font-size:80%;opacity:0.8">如果至少一些训练样本对ReLU产生了正输入，那么那个神经元上将发生学习。</span></li><li>Denoting by $a_{x,y}^i$ the activity of a neuron computed by applying kernel $i$ at position $(x, y)$ and then applying the <font color=forestgreen>ReLU</font> nonlinearity, the response-normalized activity $b^i_{x,y}$ is given by the expression<span style="font-size:80%;opacity:0.8">$a_{x,y}^i$表示神经元激活，通过在$(x, y)$位置应用核i，然后应用ReLU非线性来计算，响应归一化激活$b^i_{x,y}$通过下式给定：</span></li><li>We applied this normalization after applying the <font color=forestgreen>ReLU</font> nonlinearity in certain layers (see Section 3.5).<span style="font-size:80%;opacity:0.8">我们在特定的层使用的ReLU非线性之后应用了这种归一化（请看3.5小节）。</span></li><li>The <font color=forestgreen>ReLU</font> non-linearity is applied to the output of every convolutional and fully-connected layer.<span style="font-size:80%;opacity:0.8">ReLU非线性应用在每个卷积层和全连接层的输出上。</span></li></ul>
 </td>
</tr>
<tr>
<td> 7 </td> <td> augmentation<br>(5) </td> <td> [ˌɔ:ɡmen'teɪʃn] </td> <td> 
<ul><li>4.1 Data <font color=orangered>Augmentation</font><span style="font-size:80%;opacity:0.8">4.1 数据增强</span></li><li>We employ two distinct forms of data <font color=orangered>augmentation</font>, both of which allow transformed images to be produced from the original images with very little computation, so the transformed images do not need to be stored on disk.<span style="font-size:80%;opacity:0.8">我们使用了两种独特的数据增强方式，这两种方式都可以从原始图像通过非常少的计算量产生变换的图像，因此变换图像不需要存储在硬盘上。</span></li><li>So these data <font color=orangered>augmentation</font> schemes are, in effect, computationally free.<span style="font-size:80%;opacity:0.8">因此，实际上这些数据增强方案是计算免费的。</span></li><li>The first form of data <font color=orangered>augmentation</font> consists of generating image translations and horizontal reflections.<span style="font-size:80%;opacity:0.8">第一种数据增强方式包括产生图像变换和水平翻转。</span></li><li>The second form of data <font color=orangered>augmentation</font> consists of altering the intensities of the RGB channels in training images.<span style="font-size:80%;opacity:0.8">第二种数据增强方式包括改变训练图像的RGB通道的强度。</span></li></ul>
 </td>
</tr>
<tr>
<td> 8 </td> <td> CIFAR<br>(4) </td> <td>  </td> <td> 
<ul><li>Until recently, datasets of labeled images were relatively small -- on the order of tens of thousands of images (e.g., NORB [16], Caltech-101/256 [8, 9], and <font color=forestgreen>CIFAR</font>-10/100 [12]). Simple recognition tasks can be solved quite well with datasets of this size, especially if they are augmented with label-preserving transformations.<span style="font-size:80%;opacity:0.8">直到最近，标注图像的数据集都相对较小--在几万张图像的数量级上（例如，NORB[16]，Caltech-101/256 [8, 9]和CIFAR-10/100 [12]）。简单的识别任务在这样大小的数据集上可以被解决的相当好，尤其是如果通过标签保留变换进行数据增强的情况下。</span></li><li>This is demonstrated in Figure 1, which shows the number of iterations required to reach 25% training error on the <font color=forestgreen>CIFAR</font>-10 dataset for a particular four-layer convolutional network.<span style="font-size:80%;opacity:0.8">在图1中，对于一个特定的四层卷积网络，在CIFAR-10数据集上达到25%的训练误差所需要的迭代次数可以证实这一点。</span></li><li>Figure 1: A four-layer convolutional neural network with ReLUs (solid line) reaches a 25% training error rate on <font color=forestgreen>CIFAR</font>-10 six times faster than an equivalent network with tanh neurons (dashed line).<span style="font-size:80%;opacity:0.8">图1：使用ReLU的四层卷积神经网络在CIFAR-10数据集上达到25%的训练误差比使用tanh神经元的等价网络（虚线）快六倍。</span></li><li>We also verified the effectiveness of this scheme on the <font color=forestgreen>CIFAR</font>-10 dataset: a four-layer CNN achieved a 13% test error rate without normalization and 11% with normalization.<span style="font-size:80%;opacity:0.8">我们也在CIFAR-10数据集上验证了这个方案的有效性：一个乜嘢归一化的四层CNN取得了13%的错误率，而使用归一化取得了11%的错误率。</span></li></ul>
 </td>
</tr>
<tr>
<td> 9 </td> <td> saturate<br>(4) </td> <td> [ˈsætʃəreɪt] </td> <td> 
<ul><li>In terms of training time with gradient descent, these <font color=orangered>saturating</font> nonlinearities are much slower than the non-<font color=orangered>saturating</font> nonlinearity $f(x) = \max(0,x)$.<span style="font-size:80%;opacity:0.8">考虑到梯度下降的训练时间，这些饱和的非线性比非饱和非线性$f(x) = \max(0,x)$更慢。</span></li><li>This plot shows that we would not have been able to experiment with such large neural networks for this work if we had used traditional <font color=orangered>saturating</font> neuron models.<span style="font-size:80%;opacity:0.8">这幅图表明，如果我们采用传统的饱和神经元模型，我们将不能在如此大的神经网络上实验该工作。</span></li><li>The magnitude of the effect demonstrated here varies with network architecture, but networks with ReLUs consistently learn several times faster than equivalents with <font color=orangered>saturating</font> neurons.<span style="font-size:80%;opacity:0.8">影响的大小随着网络结构的变化而变化，这一点已得到证实，但使用ReLU的网络都比等价的饱和神经元快几倍。</span></li><li>ReLUs have the desirable property that they do not require input normalization to prevent them from <font color=orangered>saturating</font>.<span style="font-size:80%;opacity:0.8">ReLU具有让人满意的特性，它不需要通过输入归一化来防止饱和。</span></li></ul>
 </td>
</tr>
<tr>
<td> 10 </td> <td> initialize<br>(4) </td> <td> [ɪˈnɪʃəlaɪz] </td> <td> 
<ul><li>We <font color=orangered>initialized</font> the weights in each layer from a zero-mean Gaussian distribution with standard deviation 0.01.<span style="font-size:80%;opacity:0.8">我们使用均值为0，标准差为0.01的高斯分布对每一层的权重进行初始化。</span></li><li>We <font color=orangered>initialized</font> the neuron biases in the second, fourth, and fifth convolutional layers, as well as in the fully-connected hidden layers, with the constant 1.<span style="font-size:80%;opacity:0.8">我们在第2，4，5卷积层和全连接隐层将神经元偏置初始化为常量1。</span></li><li>We <font color=orangered>initialized</font> the neuron biases in the remaining layers with the constant 0.<span style="font-size:80%;opacity:0.8">我们在剩下的层将神经元偏置初始化为0。</span></li><li>The learning rate was <font color=orangered>initialized</font> at 0.01 and reduced three times prior to termination.<span style="font-size:80%;opacity:0.8">学习率初始化为0.01，在训练停止之前降低三次。</span></li></ul>
 </td>
</tr>
<tr>
<td> 11 </td> <td> GTX<br>(3) </td> <td>  </td> <td> 
<ul><li>Our network takes between five and six days to train on two <font color=forestgreen>GTX</font> 580 3GB GPUs.<span style="font-size:80%;opacity:0.8">我们的网络在两个GTX 580 3GB GPU上训练五六天。</span></li><li>A single <font color=forestgreen>GTX</font> 580 GPU has only 3GB of memory, which limits the maximum size of the networks that can be trained on it.<span style="font-size:80%;opacity:0.8">单个GTX580 GPU只有3G内存，这限制了可以在GTX580上进行训练的网络最大尺寸。</span></li><li>We trained the network for roughly 90 cycles through the training set of 1.2 million images, which took five to six days on two NVIDIA <font color=forestgreen>GTX</font> 580 3GB GPUs.<span style="font-size:80%;opacity:0.8">我们在120万图像的训练数据集上训练神经网络大约90个循环，在两个NVIDIA GTX 580 3GB GPU上花费了五到六天。</span></li></ul>
 </td>
</tr>
<tr>
<td> 12 </td> <td> GB<br>(3) </td> <td>  </td> <td> 
<ul><li>Our network takes between five and six days to train on two GTX 580 3GB GPUs.<span style="font-size:80%;opacity:0.8">我们的网络在两个GTX 580 3GB GPU上训练五六天。</span></li><li>A single GTX 580 GPU has only 3GB of memory, which limits the maximum size of the networks that can be trained on it.<span style="font-size:80%;opacity:0.8">单个GTX580 GPU只有3G内存，这限制了可以在GTX580上进行训练的网络最大尺寸。</span></li><li>We trained the network for roughly 90 cycles through the training set of 1.2 million images, which took five to six days on two NVIDIA GTX 580 3GB GPUs.<span style="font-size:80%;opacity:0.8">我们在120万图像的训练数据集上训练神经网络大约90个循环，在两个NVIDIA GTX 580 3GB GPU上花费了五到六天。</span></li></ul>
 </td>
</tr>
<tr>
<td> 13 </td> <td> Euclidean<br>(3) </td> <td> [ju:ˈklidiən] </td> <td> 
<ul><li>The remaining columns show the six training images that produce feature vectors in the last hidden layer with the smallest <font color=orangered>Euclidean</font> distance from the feature vector for the test image.<span style="font-size:80%;opacity:0.8">剩下的列展示了6张训练图像，这些图像在最后的隐藏层的特征向量与测试图像的特征向量有最小的欧氏距离。</span></li><li>If two images produce feature activation vectors with a small <font color=orangered>Euclidean</font> separation, we can say that the higher levels of the neural network consider them to be similar.<span style="font-size:80%;opacity:0.8">如果两幅图像生成的特征激活向量之间有较小的欧式距离，我们可以认为神经网络的更高层特征认为它们是相似的。</span></li><li>Computing similarity by using <font color=orangered>Euclidean</font> distance between two 4096-dimensional, real-valued vectors is inefficient, but it could be made efficient by training an auto-encoder to compress these vectors to short binary codes.<span style="font-size:80%;opacity:0.8">通过两个4096维实值向量间的欧氏距离来计算相似性是效率低下的，但通过训练一个自动编码器将这些向量压缩为短二值编码可以使其变得高效。</span></li></ul>
 </td>
</tr>
<tr>
<td> 14 </td> <td> retrieve<br>(3) </td> <td> [rɪˈtri:v] </td> <td> 
<ul><li>Notice that at the pixel level, the <font color=orangered>retrieved</font> training images are generally not close in L2 to the query images in the first column.<span style="font-size:80%;opacity:0.8">注意在像素级别，检索到的训练图像与第一列的查询图像在L2上通常是不接近的。</span></li><li>For example, the <font color=orangered>retrieved</font> dogs and elephants appear in a variety of poses.<span style="font-size:80%;opacity:0.8">例如，检索的狗和大象似乎有很多姿态。</span></li><li>This should produce a much better image retrieval method than applying auto-encoders to the raw pixels [14], which does not make use of image labels and hence has a tendency to <font color=orangered>retrieve</font> images with similar patterns of edges, whether or not they are semantically similar.<span style="font-size:80%;opacity:0.8">这应该会产生一种比将自动编码器应用到原始像素上[14]更好的图像检索方法，自动编码器应用到原始像素上的方法没有使用图像标签，因此会趋向于检索与要检索的图像具有相似边缘模式的图像，无论它们是否是语义上相似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 15 </td> <td> hinton<br>(2) </td> <td>  </td> <td> 
<ul><li>Authors: Krizhevsky, Alex (University of Toronto, Canada); Sutskever, Ilya; <font color=forestgreen>Hinton</font>, Geoffrey E.<span style="font-size:80%;opacity:0.8"></span></li><li>Following Nair and <font color=forestgreen>Hinton</font> [20], we refer to neurons with this nonlinearity as Rectified Linear Units (ReLUs).<span style="font-size:80%;opacity:0.8">根据Nair和Hinton[20]的说法，我们将这种非线性神经元称为修正线性单元(ReLU)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 16 </td> <td> max-pooling<br>(2) </td> <td>  </td> <td> 
<ul><li>The neural network, which has 60 million parameters and 650,000 neurons, consists of five convolutional layers, some of which are followed by <font color=forestgreen>max-pooling</font> layers, and three fully-connected layers with a final 1000-way softmax.<span style="font-size:80%;opacity:0.8">这个神经网络有6000万参数和650000个神经元，包含5个卷积层（某些卷积层后面带有池化层）和3个全连接层，最后是一个1000维的softmax。</span></li><li><font color=forestgreen>Max-pooling</font> layers, of the kind described in Section 3.4, follow both response-normalization layers as well as the fifth convolutional layer.<span style="font-size:80%;opacity:0.8">3.4节描述的这种最大池化层在响应归一化层和第5卷积层之后。</span></li></ul>
 </td>
</tr>
<tr>
<td> 17 </td> <td> non-saturating<br>(2) </td> <td>  </td> <td> 
<ul><li>To make training faster, we used <font color=forestgreen>non-saturating</font> neurons and a very efficient GPU implementation of the convolution operation.<span style="font-size:80%;opacity:0.8">为了训练的更快，我们使用了非饱和神经元并对卷积操作进行了非常有效的GPU实现。</span></li><li>In terms of training time with gradient descent, these saturating nonlinearities are much slower than the <font color=forestgreen>non-saturating</font> nonlinearity $f(x) = \max(0,x)$.<span style="font-size:80%;opacity:0.8">考虑到梯度下降的训练时间，这些饱和的非线性比非饱和非线性$f(x) = \max(0,x)$更慢。</span></li></ul>
 </td>
</tr>
<tr>
<td> 18 </td> <td> Caltech<br>(2) </td> <td> ['kæltek] </td> <td> 
<ul><li>Until recently, datasets of labeled images were relatively small -- on the order of tens of thousands of images (e.g., NORB [16], <font color=orangered>Caltech</font>-101/256 [8, 9], and CIFAR-10/100 [12]). Simple recognition tasks can be solved quite well with datasets of this size, especially if they are augmented with label-preserving transformations.<span style="font-size:80%;opacity:0.8">直到最近，标注图像的数据集都相对较小--在几万张图像的数量级上（例如，NORB[16]，Caltech-101/256 [8, 9]和CIFAR-10/100 [12]）。简单的识别任务在这样大小的数据集上可以被解决的相当好，尤其是如果通过标签保留变换进行数据增强的情况下。</span></li><li>For example, Jarrett et al. [11] claim that the nonlinearity $f(x) = \lvert \tanh(x) \rvert$ works particularly well with their type of contrast normalization followed by local average pooling on the <font color=orangered>Caltech</font>-101 dataset.<span style="font-size:80%;opacity:0.8">例如，Jarrett等人[11]声称非线性函数$f(x) = \lvert \tanh(x) \rvert$与其对比度归一化一起，然后是局部均值池化，在Caltech-101数据集上工作的非常好。</span></li></ul>
 </td>
</tr>
<tr>
<td> 19 </td> <td> label-preserving<br>(2) </td> <td>  </td> <td> 
<ul><li>Until recently, datasets of labeled images were relatively small -- on the order of tens of thousands of images (e.g., NORB [16], Caltech-101/256 [8, 9], and CIFAR-10/100 [12]). Simple recognition tasks can be solved quite well with datasets of this size, especially if they are augmented with <font color=forestgreen>label-preserving</font> transformations.<span style="font-size:80%;opacity:0.8">直到最近，标注图像的数据集都相对较小--在几万张图像的数量级上（例如，NORB[16]，Caltech-101/256 [8, 9]和CIFAR-10/100 [12]）。简单的识别任务在这样大小的数据集上可以被解决的相当好，尤其是如果通过标签保留变换进行数据增强的情况下。</span></li><li>The easiest and most common method to reduce overfitting on image data is to artificially enlarge the dataset using <font color=forestgreen>label-preserving</font> transformations (e.g., [25, 4, 5]).<span style="font-size:80%;opacity:0.8">图像数据上最简单常用的用来减少过拟合的方法是使用标签保留变换（例如[25, 4, 5]）来人工增大数据集。</span></li></ul>
 </td>
</tr>
<tr>
<td> 20 </td> <td> descent<br>(2) </td> <td> [dɪˈsent] </td> <td> 
<ul><li>In terms of training time with gradient <font color=orangered>descent</font>, these saturating nonlinearities are much slower than the non-saturating nonlinearity $f(x) = \max(0,x)$.<span style="font-size:80%;opacity:0.8">考虑到梯度下降的训练时间，这些饱和的非线性比非饱和非线性$f(x) = \max(0,x)$更慢。</span></li><li>We trained our models using stochastic gradient <font color=orangered>descent</font> with a batch size of 128 examples, momentum of 0.9, and weight decay of 0.0005.<span style="font-size:80%;opacity:0.8">我们使用随机梯度下降来训练我们的模型，样本的batch size为128，动量为0.9，权重衰减为0.0005。</span></li></ul>
 </td>
</tr>
<tr>
<td> 21 </td> <td> Jarrett<br>(2) </td> <td>  </td> <td> 
<ul><li>For example, <font color=forestgreen>Jarrett</font> et al. [11] claim that the nonlinearity $f(x) = \lvert \tanh(x) \rvert$ works particularly well with their type of contrast normalization followed by local average pooling on the Caltech-101 dataset.<span style="font-size:80%;opacity:0.8">例如，Jarrett等人[11]声称非线性函数$f(x) = \lvert \tanh(x) \rvert$与其对比度归一化一起，然后是局部均值池化，在Caltech-101数据集上工作的非常好。</span></li><li>This scheme bears some resemblance to the local contrast normalization scheme of <font color=forestgreen>Jarrett</font> et al. [11], but ours would be more correctly termed “brightness normalization”, since we do not subtract the mean activity.<span style="font-size:80%;opacity:0.8">这个方案与Jarrett等人[11]的局部对比度归一化方案有一定的相似性，但我们更恰当的称其为“亮度归一化”，因此我们没有减去均值。</span></li></ul>
 </td>
</tr>
<tr>
<td> 22 </td> <td> parallelization<br>(2) </td> <td> [pærəlɪlaɪ'zeɪʃn] </td> <td> 
<ul><li>Current GPUs are particularly well-suited to cross-GPU <font color=orangered>parallelization</font>, as they are able to read from and write to one another’s memory directly, without going through host machine memory.<span style="font-size:80%;opacity:0.8">目前的GPU非常适合跨GPU并行，因为它们可以直接互相读写内存，而不需要通过主机内存。</span></li><li>The <font color=orangered>parallelization</font> scheme that we employ essentially puts half of the kernels (or neurons) on each GPU, with one additional trick: the GPUs communicate only in certain layers.<span style="font-size:80%;opacity:0.8">我们采用的并行方案基本上每个GPU放置一半的核（或神经元），还有一个额外的技巧：只在某些特定的层上进行GPU通信。</span></li></ul>
 </td>
</tr>
<tr>
<td> 23 </td> <td> connectivity<br>(2) </td> <td> [ˌkɒnekˈtɪvɪti] </td> <td> 
<ul><li>Choosing the pattern of <font color=orangered>connectivity</font> is a problem for cross-validation, but this allows us to precisely tune the amount of communication until it is an acceptable fraction of the amount of computation.<span style="font-size:80%;opacity:0.8">连接模式的选择是一个交叉验证问题，但这可以让我们准确地调整通信数量，直到它的计算量在可接受的范围内。</span></li><li>Notice the specialization exhibited by the two GPUs, a result of the restricted <font color=orangered>connectivity</font> described in Section 3.5.<span style="font-size:80%;opacity:0.8">注意两个GPU表现出的专业化，3.5小节中描述的受限连接的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 24 </td> <td> layer-parts<br>(2) </td> <td>  </td> <td> 
<ul><li>One GPU runs the <font color=forestgreen>layer-parts</font> at the top of the figure while the other runs the <font color=forestgreen>layer-parts</font> at the bottom.<span style="font-size:80%;opacity:0.8">在图的顶部，一个GPU运行在部分层上，而在图的底部，另一个GPU运行在部分层上。</span></li></ul>
 </td>
</tr>
<tr>
<td> 25 </td> <td> response-normalized<br>(2) </td> <td>  </td> <td> 
<ul><li>Denoting by $a_{x,y}^i$ the activity of a neuron computed by applying kernel $i$ at position $(x, y)$ and then applying the ReLU nonlinearity, the <font color=forestgreen>response-normalized</font> activity $b^i_{x,y}$ is given by the expression<span style="font-size:80%;opacity:0.8">$a_{x,y}^i$表示神经元激活，通过在$(x, y)$位置应用核i，然后应用ReLU非线性来计算，响应归一化激活$b^i_{x,y}$通过下式给定：</span></li><li>The second convolutional layer takes as input the (<font color=forestgreen>response-normalized</font> and pooled) output of the first convolutional layer and filters it with 256 kernels of size 5 × 5 × 48.<span style="font-size:80%;opacity:0.8">第2卷积层使用用第1卷积层的输出（响应归一化和池化）作为输入，并使用256个核进行滤波，核大小为5 × 5 × 48。</span></li></ul>
 </td>
</tr>
<tr>
<td> 26 </td> <td> neighboring<br>(2) </td> <td> ['neɪbərɪŋ] </td> <td> 
<ul><li>Pooling layers in CNNs summarize the outputs of <font color=orangered>neighboring</font> groups of neurons in the same kernel map.<span style="font-size:80%;opacity:0.8">CNN中的池化层归纳了同一核映射上相邻组神经元的输出。</span></li><li>The first convolutional layer filters the 224 × 224 × 3 input image with 96 kernels of size 11 × 11 × 3 with a stride of 4 pixels (this is the distance between the receptive field centers of <font color=orangered>neighboring</font> neurons in a kernel map).<span style="font-size:80%;opacity:0.8">第1卷积层使用96个核对224 × 224 × 3的输入图像进行滤波，核大小为11 × 11 × 3，步长是4个像素（核映射中相邻神经元感受野中心之间的距离）。</span></li></ul>
 </td>
</tr>
<tr>
<td> 27 </td> <td> response-normalization<br>(2) </td> <td>  </td> <td> 
<ul><li>Max-pooling layers, of the kind described in Section 3.4, follow both <font color=forestgreen>response-normalization</font> layers as well as the fifth convolutional layer.<span style="font-size:80%;opacity:0.8">3.4节描述的这种最大池化层在响应归一化层和第5卷积层之后。</span></li><li><font color=forestgreen>Response-normalization</font> layers follow the first and second convolutional layers.<span style="font-size:80%;opacity:0.8">第1，2卷积层之后是响应归一化层。</span></li></ul>
 </td>
</tr>
<tr>
<td> 28 </td> <td> eigenvalue<br>(2) </td> <td> ['aɪdʒənˌvælju:] </td> <td> 
<ul><li>To each training image, we add multiples of the found principal components, with magnitudes proportional to the corresponding <font color=orangered>eigenvalues</font> times a random variable drawn from a Gaussian with mean zero and standard deviation 0.1.<span style="font-size:80%;opacity:0.8">对于每幅训练图像，我们加上多倍找到的主成分，大小成正比的对应特征值乘以一个随机变量，随机变量通过均值为0，标准差为0.1的高斯分布得到。</span></li><li>where $p_i$ and $\lambda_i$ are ith eigenvector and <font color=orangered>eigenvalue</font> of the $3 × 3$ covariance matrix of RGB pixel values, respectively, and $\alpha_i$ is the aforementioned random variable.<span style="font-size:80%;opacity:0.8">$p_i$，$\lambda_i$分别是RGB像素值$3 × 3$协方差矩阵的第i个特征向量和特征值，$\alpha_i$是前面提到的随机变量。</span></li></ul>
 </td>
</tr>
<tr>
<td> 29 </td> <td> gaussian<br>(2) </td> <td> ['gaʊsɪən] </td> <td> 
<ul><li>To each training image, we add multiples of the found principal components, with magnitudes proportional to the corresponding eigenvalues times a random variable drawn from a <font color=orangered>Gaussian</font> with mean zero and standard deviation 0.1.<span style="font-size:80%;opacity:0.8">对于每幅训练图像，我们加上多倍找到的主成分，大小成正比的对应特征值乘以一个随机变量，随机变量通过均值为0，标准差为0.1的高斯分布得到。</span></li><li>We initialized the weights in each layer from a zero-mean <font color=orangered>Gaussian</font> distribution with standard deviation 0.01.<span style="font-size:80%;opacity:0.8">我们使用均值为0，标准差为0.01的高斯分布对每一层的权重进行初始化。</span></li></ul>
 </td>
</tr>
<tr>
<td> 30 </td> <td> deviation<br>(2) </td> <td> [ˌdi:viˈeɪʃn] </td> <td> 
<ul><li>To each training image, we add multiples of the found principal components, with magnitudes proportional to the corresponding eigenvalues times a random variable drawn from a Gaussian with mean zero and standard <font color=orangered>deviation</font> 0.1.<span style="font-size:80%;opacity:0.8">对于每幅训练图像，我们加上多倍找到的主成分，大小成正比的对应特征值乘以一个随机变量，随机变量通过均值为0，标准差为0.1的高斯分布得到。</span></li><li>We initialized the weights in each layer from a zero-mean Gaussian distribution with standard <font color=orangered>deviation</font> 0.01.<span style="font-size:80%;opacity:0.8">我们使用均值为0，标准差为0.01的高斯分布对每一层的权重进行初始化。</span></li></ul>
 </td>
</tr>
<tr>
<td> 31 </td> <td> ith<br>(2) </td> <td>  </td> <td> 
<ul><li>where $p_i$ and $\lambda_i$ are <font color=forestgreen>ith</font> eigenvector and eigenvalue of the $3 × 3$ covariance matrix of RGB pixel values, respectively, and $\alpha_i$ is the aforementioned random variable.<span style="font-size:80%;opacity:0.8">$p_i$，$\lambda_i$分别是RGB像素值$3 × 3$协方差矩阵的第i个特征向量和特征值，$\alpha_i$是前面提到的随机变量。</span></li><li>where $i$ is the iteration index, $v$ is the momentum variable, $\varepsilon$ is the learning rate, and $\langle \frac{\partial L} {\partial w} |_{w_i}\rangle _{D_i}$ is the average over the <font color=forestgreen>ith</font> batch $D_i$ of the derivative of the objective with respect to $w$, evaluated at $w_i$.<span style="font-size:80%;opacity:0.8">$i$是迭代索引，$v$是动量变量，$\varepsilon$是学习率，$\langle \frac{\partial L} {\partial w} |_{w_i}\rangle _{D_i}$是目标函数对$w$，在$w_i$上的第$i$批微分$D_i$的平均。</span></li></ul>
 </td>
</tr>
<tr>
<td> 32 </td> <td> aforementioned<br>(2) </td> <td> [əˌfɔ:ˈmenʃənd] </td> <td> 
<ul><li>where $p_i$ and $\lambda_i$ are ith eigenvector and eigenvalue of the $3 × 3$ covariance matrix of RGB pixel values, respectively, and $\alpha_i$ is the <font color=orangered>aforementioned</font> random variable.<span style="font-size:80%;opacity:0.8">$p_i$，$\lambda_i$分别是RGB像素值$3 × 3$协方差矩阵的第i个特征向量和特征值，$\alpha_i$是前面提到的随机变量。</span></li><li>Averaging the predictions of two CNNs that were pre-trained on the entire Fall 2011 release with the <font color=orangered>aforementioned</font> five CNNs gives an error rate of 15.3%.<span style="font-size:80%;opacity:0.8">对在ImageNet 2011秋季发布的整个数据集上预训练的两个CNN和前面提到的五个CNN的预测进行平均得到了15.3%的错误率。</span></li></ul>
 </td>
</tr>
<tr>
<td> 33 </td> <td> momentum<br>(2) </td> <td> [məˈmentəm] </td> <td> 
<ul><li>We trained our models using stochastic gradient descent with a batch size of 128 examples, <font color=orangered>momentum</font> of 0.9, and weight decay of 0.0005.<span style="font-size:80%;opacity:0.8">我们使用随机梯度下降来训练我们的模型，样本的batch size为128，动量为0.9，权重衰减为0.0005。</span></li><li>where $i$ is the iteration index, $v$ is the <font color=orangered>momentum</font> variable, $\varepsilon$ is the learning rate, and $\langle \frac{\partial L} {\partial w} |_{w_i}\rangle _{D_i}$ is the average over the ith batch $D_i$ of the derivative of the objective with respect to $w$, evaluated at $w_i$.<span style="font-size:80%;opacity:0.8">$i$是迭代索引，$v$是动量变量，$\varepsilon$是学习率，$\langle \frac{\partial L} {\partial w} |_{w_i}\rangle _{D_i}$是目标函数对$w$，在$w_i$上的第$i$批微分$D_i$的平均。</span></li></ul>
 </td>
</tr>
<tr>
<td> 34 </td> <td> initialization<br>(2) </td> <td> [ɪˌnɪʃəlaɪ'zeɪʃn] </td> <td> 
<ul><li>This <font color=orangered>initialization</font> accelerates the early stages of learning by providing the ReLUs with positive inputs.<span style="font-size:80%;opacity:0.8">这个初始化通过为ReLU提供正输入加速了学习的早期阶段。</span></li><li>This kind of specialization occurs during every run and is independent of any particular random weight <font color=orangered>initialization</font> (modulo a renumbering of the GPUs).<span style="font-size:80%;opacity:0.8">这种专业化在每次运行时都会发生，并且是与任何特别的随机权重初始化（以GPU的重新编号为模）无关的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 35 </td> <td> FVs<br>(2) </td> <td>  </td> <td> 
<ul><li>The best performance achieved during the ILSVRC-2010 competition was 47.1% and 28.2% with an approach that averages the predictions produced from six sparse-coding models trained on different features [2], and since then the best published results are 45.7% and 25.7% with an approach that averages the predictions of two classifiers trained on Fisher Vectors (<font color=forestgreen>FVs</font>) computed from two types of densely-sampled features [24].<span style="font-size:80%;opacity:0.8">在ILSVRC-2010竞赛中最佳结果是top-1 47.1%，top-5 28.2%，使用的方法是对6个在不同特征上训练的稀疏编码模型生成的预测进行平均，从那时起已公布的最好结果是top-1 45.7%，top-5 25.7%，使用的方法是平均在Fisher向量（FV）上训练的两个分类器的预测结果，Fisher向量是通过两种密集采样特征计算得到的[24]。</span></li><li>The second-best contest entry achieved an error rate of 26.2% with an approach that averages the predictions of several classifiers trained on <font color=forestgreen>FVs</font> computed from different types of densely-sampled features [7].<span style="font-size:80%;opacity:0.8">第二名的最好竞赛输入取得了26.2%的错误率，他的方法是对FV上训练的一些分类器的预测结果进行平均，FV在不同类型密集采样特征计算得到的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 36 </td> <td> densely-sampled<br>(2) </td> <td>  </td> <td> 
<ul><li>The best performance achieved during the ILSVRC-2010 competition was 47.1% and 28.2% with an approach that averages the predictions produced from six sparse-coding models trained on different features [2], and since then the best published results are 45.7% and 25.7% with an approach that averages the predictions of two classifiers trained on Fisher Vectors (FVs) computed from two types of <font color=forestgreen>densely-sampled</font> features [24].<span style="font-size:80%;opacity:0.8">在ILSVRC-2010竞赛中最佳结果是top-1 47.1%，top-5 28.2%，使用的方法是对6个在不同特征上训练的稀疏编码模型生成的预测进行平均，从那时起已公布的最好结果是top-1 45.7%，top-5 25.7%，使用的方法是平均在Fisher向量（FV）上训练的两个分类器的预测结果，Fisher向量是通过两种密集采样特征计算得到的[24]。</span></li><li>The second-best contest entry achieved an error rate of 26.2% with an approach that averages the predictions of several classifiers trained on FVs computed from different types of <font color=forestgreen>densely-sampled</font> features [7].<span style="font-size:80%;opacity:0.8">第二名的最好竞赛输入取得了26.2%的错误率，他的方法是对FV上训练的一些分类器的预测结果进行平均，FV在不同类型密集采样特征计算得到的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 37 </td> <td> italic<br>(2) </td> <td> [ɪˈtælɪk] </td> <td> 
<ul><li>In <font color=orangered>italics</font> are best results achieved by others.<span style="font-size:80%;opacity:0.8">斜体是其它人取得的最好结果。</span></li><li>In <font color=orangered>italics</font> are best results achieved by others.<span style="font-size:80%;opacity:0.8">斜线部分是其它人取得的最好的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 38 </td> <td> specialization<br>(2) </td> <td> [ˌspeʃəlaɪ'zeɪʃn] </td> <td> 
<ul><li>Notice the <font color=orangered>specialization</font> exhibited by the two GPUs, a result of the restricted connectivity described in Section 3.5.<span style="font-size:80%;opacity:0.8">注意两个GPU表现出的专业化，3.5小节中描述的受限连接的结果。</span></li><li>This kind of <font color=orangered>specialization</font> occurs during every run and is independent of any particular random weight initialization (modulo a renumbering of the GPUs).<span style="font-size:80%;opacity:0.8">这种专业化在每次运行时都会发生，并且是与任何特别的随机权重初始化（以GPU的重新编号为模）无关的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 39 </td> <td> Krizhevsky<br>(1) </td> <td>  </td> <td> 
<ul><li>Authors: <font color=forestgreen>Krizhevsky</font>, Alex (University of Toronto, Canada); Sutskever, Ilya; Hinton, Geoffrey E.<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 40 </td> <td> Alex<br>(1) </td> <td> ['ælɪkʃ] </td> <td> 
<ul><li>Authors: Krizhevsky, <font color=orangered>Alex</font> (University of Toronto, Canada); Sutskever, Ilya; Hinton, Geoffrey E.<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 41 </td> <td> Toronto<br>(1) </td> <td> [tə'rɔntəu] </td> <td> 
<ul><li>Authors: Krizhevsky, Alex (University of <font color=orangered>Toronto</font>, Canada); Sutskever, Ilya; Hinton, Geoffrey E.<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 42 </td> <td> Sutskever<br>(1) </td> <td>  </td> <td> 
<ul><li>Authors: Krizhevsky, Alex (University of Toronto, Canada); <font color=forestgreen>Sutskever</font>, Ilya; Hinton, Geoffrey E.<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 43 </td> <td> ilya<br>(1) </td> <td>  </td> <td> 
<ul><li>Authors: Krizhevsky, Alex (University of Toronto, Canada); Sutskever, <font color=forestgreen>Ilya</font>; Hinton, Geoffrey E.<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 44 </td> <td> Geoffrey<br>(1) </td> <td> ['dʒefrɪ] </td> <td> 
<ul><li>Authors: Krizhevsky, Alex (University of Toronto, Canada); Sutskever, Ilya; Hinton, <font color=orangered>Geoffrey</font> E.<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 45 </td> <td> nip<br>(1) </td> <td> [nɪp] </td> <td> 
<ul><li>Source: Advances in Neural Information Processing Systems, v 2, p 1097-1105, 2012, 26th Annual Conference on Neural Information Processing Systems 2012, <font color=orangered>NIPS</font> 2012<span style="font-size:80%;opacity:0.8"></span></li></ul>
 </td>
</tr>
<tr>
<td> 46 </td> <td> LSVRC<br>(1) </td> <td>  </td> <td> 
<ul><li>We trained a large, deep convolutional neural network to classify the 1.2 million high-resolution images in the ImageNet <font color=forestgreen>LSVRC</font>-2010 contest into the 1000 different classes.<span style="font-size:80%;opacity:0.8">我们训练了一个大型深度卷积神经网络来将ImageNet LSVRC-2010竞赛的120万高分辨率的图像分到1000不同的类别中。</span></li></ul>
 </td>
</tr>
<tr>
<td> 47 </td> <td> variant<br>(1) </td> <td> [ˈveəriənt] </td> <td> 
<ul><li>We also entered a <font color=orangered>variant</font> of this model in the ILSVRC-2012 competition and achieved a winning top-5 test error rate of 15.3%, compared to 26.2% achieved by the second-best entry.<span style="font-size:80%;opacity:0.8">我们也使用这个模型的一个变种参加了ILSVRC-2012竞赛，赢得了冠军并且与第二名 top-5 26.2%的错误率相比，我们取得了top-5 15.3%的错误率。</span></li></ul>
 </td>
</tr>
<tr>
<td> 48 </td> <td> NORB<br>(1) </td> <td>  </td> <td> 
<ul><li>Until recently, datasets of labeled images were relatively small -- on the order of tens of thousands of images (e.g., <font color=forestgreen>NORB</font> [16], Caltech-101/256 [8, 9], and CIFAR-10/100 [12]). Simple recognition tasks can be solved quite well with datasets of this size, especially if they are augmented with label-preserving transformations.<span style="font-size:80%;opacity:0.8">直到最近，标注图像的数据集都相对较小--在几万张图像的数量级上（例如，NORB[16]，Caltech-101/256 [8, 9]和CIFAR-10/100 [12]）。简单的识别任务在这样大小的数据集上可以被解决的相当好，尤其是如果通过标签保留变换进行数据增强的情况下。</span></li></ul>
 </td>
</tr>
<tr>
<td> 49 </td> <td> augment<br>(1) </td> <td> [ɔ:gˈment] </td> <td> 
<ul><li>Until recently, datasets of labeled images were relatively small -- on the order of tens of thousands of images (e.g., NORB [16], Caltech-101/256 [8, 9], and CIFAR-10/100 [12]). Simple recognition tasks can be solved quite well with datasets of this size, especially if they are <font color=orangered>augmented</font> with label-preserving transformations.<span style="font-size:80%;opacity:0.8">直到最近，标注图像的数据集都相对较小--在几万张图像的数量级上（例如，NORB[16]，Caltech-101/256 [8, 9]和CIFAR-10/100 [12]）。简单的识别任务在这样大小的数据集上可以被解决的相当好，尤其是如果通过标签保留变换进行数据增强的情况下。</span></li></ul>
 </td>
</tr>
<tr>
<td> 50 </td> <td> MNIST<br>(1) </td> <td>  </td> <td> 
<ul><li>For example, the current best error rate on the <font color=forestgreen>MNIST</font> digit-recognition task (&lt;0.3%) approaches human performance [4].<span style="font-size:80%;opacity:0.8">例如，目前在MNIST数字识别任务上（&lt;0.3%）的最好准确率已经接近了人类水平[4]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 51 </td> <td> digit-recognition<br>(1) </td> <td>  </td> <td> 
<ul><li>For example, the current best error rate on the MNIST <font color=forestgreen>digit-recognition</font> task (&lt;0.3%) approaches human performance [4].<span style="font-size:80%;opacity:0.8">例如，目前在MNIST数字识别任务上（&lt;0.3%）的最好准确率已经接近了人类水平[4]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 52 </td> <td> variability<br>(1) </td> <td> [ˌveəriəˈbɪləti] </td> <td> 
<ul><li>But objects in realistic settings exhibit considerable <font color=orangered>variability</font>, so to learn to recognize them it is necessary to use much larger training sets.<span style="font-size:80%;opacity:0.8">但真实环境中的对象表现出了相当大的可变性，因此为了学习识别它们，有必要使用更大的训练数据集。</span></li></ul>
 </td>
</tr>
<tr>
<td> 53 </td> <td> pinto<br>(1) </td> <td> [ˈpɪntəʊ] </td> <td> 
<ul><li>And indeed, the shortcomings of small image datasets have been widely recognized (e.g., <font color=orangered>Pinto</font> et al. [21]), but it has only recently become possible to collect labeled datasets with millions of images.<span style="font-size:80%;opacity:0.8">实际上，小图像数据集的缺点已经被广泛认识到（例如，Pinto et al. [21]），但收集上百万图像的标注数据仅在最近才变得的可能。</span></li></ul>
 </td>
</tr>
<tr>
<td> 54 </td> <td> LabelMe<br>(1) </td> <td>  </td> <td> 
<ul><li>The new larger datasets include <font color=forestgreen>LabelMe</font> [23], which consists of hundreds of thousands of fully-segmented images, and ImageNet [6], which consists of over 15 million labeled high-resolution images in over 22,000 categories.<span style="font-size:80%;opacity:0.8">新的更大的数据集包括LabelMe [23]，它包含了数十万张完全分割的图像，ImageNet[6]，它包含了22000个类别上的超过1500万张标注的高分辨率的图像。</span></li></ul>
 </td>
</tr>
<tr>
<td> 55 </td> <td> immense<br>(1) </td> <td> [ɪˈmens] </td> <td> 
<ul><li>However, the <font color=orangered>immense</font> complexity of the object recognition task means that this problem cannot be specified even by a dataset as large as ImageNet, so our model should also have lots of prior knowledge to compensate for all the data we don’t have.<span style="font-size:80%;opacity:0.8">然而对象识别任务的巨大复杂性意味着这个问题不能被指定，即使通过像ImageNet这样的大数据集，因此我们的模型应该也有许多先验知识来补偿我们所没有的数据。</span></li></ul>
 </td>
</tr>
<tr>
<td> 56 </td> <td> constitute<br>(1) </td> <td> [ˈkɒnstɪtju:t] </td> <td> 
<ul><li>Convolutional neural networks (CNNs) <font color=orangered>constitute</font> one such class of models [16, 11, 13, 18, 15, 22, 26].<span style="font-size:80%;opacity:0.8">卷积神经网络(CNNs)构成了一个这样的模型[16, 11, 13, 18, 15, 22, 26]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 57 </td> <td> stationarity<br>(1) </td> <td> [steɪʃə'nærɪtɪ] </td> <td> 
<ul><li>Their capacity can be controlled by varying their depth and breadth, and they also make strong and mostly correct assumptions about the nature of images (namely, <font color=orangered>stationarity</font> of statistics and locality of pixel dependencies).<span style="font-size:80%;opacity:0.8">它们的能力可以通过改变它们的广度和深度来控制，它们也可以对图像的本质进行强大且通常正确的假设（也就是说，统计的稳定性和像素依赖的局部性）。</span></li></ul>
 </td>
</tr>
<tr>
<td> 58 </td> <td> feedforward<br>(1) </td> <td> [fi:d'fɔ:wəd] </td> <td> 
<ul><li>Thus, compared to standard <font color=orangered>feedforward</font> neural networks with similarly-sized layers, CNNs have much fewer connections and parameters and so they are easier to train, while their theoretically-best performance is likely to be only slightly worse.<span style="font-size:80%;opacity:0.8">因此，与具有层次大小相似的标准前馈神经网络，CNNs有更少的连接和参数，因此它们更容易训练，而它们理论上的最佳性能可能仅比标准前馈神经网络差一点。</span></li></ul>
 </td>
</tr>
<tr>
<td> 59 </td> <td> similarly-sized<br>(1) </td> <td>  </td> <td> 
<ul><li>Thus, compared to standard feedforward neural networks with <font color=forestgreen>similarly-sized</font> layers, CNNs have much fewer connections and parameters and so they are easier to train, while their theoretically-best performance is likely to be only slightly worse.<span style="font-size:80%;opacity:0.8">因此，与具有层次大小相似的标准前馈神经网络，CNNs有更少的连接和参数，因此它们更容易训练，而它们理论上的最佳性能可能仅比标准前馈神经网络差一点。</span></li></ul>
 </td>
</tr>
<tr>
<td> 60 </td> <td> theoretically-best<br>(1) </td> <td>  </td> <td> 
<ul><li>Thus, compared to standard feedforward neural networks with similarly-sized layers, CNNs have much fewer connections and parameters and so they are easier to train, while their <font color=forestgreen>theoretically-best</font> performance is likely to be only slightly worse.<span style="font-size:80%;opacity:0.8">因此，与具有层次大小相似的标准前馈神经网络，CNNs有更少的连接和参数，因此它们更容易训练，而它们理论上的最佳性能可能仅比标准前馈神经网络差一点。</span></li></ul>
 </td>
</tr>
<tr>
<td> 61 </td> <td> prohibitively<br>(1) </td> <td> [prəʊˈhɪbɪtɪvlɪ] </td> <td> 
<ul><li>Despite the attractive qualities of CNNs, and despite the relative efficiency of their local architecture, they have still been <font color=orangered>prohibitively</font> expensive to apply in large scale to high-resolution images.<span style="font-size:80%;opacity:0.8">尽管CNN具有引人注目的特性，尽管CNN的局部架构相当有效，但将它们大规模的应用到到高分辨率图像中仍然是代价极高的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 62 </td> <td> interestingly-large<br>(1) </td> <td>  </td> <td> 
<ul><li>Luckily, current GPUs, paired with a highly-optimized implementation of 2D convolution, are powerful enough to facilitate the training of <font color=forestgreen>interestingly-large</font> CNNs, and recent datasets such as ImageNet contain enough labeled examples to train such models without severe overfitting.<span style="font-size:80%;opacity:0.8">幸运的是，目前的GPU，搭配了高度优化的2D卷积实现，强大到足够促进有趣地大量CNN的训练，最近的数据集例如ImageNet包含足够的标注样本来训练这样的模型而没有严重的过拟合。</span></li></ul>
 </td>
</tr>
<tr>
<td> 63 </td> <td> labelers<br>(1) </td> <td>  </td> <td> 
<ul><li>The images were collected from the web and labeled by human <font color=forestgreen>labelers</font> using Amazon’s Mechanical Turk crowd-sourcing tool.<span style="font-size:80%;opacity:0.8">这些图像是从网上收集的，使用了Amazon’s Mechanical Turk的众包工具通过人工标注的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 64 </td> <td> turk<br>(1) </td> <td> [tә:k] </td> <td> 
<ul><li>The images were collected from the web and labeled by human labelers using Amazon’s Mechanical <font color=orangered>Turk</font> crowd-sourcing tool.<span style="font-size:80%;opacity:0.8">这些图像是从网上收集的，使用了Amazon’s Mechanical Turk的众包工具通过人工标注的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 65 </td> <td> crowd-sourcing<br>(1) </td> <td>  </td> <td> 
<ul><li>The images were collected from the web and labeled by human labelers using Amazon’s Mechanical Turk <font color=forestgreen>crowd-sourcing</font> tool.<span style="font-size:80%;opacity:0.8">这些图像是从网上收集的，使用了Amazon’s Mechanical Turk的众包工具通过人工标注的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 66 </td> <td> pascal<br>(1) </td> <td> ['pæskәl] </td> <td> 
<ul><li>Starting in 2010, as part of the <font color=orangered>Pascal</font> Visual Object Challenge, an annual competition called the ImageNet Large-Scale Visual Recognition Challenge (ILSVRC) has been held.<span style="font-size:80%;opacity:0.8">从2010年起，作为Pascal视觉对象挑战赛的一部分，每年都会举办ImageNet大规模视觉识别挑战赛（ILSVRC）。</span></li></ul>
 </td>
</tr>
<tr>
<td> 67 </td> <td> variable-resolution<br>(1) </td> <td>  </td> <td> 
<ul><li>ImageNet consists of <font color=forestgreen>variable-resolution</font> images, while our system requires a constant input dimensionality.<span style="font-size:80%;opacity:0.8">ImageNet包含各种分辨率的图像，而我们的系统要求不变的输入维度。</span></li></ul>
 </td>
</tr>
<tr>
<td> 68 </td> <td> down-sampled<br>(1) </td> <td>  </td> <td> 
<ul><li>Therefore, we <font color=forestgreen>down-sampled</font> the images to a fixed resolution of 256 × 256.<span style="font-size:80%;opacity:0.8">因此，我们将图像进行下采样到固定的256×256分辨率。</span></li></ul>
 </td>
</tr>
<tr>
<td> 69 </td> <td> rectangular<br>(1) </td> <td> [rek'tæŋɡjələ(r)] </td> <td> 
<ul><li>Given a <font color=orangered>rectangular</font> image, we first rescaled the image such that the shorter side was of length 256, and then cropped out the central 256×256 patch from the resulting image.<span style="font-size:80%;opacity:0.8">给定一个矩形图像，我们首先缩放图像短边长度为256，然后从结果图像中裁剪中心的256×256大小的图像块。</span></li></ul>
 </td>
</tr>
<tr>
<td> 70 </td> <td> rescale<br>(1) </td> <td> [ri:'skeɪl] </td> <td> 
<ul><li>Given a rectangular image, we first <font color=orangered>rescaled</font> the image such that the shorter side was of length 256, and then cropped out the central 256×256 patch from the resulting image.<span style="font-size:80%;opacity:0.8">给定一个矩形图像，我们首先缩放图像短边长度为256，然后从结果图像中裁剪中心的256×256大小的图像块。</span></li></ul>
 </td>
</tr>
<tr>
<td> 71 </td> <td> nonlinearities<br>(1) </td> <td>  </td> <td> 
<ul><li>In terms of training time with gradient descent, these saturating <font color=forestgreen>nonlinearities</font> are much slower than the non-saturating nonlinearity $f(x) = \max(0,x)$.<span style="font-size:80%;opacity:0.8">考虑到梯度下降的训练时间，这些饱和的非线性比非饱和非线性$f(x) = \max(0,x)$更慢。</span></li></ul>
 </td>
</tr>
<tr>
<td> 72 </td> <td> Nair<br>(1) </td> <td> ['nɑ:ɪə] </td> <td> 
<ul><li>Following <font color=orangered>Nair</font> and Hinton [20], we refer to neurons with this nonlinearity as Rectified Linear Units (ReLUs).<span style="font-size:80%;opacity:0.8">根据Nair和Hinton[20]的说法，我们将这种非线性神经元称为修正线性单元(ReLU)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 73 </td> <td> rectify<br>(1) </td> <td> [ˈrektɪfaɪ] </td> <td> 
<ul><li>Following Nair and Hinton [20], we refer to neurons with this nonlinearity as <font color=orangered>Rectified</font> Linear Units (ReLUs).<span style="font-size:80%;opacity:0.8">根据Nair和Hinton[20]的说法，我们将这种非线性神经元称为修正线性单元(ReLU)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 74 </td> <td> dash<br>(1) </td> <td> [dæʃ] </td> <td> 
<ul><li>Figure 1: A four-layer convolutional neural network with ReLUs (solid line) reaches a 25% training error rate on CIFAR-10 six times faster than an equivalent network with tanh neurons (<font color=orangered>dashed</font> line).<span style="font-size:80%;opacity:0.8">图1：使用ReLU的四层卷积神经网络在CIFAR-10数据集上达到25%的训练误差比使用tanh神经元的等价网络（虚线）快六倍。</span></li></ul>
 </td>
</tr>
<tr>
<td> 75 </td> <td> consistently<br>(1) </td> <td> [kən'sɪstəntlɪ] </td> <td> 
<ul><li>The magnitude of the effect demonstrated here varies with network architecture, but networks with ReLUs <font color=orangered>consistently</font> learn several times faster than equivalents with saturating neurons.<span style="font-size:80%;opacity:0.8">影响的大小随着网络结构的变化而变化，这一点已得到证实，但使用ReLU的网络都比等价的饱和神经元快几倍。</span></li></ul>
 </td>
</tr>
<tr>
<td> 76 </td> <td> cross-GPU<br>(1) </td> <td>  </td> <td> 
<ul><li>Current GPUs are particularly well-suited to <font color=forestgreen>cross-GPU</font> parallelization, as they are able to read from and write to one another’s memory directly, without going through host machine memory.<span style="font-size:80%;opacity:0.8">目前的GPU非常适合跨GPU并行，因为它们可以直接互相读写内存，而不需要通过主机内存。</span></li></ul>
 </td>
</tr>
<tr>
<td> 77 </td> <td> cross-validation<br>(1) </td> <td> [k'rɒsvælɪd'eɪʃn] </td> <td> 
<ul><li>Choosing the pattern of connectivity is a problem for <font color=orangered>cross-validation</font>, but this allows us to precisely tune the amount of communication until it is an acceptable fraction of the amount of computation.<span style="font-size:80%;opacity:0.8">连接模式的选择是一个交叉验证问题，但这可以让我们准确地调整通信数量，直到它的计算量在可接受的范围内。</span></li></ul>
 </td>
</tr>
<tr>
<td> 78 </td> <td> resultant<br>(1) </td> <td> [rɪˈzʌltənt] </td> <td> 
<ul><li>The <font color=orangered>resultant</font> architecture is somewhat similar to that of the “columnar” CNN employed by Ciresan et al. [5], except that our columns are not independent (see Figure 2).<span style="font-size:80%;opacity:0.8">除了我们的列不是独立的之外（看图2），最终的架构有点类似于Ciresan等人[5]采用的“columnar” CNN。</span></li></ul>
 </td>
</tr>
<tr>
<td> 79 </td> <td> columnar<br>(1) </td> <td> [kə'lʌmnə] </td> <td> 
<ul><li>The resultant architecture is somewhat similar to that of the “<font color=orangered>columnar</font>” CNN employed by Ciresan et al. [5], except that our columns are not independent (see Figure 2).<span style="font-size:80%;opacity:0.8">除了我们的列不是独立的之外（看图2），最终的架构有点类似于Ciresan等人[5]采用的“columnar” CNN。</span></li></ul>
 </td>
</tr>
<tr>
<td> 80 </td> <td> Ciresan<br>(1) </td> <td>  </td> <td> 
<ul><li>The resultant architecture is somewhat similar to that of the “columnar” CNN employed by <font color=forestgreen>Ciresan</font> et al. [5], except that our columns are not independent (see Figure 2).<span style="font-size:80%;opacity:0.8">除了我们的列不是独立的之外（看图2），最终的架构有点类似于Ciresan等人[5]采用的“columnar” CNN。</span></li></ul>
 </td>
</tr>
<tr>
<td> 81 </td> <td> delineation<br>(1) </td> <td> [dɪˌlɪnɪ'eɪʃn] </td> <td> 
<ul><li>Figure 2: An illustration of the architecture of our CNN, explicitly showing the <font color=orangered>delineation</font> of responsibilities between the two GPUs.<span style="font-size:80%;opacity:0.8">图 2：我们CNN架构图解，明确描述了两个GPU之间的责任。</span></li></ul>
 </td>
</tr>
<tr>
<td> 82 </td> <td> arbitrary<br>(1) </td> <td> [ˈɑ:bɪtrəri] </td> <td> 
<ul><li>The ordering of the kernel maps is of course <font color=orangered>arbitrary</font> and determined before training begins.<span style="font-size:80%;opacity:0.8">核映射的顺序当然是任意的，在训练开始前确定。</span></li></ul>
 </td>
</tr>
<tr>
<td> 83 </td> <td> lateral<br>(1) </td> <td> [ˈlætərəl] </td> <td> 
<ul><li>This sort of response normalization implements a form of <font color=orangered>lateral</font> inhibition inspired by the type found in real neurons, creating competition for big activities amongst neuron outputs computed using different kernels.<span style="font-size:80%;opacity:0.8">响应归一化的顺序实现了一种侧抑制形式，灵感来自于真实神经元中发现的类型，为使用不同核进行神经元输出计算的较大活动创造了竞争。</span></li></ul>
 </td>
</tr>
<tr>
<td> 84 </td> <td> inhibition<br>(1) </td> <td> [ˌɪnhɪˈbɪʃn] </td> <td> 
<ul><li>This sort of response normalization implements a form of lateral <font color=orangered>inhibition</font> inspired by the type found in real neurons, creating competition for big activities amongst neuron outputs computed using different kernels.<span style="font-size:80%;opacity:0.8">响应归一化的顺序实现了一种侧抑制形式，灵感来自于真实神经元中发现的类型，为使用不同核进行神经元输出计算的较大活动创造了竞争。</span></li></ul>
 </td>
</tr>
<tr>
<td> 85 </td> <td> hyper-parameters<br>(1) </td> <td>  </td> <td> 
<ul><li>The constants $k, n, \alpha$, and $\beta$ are <font color=forestgreen>hyper-parameters</font> whose values are determined using a validation set; we used $k = 2, n = 5, \alpha = 0.0001$, and $\beta = 0.75$.<span style="font-size:80%;opacity:0.8">常量$k, n, \alpha, \beta$是超参数，它们的值通过验证集确定；我们设$k = 2, n = 5, \alpha = 0.0001, \beta = 0.75$。</span></li></ul>
 </td>
</tr>
<tr>
<td> 86 </td> <td> brightness<br>(1) </td> <td> ['braɪtnəs] </td> <td> 
<ul><li>This scheme bears some resemblance to the local contrast normalization scheme of Jarrett et al. [11], but ours would be more correctly termed “<font color=orangered>brightness</font> normalization”, since we do not subtract the mean activity.<span style="font-size:80%;opacity:0.8">这个方案与Jarrett等人[11]的局部对比度归一化方案有一定的相似性，但我们更恰当的称其为“亮度归一化”，因此我们没有减去均值。</span></li></ul>
 </td>
</tr>
<tr>
<td> 87 </td> <td> overfit<br>(1) </td> <td>  </td> <td> 
<ul><li>We generally observe during training that models with overlapping pooling find it slightly more difficult to <font color=forestgreen>overfit</font>.<span style="font-size:80%;opacity:0.8">我们在训练过程中通常观察采用重叠池化的模型，发现它更难过拟合。</span></li></ul>
 </td>
</tr>
<tr>
<td> 88 </td> <td> multinomial<br>(1) </td> <td> [ˌmʌltɪ'nəʊmɪəl] </td> <td> 
<ul><li>Our network maximizes the <font color=orangered>multinomial</font> logistic regression objective, which is equivalent to maximizing the average across training cases of the log-probability of the correct label under the prediction distribution.<span style="font-size:80%;opacity:0.8">我们的网络最大化多项逻辑回归的目标，这等价于最大化预测分布下训练样本正确标签的对数概率的均值。</span></li></ul>
 </td>
</tr>
<tr>
<td> 89 </td> <td> log-probability<br>(1) </td> <td>  </td> <td> 
<ul><li>Our network maximizes the multinomial logistic regression objective, which is equivalent to maximizing the average across training cases of the <font color=forestgreen>log-probability</font> of the correct label under the prediction distribution.<span style="font-size:80%;opacity:0.8">我们的网络最大化多项逻辑回归的目标，这等价于最大化预测分布下训练样本正确标签的对数概率的均值。</span></li></ul>
 </td>
</tr>
<tr>
<td> 90 </td> <td> non-linearity<br>(1) </td> <td> ['nɒnlaɪn'ərɪtɪ] </td> <td> 
<ul><li>The ReLU <font color=orangered>non-linearity</font> is applied to the output of every convolutional and fully-connected layer.<span style="font-size:80%;opacity:0.8">ReLU非线性应用在每个卷积层和全连接层的输出上。</span></li></ul>
 </td>
</tr>
<tr>
<td> 91 </td> <td> receptive<br>(1) </td> <td> [rɪˈseptɪv] </td> <td> 
<ul><li>The first convolutional layer filters the 224 × 224 × 3 input image with 96 kernels of size 11 × 11 × 3 with a stride of 4 pixels (this is the distance between the <font color=orangered>receptive</font> field centers of neighboring neurons in a kernel map).<span style="font-size:80%;opacity:0.8">第1卷积层使用96个核对224 × 224 × 3的输入图像进行滤波，核大小为11 × 11 × 3，步长是4个像素（核映射中相邻神经元感受野中心之间的距离）。</span></li></ul>
 </td>
</tr>
<tr>
<td> 92 </td> <td> normalize<br>(1) </td> <td> [ˈnɔ:məlaɪz] </td> <td> 
<ul><li>The third convolutional layer has 384 kernels of size 3 × 3 × 256 connected to the (<font color=orangered>normalized</font>, pooled) outputs of the second convolutional layer.<span style="font-size:80%;opacity:0.8">第3卷积层有384个核，核大小为3 × 3 × 256，与第2卷积层的输出（归一化的，池化的）相连。</span></li></ul>
 </td>
</tr>
<tr>
<td> 93 </td> <td> artificially<br>(1) </td> <td> [ˌɑ:tɪ'fɪʃəlɪ] </td> <td> 
<ul><li>The easiest and most common method to reduce overfitting on image data is to <font color=orangered>artificially</font> enlarge the dataset using label-preserving transformations (e.g., [25, 4, 5]).<span style="font-size:80%;opacity:0.8">图像数据上最简单常用的用来减少过拟合的方法是使用标签保留变换（例如[25, 4, 5]）来人工增大数据集。</span></li></ul>
 </td>
</tr>
<tr>
<td> 94 </td> <td> computationally<br>(1) </td> <td>  </td> <td> 
<ul><li>So these data augmentation schemes are, in effect, <font color=forestgreen>computationally</font> free.<span style="font-size:80%;opacity:0.8">因此，实际上这些数据增强方案是计算免费的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 95 </td> <td> interdependent<br>(1) </td> <td> [ˌɪntədɪˈpendənt] </td> <td> 
<ul><li>This increases the size of our training set by a factor of 2048, though the resulting training examples are, of course, highly <font color=orangered>interdependent</font>.<span style="font-size:80%;opacity:0.8">这通过一个2048因子增大了我们的训练集，尽管最终的训练样本是高度相关的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 96 </td> <td> Specifically<br>(1) </td> <td> [spəˈsɪfɪkli] </td> <td> 
<ul><li><font color=orangered>Specifically</font>, we perform PCA on the set of RGB pixel values throughout the ImageNet training set.<span style="font-size:80%;opacity:0.8">具体地，我们在整个ImageNet训练集上对RGB像素值集合执行PCA。</span></li></ul>
 </td>
</tr>
<tr>
<td> 97 </td> <td> pca<br>(1) </td> <td>  </td> <td> 
<ul><li>Specifically, we perform <font color=forestgreen>PCA</font> on the set of RGB pixel values throughout the ImageNet training set.<span style="font-size:80%;opacity:0.8">具体地，我们在整个ImageNet训练集上对RGB像素值集合执行PCA。</span></li></ul>
 </td>
</tr>
<tr>
<td> 98 </td> <td> proportional<br>(1) </td> <td> [prəˈpɔ:ʃənl] </td> <td> 
<ul><li>To each training image, we add multiples of the found principal components, with magnitudes <font color=orangered>proportional</font> to the corresponding eigenvalues times a random variable drawn from a Gaussian with mean zero and standard deviation 0.1.<span style="font-size:80%;opacity:0.8">对于每幅训练图像，我们加上多倍找到的主成分，大小成正比的对应特征值乘以一个随机变量，随机变量通过均值为0，标准差为0.1的高斯分布得到。</span></li></ul>
 </td>
</tr>
<tr>
<td> 99 </td> <td> eigenvector<br>(1) </td> <td> ['aɪgənvektə(r)] </td> <td> 
<ul><li>where $p_i$ and $\lambda_i$ are ith <font color=orangered>eigenvector</font> and eigenvalue of the $3 × 3$ covariance matrix of RGB pixel values, respectively, and $\alpha_i$ is the aforementioned random variable.<span style="font-size:80%;opacity:0.8">$p_i$，$\lambda_i$分别是RGB像素值$3 × 3$协方差矩阵的第i个特征向量和特征值，$\alpha_i$是前面提到的随机变量。</span></li></ul>
 </td>
</tr>
<tr>
<td> 100 </td> <td> covariance<br>(1) </td> <td> [kəʊ'veərɪəns] </td> <td> 
<ul><li>where $p_i$ and $\lambda_i$ are ith eigenvector and eigenvalue of the $3 × 3$ <font color=orangered>covariance</font> matrix of RGB pixel values, respectively, and $\alpha_i$ is the aforementioned random variable.<span style="font-size:80%;opacity:0.8">$p_i$，$\lambda_i$分别是RGB像素值$3 × 3$协方差矩阵的第i个特征向量和特征值，$\alpha_i$是前面提到的随机变量。</span></li></ul>
 </td>
</tr>
<tr>
<td> 101 </td> <td> re-draw<br>(1) </td> <td> [ri'drɔ] </td> <td> 
<ul><li>Each $\alpha_i$ is drawn only once for all the pixels of a particular training image until that image is used for training again, at which point it is <font color=orangered>re-drawn</font>.<span style="font-size:80%;opacity:0.8">对于某个训练图像的所有像素，每个$\alpha_i$只获取一次，直到图像进行下一次训练时才重新获取。</span></li></ul>
 </td>
</tr>
<tr>
<td> 102 </td> <td> invariant<br>(1) </td> <td> [ɪnˈveəriənt] </td> <td> 
<ul><li>This scheme approximately captures an important property of natural images, namely, that object identity is <font color=orangered>invariant</font> to changes in the intensity and color of the illumination.<span style="font-size:80%;opacity:0.8">这个方案近似抓住了自然图像的一个重要特性，即光照的颜色和强度发生变化时，目标身份是不变的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 103 </td> <td> back-propagation<br>(1) </td> <td>  </td> <td> 
<ul><li>The neurons which are “dropped out” in this way do not contribute to the forward pass and do not participate in <font color=forestgreen>back-propagation</font>.<span style="font-size:80%;opacity:0.8">那些“失活的”的神经元不再进行前向传播并且不参与反向传播。</span></li></ul>
 </td>
</tr>
<tr>
<td> 104 </td> <td> co-adaptations<br>(1) </td> <td>  </td> <td> 
<ul><li>This technique reduces complex <font color=forestgreen>co-adaptations</font> of neurons, since a neuron cannot rely on the presence of particular other neurons.<span style="font-size:80%;opacity:0.8">这个技术减少了复杂的神经元互适应，因为一个神经元不能依赖特定的其它神经元的存在。</span></li></ul>
 </td>
</tr>
<tr>
<td> 105 </td> <td> conjunction<br>(1) </td> <td> [kənˈdʒʌŋkʃn] </td> <td> 
<ul><li>It is, therefore, forced to learn more robust features that are useful in <font color=orangered>conjunction</font> with many different random subsets of the other neurons.<span style="font-size:80%;opacity:0.8">因此，神经元被强迫学习更鲁棒的特征，它在与许多不同的其它神经元的随机子集结合时是有用的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 106 </td> <td> approximation<br>(1) </td> <td> [əˌprɒksɪˈmeɪʃn] </td> <td> 
<ul><li>At test time, we use all the neurons but multiply their outputs by 0.5, which is a reasonable <font color=orangered>approximation</font> to taking the geometric mean of the predictive distributions produced by the exponentially-many dropout networks.<span style="font-size:80%;opacity:0.8">在测试时，我们使用所有的神经元但它们的输出乘以0.5，对指数级的许多失活网络的预测分布进行几何平均，这是一种合理的近似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 107 </td> <td> geometric<br>(1) </td> <td> [ˌdʒi:əˈmetrɪk] </td> <td> 
<ul><li>At test time, we use all the neurons but multiply their outputs by 0.5, which is a reasonable approximation to taking the <font color=orangered>geometric</font> mean of the predictive distributions produced by the exponentially-many dropout networks.<span style="font-size:80%;opacity:0.8">在测试时，我们使用所有的神经元但它们的输出乘以0.5，对指数级的许多失活网络的预测分布进行几何平均，这是一种合理的近似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 108 </td> <td> predictive<br>(1) </td> <td> [prɪˈdɪktɪv] </td> <td> 
<ul><li>At test time, we use all the neurons but multiply their outputs by 0.5, which is a reasonable approximation to taking the geometric mean of the <font color=orangered>predictive</font> distributions produced by the exponentially-many dropout networks.<span style="font-size:80%;opacity:0.8">在测试时，我们使用所有的神经元但它们的输出乘以0.5，对指数级的许多失活网络的预测分布进行几何平均，这是一种合理的近似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 109 </td> <td> exponentially-many<br>(1) </td> <td>  </td> <td> 
<ul><li>At test time, we use all the neurons but multiply their outputs by 0.5, which is a reasonable approximation to taking the geometric mean of the predictive distributions produced by the <font color=forestgreen>exponentially-many</font> dropout networks.<span style="font-size:80%;opacity:0.8">在测试时，我们使用所有的神经元但它们的输出乘以0.5，对指数级的许多失活网络的预测分布进行几何平均，这是一种合理的近似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 110 </td> <td> stochastic<br>(1) </td> <td> [stə'kæstɪk] </td> <td> 
<ul><li>We trained our models using <font color=orangered>stochastic</font> gradient descent with a batch size of 128 examples, momentum of 0.9, and weight decay of 0.0005.<span style="font-size:80%;opacity:0.8">我们使用随机梯度下降来训练我们的模型，样本的batch size为128，动量为0.9，权重衰减为0.0005。</span></li></ul>
 </td>
</tr>
<tr>
<td> 111 </td> <td> regularizer<br>(1) </td> <td>  </td> <td> 
<ul><li>In other words, weight decay here is not merely a <font color=forestgreen>regularizer</font>: it reduces the model’s training error.<span style="font-size:80%;opacity:0.8">换句话说，权重衰减不仅仅是一个正则项：它减少了模型的训练误差。</span></li></ul>
 </td>
</tr>
<tr>
<td> 112 </td> <td> derivative<br>(1) </td> <td> [dɪˈrɪvətɪv] </td> <td> 
<ul><li>where $i$ is the iteration index, $v$ is the momentum variable, $\varepsilon$ is the learning rate, and $\langle \frac{\partial L} {\partial w} |_{w_i}\rangle _{D_i}$ is the average over the ith batch $D_i$ of the <font color=orangered>derivative</font> of the objective with respect to $w$, evaluated at $w_i$.<span style="font-size:80%;opacity:0.8">$i$是迭代索引，$v$是动量变量，$\varepsilon$是学习率，$\langle \frac{\partial L} {\partial w} |_{w_i}\rangle _{D_i}$是目标函数对$w$，在$w_i$上的第$i$批微分$D_i$的平均。</span></li></ul>
 </td>
</tr>
<tr>
<td> 113 </td> <td> heuristic<br>(1) </td> <td> [hjuˈrɪstɪk] </td> <td> 
<ul><li>The <font color=orangered>heuristic</font> which we followed was to divide the learning rate by 10 when the validation error rate stopped improving with the current learning rate.<span style="font-size:80%;opacity:0.8">当验证误差在当前的学习率下停止提供时，我们遵循启发式的方法将学习率除以10。</span></li></ul>
 </td>
</tr>
<tr>
<td> 114 </td> <td> termination<br>(1) </td> <td> [ˌtɜ:mɪˈneɪʃn] </td> <td> 
<ul><li>The learning rate was initialized at 0.01 and reduced three times prior to <font color=orangered>termination</font>.<span style="font-size:80%;opacity:0.8">学习率初始化为0.01，在训练停止之前降低三次。</span></li></ul>
 </td>
</tr>
<tr>
<td> 115 </td> <td> NVIDIA<br>(1) </td> <td> [ɪn'vɪdɪə] </td> <td> 
<ul><li>We trained the network for roughly 90 cycles through the training set of 1.2 million images, which took five to six days on two <font color=orangered>NVIDIA</font> GTX 580 3GB GPUs.<span style="font-size:80%;opacity:0.8">我们在120万图像的训练数据集上训练神经网络大约90个循环，在两个NVIDIA GTX 580 3GB GPU上花费了五到六天。</span></li></ul>
 </td>
</tr>
<tr>
<td> 116 </td> <td> sparse-coding<br>(1) </td> <td>  </td> <td> 
<ul><li>The best performance achieved during the ILSVRC-2010 competition was 47.1% and 28.2% with an approach that averages the predictions produced from six <font color=forestgreen>sparse-coding</font> models trained on different features [2], and since then the best published results are 45.7% and 25.7% with an approach that averages the predictions of two classifiers trained on Fisher Vectors (FVs) computed from two types of densely-sampled features [24].<span style="font-size:80%;opacity:0.8">在ILSVRC-2010竞赛中最佳结果是top-1 47.1%，top-5 28.2%，使用的方法是对6个在不同特征上训练的稀疏编码模型生成的预测进行平均，从那时起已公布的最好结果是top-1 45.7%，top-5 25.7%，使用的方法是平均在Fisher向量（FV）上训练的两个分类器的预测结果，Fisher向量是通过两种密集采样特征计算得到的[24]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 117 </td> <td> interchangeably<br>(1) </td> <td> [ɪntəˈtʃeɪndʒəblɪ] </td> <td> 
<ul><li>In the remainder of this paragraph, we use validation and test error rates <font color=orangered>interchangeably</font> because in our experience they do not differ by more than 0.1% (see Table 2).<span style="font-size:80%;opacity:0.8">在这段的其余部分，我们会使用验证误差率和测试误差率互换，因为在我们的实验中它们的差别不会超过0.1%（看图2）。</span></li></ul>
 </td>
</tr>
<tr>
<td> 118 </td> <td> fine-tune<br>(1) </td> <td> [faɪn tju:n] </td> <td> 
<ul><li>Training one CNN, with an extra sixth convolutional layer over the last pooling layer, to classify the entire ImageNet Fall 2011 release (15M images, 22K categories), and then “<font color=orangered>fine-tuning</font>” it on ILSVRC-2012 gives an error rate of 16.6%.<span style="font-size:80%;opacity:0.8">为了对ImageNet 2011秋季发布的整个数据集（1500万图像，22000个类别）进行分类，我们在最后的池化层之后有一个额外的第6卷积层，训练了一个CNN，然后在它上面进行“fine-tuning”，在ILSVRC-2012取得了16.6%的错误率。</span></li></ul>
 </td>
</tr>
<tr>
<td> 119 </td> <td> asterisk<br>(1) </td> <td> [ˈæstərɪsk] </td> <td> 
<ul><li>Models with an <font color=orangered>asterisk</font> were “pre-trained” to classify the entire ImageNet 2011 Fall release.<span style="font-size:80%;opacity:0.8">带星号的是“预训练的”对ImageNet 2011秋季数据集进行分类的模型。</span></li></ul>
 </td>
</tr>
<tr>
<td> 120 </td> <td> convention<br>(1) </td> <td> [kənˈvenʃn] </td> <td> 
<ul><li>On this dataset we follow the <font color=orangered>convention</font> in the literature of using half of the images for training and half for testing.<span style="font-size:80%;opacity:0.8">在这个数据集上我们按照惯例用一半的图像来训练，一半的图像来测试。</span></li></ul>
 </td>
</tr>
<tr>
<td> 121 </td> <td> appreciably<br>(1) </td> <td> [ə'pri:ʃəblɪ] </td> <td> 
<ul><li>Since there is no established test set, our split necessarily differs from the splits used by previous authors, but this does not affect the results <font color=orangered>appreciably</font>.<span style="font-size:80%;opacity:0.8">由于没有建立测试集，我们的数据集分割有必要不同于以前作者的数据集分割，但这对结果没有明显的影响。</span></li></ul>
 </td>
</tr>
<tr>
<td> 122 </td> <td> Qualitative<br>(1) </td> <td> [ˈkwɒlɪtətɪv] </td> <td> 
<ul><li>6.1 <font color=orangered>Qualitative</font> Evaluations<span style="font-size:80%;opacity:0.8">6.1 定性评估</span></li></ul>
 </td>
</tr>
<tr>
<td> 123 </td> <td> data-connected<br>(1) </td> <td>  </td> <td> 
<ul><li>Figure 3 shows the convolutional kernels learned by the network’s two <font color=forestgreen>data-connected</font> layers.<span style="font-size:80%;opacity:0.8">图3显示了网络的两个数据连接层学习到的卷积核。</span></li></ul>
 </td>
</tr>
<tr>
<td> 124 </td> <td> orientation-selective<br>(1) </td> <td>  </td> <td> 
<ul><li>The network has learned a variety of frequency and <font color=forestgreen>orientation-selective</font> kernels, as well as various colored blobs.<span style="font-size:80%;opacity:0.8">网络学习到了大量的频率核、方向选择核，也学到了各种颜色点。</span></li></ul>
 </td>
</tr>
<tr>
<td> 125 </td> <td> blob<br>(1) </td> <td> [blɒb] </td> <td> 
<ul><li>The network has learned a variety of frequency and orientation-selective kernels, as well as various colored <font color=orangered>blobs</font>.<span style="font-size:80%;opacity:0.8">网络学习到了大量的频率核、方向选择核，也学到了各种颜色点。</span></li></ul>
 </td>
</tr>
<tr>
<td> 126 </td> <td> color-agnostic<br>(1) </td> <td>  </td> <td> 
<ul><li>The kernels on GPU 1 are largely <font color=forestgreen>color-agnostic</font>, while the kernels on on GPU 2 are largely color-specific.<span style="font-size:80%;opacity:0.8">GPU 1上的核主要是没有颜色的，而GPU 2上的核主要是针对颜色的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 127 </td> <td> color-specific<br>(1) </td> <td>  </td> <td> 
<ul><li>The kernels on GPU 1 are largely color-agnostic, while the kernels on on GPU 2 are largely <font color=forestgreen>color-specific</font>.<span style="font-size:80%;opacity:0.8">GPU 1上的核主要是没有颜色的，而GPU 2上的核主要是针对颜色的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 128 </td> <td> modulo<br>(1) </td> <td> ['mɒdjʊləʊ] </td> <td> 
<ul><li>This kind of specialization occurs during every run and is independent of any particular random weight initialization (<font color=orangered>modulo</font> a renumbering of the GPUs).<span style="font-size:80%;opacity:0.8">这种专业化在每次运行时都会发生，并且是与任何特别的随机权重初始化（以GPU的重新编号为模）无关的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 129 </td> <td> renumber<br>(1) </td> <td> ['ri:'nʌmbə] </td> <td> 
<ul><li>This kind of specialization occurs during every run and is independent of any particular random weight initialization (modulo a <font color=orangered>renumbering</font> of the GPUs).<span style="font-size:80%;opacity:0.8">这种专业化在每次运行时都会发生，并且是与任何特别的随机权重初始化（以GPU的重新编号为模）无关的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 130 </td> <td> qualitatively<br>(1) </td> <td> ['kwɒlɪtətɪvlɪ] </td> <td> 
<ul><li>In the left panel of Figure 4 we <font color=orangered>qualitatively</font> assess what the network has learned by computing its top-5 predictions on eight test images.<span style="font-size:80%;opacity:0.8">在图4的左边部分，我们通过在8张测试图像上计算它的top-5预测定性地评估了网络学习到的东西。</span></li></ul>
 </td>
</tr>
<tr>
<td> 131 </td> <td> off-center<br>(1) </td> <td> ['ɔ:fs'entə] </td> <td> 
<ul><li>Notice that even <font color=orangered>off-center</font> objects, such as the mite in the top-left, can be recognized by the net.<span style="font-size:80%;opacity:0.8">注意即使是不在图像中心的目标也能被网络识别，例如左上角的小虫。</span></li></ul>
 </td>
</tr>
<tr>
<td> 132 </td> <td> mite<br>(1) </td> <td> [maɪt] </td> <td> 
<ul><li>Notice that even off-center objects, such as the <font color=orangered>mite</font> in the top-left, can be recognized by the net.<span style="font-size:80%;opacity:0.8">注意即使是不在图像中心的目标也能被网络识别，例如左上角的小虫。</span></li></ul>
 </td>
</tr>
<tr>
<td> 133 </td> <td> top-left<br>(1) </td> <td>  </td> <td> 
<ul><li>Notice that even off-center objects, such as the mite in the <font color=forestgreen>top-left</font>, can be recognized by the net.<span style="font-size:80%;opacity:0.8">注意即使是不在图像中心的目标也能被网络识别，例如左上角的小虫。</span></li></ul>
 </td>
</tr>
<tr>
<td> 134 </td> <td> plausible<br>(1) </td> <td> [ˈplɔ:zəbl] </td> <td> 
<ul><li>For example, only other types of cat are considered <font color=orangered>plausible</font> labels for the leopard.<span style="font-size:80%;opacity:0.8">例如，对于美洲豹来说，只有其它类型的猫被认为是看似合理的标签。</span></li></ul>
 </td>
</tr>
<tr>
<td> 135 </td> <td> leopard<br>(1) </td> <td> [ˈlepəd] </td> <td> 
<ul><li>For example, only other types of cat are considered plausible labels for the <font color=orangered>leopard</font>.<span style="font-size:80%;opacity:0.8">例如，对于美洲豹来说，只有其它类型的猫被认为是看似合理的标签。</span></li></ul>
 </td>
</tr>
<tr>
<td> 136 </td> <td> grille<br>(1) </td> <td> [ɡrɪl] </td> <td> 
<ul><li>In some cases (<font color=orangered>grille</font>, cherry) there is genuine ambiguity about the intended focus of the photograph.<span style="font-size:80%;opacity:0.8">在某些案例（格栅，樱桃）中，网络在意的图片焦点真的很含糊。</span></li></ul>
 </td>
</tr>
<tr>
<td> 137 </td> <td> probe<br>(1) </td> <td> [prəʊb] </td> <td> 
<ul><li>Another way to <font color=orangered>probe</font> the network’s visual knowledge is to consider the feature activations induced by an image at the last, 4096-dimensional hidden layer.<span style="font-size:80%;opacity:0.8">探索网络可视化知识的另一种方式是思考最后的4096维隐藏层在图像上得到的特征激活。</span></li></ul>
 </td>
</tr>
<tr>
<td> 138 </td> <td> activations<br>(1) </td> <td> [,æktɪ'veɪʃən] </td> <td> 
<ul><li>Another way to probe the network’s visual knowledge is to consider the feature <font color=orangered>activations</font> induced by an image at the last, 4096-dimensional hidden layer.<span style="font-size:80%;opacity:0.8">探索网络可视化知识的另一种方式是思考最后的4096维隐藏层在图像上得到的特征激活。</span></li></ul>
 </td>
</tr>
<tr>
<td> 139 </td> <td> induce<br>(1) </td> <td> [ɪnˈdju:s] </td> <td> 
<ul><li>Another way to probe the network’s visual knowledge is to consider the feature activations <font color=orangered>induced</font> by an image at the last, 4096-dimensional hidden layer.<span style="font-size:80%;opacity:0.8">探索网络可视化知识的另一种方式是思考最后的4096维隐藏层在图像上得到的特征激活。</span></li></ul>
 </td>
</tr>
<tr>
<td> 140 </td> <td> activation<br>(1) </td> <td> [ˌæktɪ'veɪʃn] </td> <td> 
<ul><li>If two images produce feature <font color=orangered>activation</font> vectors with a small Euclidean separation, we can say that the higher levels of the neural network consider them to be similar.<span style="font-size:80%;opacity:0.8">如果两幅图像生成的特征激活向量之间有较小的欧式距离，我们可以认为神经网络的更高层特征认为它们是相似的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 141 </td> <td> supplementary<br>(1) </td> <td> [ˌsʌplɪˈmentri] </td> <td> 
<ul><li>We present the results for many more test images in the <font color=orangered>supplementary</font> material.<span style="font-size:80%;opacity:0.8">我们在补充材料中对更多的测试图像呈现了这种结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 142 </td> <td> real-valued<br>(1) </td> <td> ['reɪɑ:lv'ælju:d] </td> <td> 
<ul><li>Computing similarity by using Euclidean distance between two 4096-dimensional, <font color=orangered>real-valued</font> vectors is inefficient, but it could be made efficient by training an auto-encoder to compress these vectors to short binary codes.<span style="font-size:80%;opacity:0.8">通过两个4096维实值向量间的欧氏距离来计算相似性是效率低下的，但通过训练一个自动编码器将这些向量压缩为短二值编码可以使其变得高效。</span></li></ul>
 </td>
</tr>
<tr>
<td> 143 </td> <td> auto-encoder<br>(1) </td> <td>  </td> <td> 
<ul><li>Computing similarity by using Euclidean distance between two 4096-dimensional, real-valued vectors is inefficient, but it could be made efficient by training an <font color=forestgreen>auto-encoder</font> to compress these vectors to short binary codes.<span style="font-size:80%;opacity:0.8">通过两个4096维实值向量间的欧氏距离来计算相似性是效率低下的，但通过训练一个自动编码器将这些向量压缩为短二值编码可以使其变得高效。</span></li></ul>
 </td>
</tr>
<tr>
<td> 144 </td> <td> retrieval<br>(1) </td> <td> [rɪˈtri:vl] </td> <td> 
<ul><li>This should produce a much better image <font color=orangered>retrieval</font> method than applying auto-encoders to the raw pixels [14], which does not make use of image labels and hence has a tendency to retrieve images with similar patterns of edges, whether or not they are semantically similar.<span style="font-size:80%;opacity:0.8">这应该会产生一种比将自动编码器应用到原始像素上[14]更好的图像检索方法，自动编码器应用到原始像素上的方法没有使用图像标签，因此会趋向于检索与要检索的图像具有相似边缘模式的图像，无论它们是否是语义上相似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 145 </td> <td> auto-encoders<br>(1) </td> <td>  </td> <td> 
<ul><li>This should produce a much better image retrieval method than applying <font color=forestgreen>auto-encoders</font> to the raw pixels [14], which does not make use of image labels and hence has a tendency to retrieve images with similar patterns of edges, whether or not they are semantically similar.<span style="font-size:80%;opacity:0.8">这应该会产生一种比将自动编码器应用到原始像素上[14]更好的图像检索方法，自动编码器应用到原始像素上的方法没有使用图像标签，因此会趋向于检索与要检索的图像具有相似边缘模式的图像，无论它们是否是语义上相似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 146 </td> <td> semantically<br>(1) </td> <td> [sɪ'mæntɪklɪ] </td> <td> 
<ul><li>This should produce a much better image retrieval method than applying auto-encoders to the raw pixels [14], which does not make use of image labels and hence has a tendency to retrieve images with similar patterns of edges, whether or not they are <font color=orangered>semantically</font> similar.<span style="font-size:80%;opacity:0.8">这应该会产生一种比将自动编码器应用到原始像素上[14]更好的图像检索方法，自动编码器应用到原始像素上的方法没有使用图像标签，因此会趋向于检索与要检索的图像具有相似边缘模式的图像，无论它们是否是语义上相似。</span></li></ul>
 </td>
</tr>
<tr>
<td> 147 </td> <td> record-breaking<br>(1) </td> <td> ['rekɔ:d,breikiŋ, 'rekəd-] </td> <td> 
<ul><li>Our results show that a large, deep convolutional neural network is capable of achieving <font color=orangered>record-breaking</font> results on a highly challenging dataset using purely supervised learning.<span style="font-size:80%;opacity:0.8">我们的结果表明一个大型深度卷积神经网络在一个具有高度挑战性的数据集上使用纯有监督学习可以取得破纪录的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 148 </td> <td> unsupervised<br>(1) </td> <td> [ˌʌn'sju:pəvaɪzd] </td> <td> 
<ul><li>To simplify our experiments, we did not use any <font color=orangered>unsupervised</font> pre-training even though we expect that it will help, especially if we obtain enough computational power to significantly increase the size of the network without obtaining a corresponding increase in the amount of labeled data.<span style="font-size:80%;opacity:0.8">为了简化我们的实验，我们没有使用任何无监督的预训练，尽管我们希望它会有所帮助，特别是在如果我们能获得足够的计算能力来显著增加网络的大小而标注的数据量没有对应增加的情况下。</span></li></ul>
 </td>
</tr>
<tr>
<td> 149 </td> <td> computational<br>(1) </td> <td> [ˌkɒmpjuˈteɪʃənl] </td> <td> 
<ul><li>To simplify our experiments, we did not use any unsupervised pre-training even though we expect that it will help, especially if we obtain enough <font color=orangered>computational</font> power to significantly increase the size of the network without obtaining a corresponding increase in the amount of labeled data.<span style="font-size:80%;opacity:0.8">为了简化我们的实验，我们没有使用任何无监督的预训练，尽管我们希望它会有所帮助，特别是在如果我们能获得足够的计算能力来显著增加网络的大小而标注的数据量没有对应增加的情况下。</span></li></ul>
 </td>
</tr>
<tr>
<td> 150 </td> <td> infero-temporal<br>(1) </td> <td>  </td> <td> 
<ul><li>Thus far, our results have improved as we have made our network larger and trained it longer but we still have many orders of magnitude to go in order to match the <font color=forestgreen>infero-temporal</font> pathway of the human visual system.<span style="font-size:80%;opacity:0.8">到目前为止，我们的结果已经提高了，因为我们的网络更大、训练时间更长，但为了匹配人类视觉系统的下颞线（视觉专业术语）我们仍然有许多数量级要达到。</span></li></ul>
 </td>
</tr>
<tr>
<td> 151 </td> <td> pathway<br>(1) </td> <td> [ˈpɑ:θweɪ] </td> <td> 
<ul><li>Thus far, our results have improved as we have made our network larger and trained it longer but we still have many orders of magnitude to go in order to match the infero-temporal <font color=orangered>pathway</font> of the human visual system.<span style="font-size:80%;opacity:0.8">到目前为止，我们的结果已经提高了，因为我们的网络更大、训练时间更长，但为了匹配人类视觉系统的下颞线（视觉专业术语）我们仍然有许多数量级要达到。</span></li></ul>
 </td>
</tr>
<tr>
<td> 152 </td> <td> static<br>(1) </td> <td> [ˈstætɪk] </td> <td> 
<ul><li>Ultimately we would like to use very large and deep convolutional nets on video sequences where the temporal structure provides very helpful information that is missing or far less obvious in <font color=orangered>static</font> images.<span style="font-size:80%;opacity:0.8">最后我们想在视频序列上使用非常大的深度卷积网络，视频序列的时序结构会提供非常有帮助的信息，这些信息在静态图像上是缺失的或远不那么明显。</span></li></ul>
 </td>
</tr>
</table>
</div>
</div>
</div>
</body>
</html>