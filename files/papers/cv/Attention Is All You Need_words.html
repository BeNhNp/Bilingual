<html>
<head>
<meta charset="utf-8">
<title> Attention Is All You Need </title>
<style type="text/css">
.inline-ul { font-size:0;}
.inline-ul ul li{ font-size: 12px; letter-spacing: normal; word-spacing: normal;
vertical-align:top; display: inline-block; *display:inline; *zoom:1;}
.inline-ul{ letter-spacing:-5px; }
.widget-title { font-size: 13px; font-weight: normal; color: #888888; padding: 20px 20px 0px; }
.widget-tab .widget-title{font-size: 0;}
.widget-tab .widget-title ul li{margin-left:3%;width:40%;text-align:center;margin-right:2%;padding:4px 1%;}
.widget-tab .widget-title ul li:hover{background:#F7F7F7}
.widget-tab .widget-title label{cursor:pointer;display:block; font-size: 0.8em;}
.widget-tab .widget-title ul li.active{background:#F0F0F0}
.widget-tab input{display:none}
.widget-tab .widget-box div{display:none}
#one:checked ~ .widget-title .one,#two:checked ~ .widget-title .two{background:#F7F7F7}
#one:checked ~ .widget-box .one-list,#two:checked ~ .widget-box .two-list{display:block}

body {font-family: arial,verdana,geneva,sans-serif; font-size: 1.25em; color: #000; word-wrap:break-word;}
table { border-collapse: collapse; margin: 0 auto; }
table td, table th { border: 1px solid #cad9ea; height: 30px; }
table thead th, table thead td { background-color: #CCE8EB; text-align: center; }
table tr:nth-child(odd) { background: #fff; }
table tr:nth-child(even) { background: #F5FAFA; }
table tr td:not(:last-child){ text-align: center; }
</style>
</head>
<body>
<div class="widget-tab">
<input type="radio" name="widget-tab" id="one" checked="checked"/>
<input type="radio" name="widget-tab" id="two"/>
<div class="widget-title inline-ul">
    <ul> <li class="one"> <label for="one">In order of appearance</label> </li>
        <li class="two"> <label for="two">In order of frequency</label> </li>
    </ul>
</div>
<div class="widget-box">
<div class="one-list">
<table>
<caption>
    <h2> Words List (appearance)</h2>
</caption>
<thead>
<tr>
<td> # </td> <td> word </td> <td> phonetic </td> <td> sentence </td>
</tr>
</thead>
<tr>
<td> 1 </td> <td> nip </td> <td> [nɪp] </td> <td> 
<ul><li>31st Conference on Neural Information Processing Systems (<font color=orangered>NIPS</font> 2017), Long Beach, CA, USA.<span style="font-size:80%;opacity:0.8"> 第31届神经网络信息处理系统会议（NIPS 2017），美国加州长滩市。</span></li></ul>
 </td>
</tr>
<tr>
<td> 2 </td> <td> CA </td> <td> [!≈ si: eɪ] </td> <td> 
<ul><li>31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, <font color=orangered>CA</font>, USA.<span style="font-size:80%;opacity:0.8"> 第31届神经网络信息处理系统会议（NIPS 2017），美国加州长滩市。</span></li></ul>
 </td>
</tr>
<tr>
<td> 3 </td> <td> USA </td> <td> [ju: es 'ei] </td> <td> 
<ul><li>31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, CA, <font color=orangered>USA</font>.<span style="font-size:80%;opacity:0.8"> 第31届神经网络信息处理系统会议（NIPS 2017），美国加州长滩市。</span></li></ul>
 </td>
</tr>
<tr>
<td> 4 </td> <td> Jakob </td> <td>  </td> <td> 
<ul><li><font color=forestgreen>Jakob</font> proposed replacing RNNs with self-attention and started the effort to evaluate this idea.<span style="font-size:80%;opacity:0.8">  Jakob提出用self-attention替换RNN并开始努力验证这个想法。</span></li></ul>
 </td>
</tr>
<tr>
<td> 5 </td> <td> Ashish </td> <td>  </td> <td> 
<ul><li><font color=forestgreen>Ashish</font>, with Illia, designed and implemented the first Transformer models and has been crucially involved in every aspect of this work.<span style="font-size:80%;opacity:0.8">  Ashish和Illia设计并实现第一个Transformer模型，并在这项工作中的各个方面起着至关重要的作用。</span></li></ul>
 </td>
</tr>
<tr>
<td> 6 </td> <td> Illia </td> <td>  </td> <td> 
<ul><li>Ashish, with <font color=forestgreen>Illia</font>, designed and implemented the first Transformer models and has been crucially involved in every aspect of this work.<span style="font-size:80%;opacity:0.8">  Ashish和Illia设计并实现第一个Transformer模型，并在这项工作中的各个方面起着至关重要的作用。</span></li></ul>
 </td>
</tr>
<tr>
<td> 7 </td> <td> transformer </td> <td> [trænsˈfɔ:mə(r)] </td> <td> 
<ul><li>Ashish, with Illia, designed and implemented the first <font color=orangered>Transformer</font> models and has been crucially involved in every aspect of this work.<span style="font-size:80%;opacity:0.8">  Ashish和Illia设计并实现第一个Transformer模型，并在这项工作中的各个方面起着至关重要的作用。</span></li><li>We propose a new simple network architecture, the <font color=orangered>Transformer</font>, based solely on attention mechanisms, dispensing with recurrence and convolutions entirely.<span style="font-size:80%;opacity:0.8">  我们提出一种新的简单的网络架构Transformer，仅基于attention机制并完全避免循环和卷积。</span></li><li>We show that the <font color=orangered>Transformer</font> generalizes well to other tasks by applying it successfully to English constituency parsing both with large and limited training data.<span style="font-size:80%;opacity:0.8">  通过在解析大量训练数据和有限训练数据的两种情况下将其应用到English constituency，我们表明Transformer可以很好地推广到其他任务。</span></li><li>In this work we propose the <font color=orangered>Transformer</font>, a model architecture eschewing recurrence and instead relying entirely on an attention mechanism to draw global dependencies between input and output.<span style="font-size:80%;opacity:0.8"> 在这项工作中我们提出Transformer，这种模型架构避免循环并完全依赖于attention机制来绘制输入和输出之间的全局依赖关系。</span></li><li>The <font color=orangered>Transformer</font> allows for significantly more parallelization and can reach a new state of the art in translation quality after being trained for as little as twelve hours on eight P100 GPUs.<span style="font-size:80%;opacity:0.8">  Transformer允许进行更多的并行化，并且可以在八个P100 GPU上接受少至十二小时的训练后达到翻译质量的新的最佳结果。</span></li><li>In the <font color=orangered>Transformer</font> this is reduced to a constant number of operations, albeit at the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we counteract with Multi-Head Attention as described in section 3.2.<span style="font-size:80%;opacity:0.8">  在Transformer中，这种操作减少到固定的次数，尽管由于对用attention权重化的位置取平均降低了效果，但是我使用Multi-Head Attention进行抵消，具体描述见 3.2。</span></li><li>To the best of our knowledge, however, the <font color=orangered>Transformer</font> is the first transduction model relying entirely on self-attention to compute representations of its input and output without using sequence-aligned RNNs or convolution.<span style="font-size:80%;opacity:0.8"> 然而，就我们所知，Transformer是第一个完全依靠self-attention来计算输入和输出表示而不使用序列对齐RNN或卷积的转导模型。</span></li><li>In the following sections, we will describe the <font color=orangered>Transformer</font>, motivate self-attention and discuss its advantages over models such as [17, 18] and [9].<span style="font-size:80%;opacity:0.8">  在下面的章节中，我们将描述Transformer、引出self-attention并讨论它相对[17, 18]和[9]几个模型的优势。</span></li><li>Figure 1: The <font color=orangered>Transformer</font> - model architecture.<span style="font-size:80%;opacity:0.8"> 图1： Transformer — 模型架构。</span></li><li>The <font color=orangered>Transformer</font> follows this overall architecture using stacked self-attention and point-wise, fully connected layers for both the encoder and decoder, shown in the left and right halves of Figure 1, respectively.<span style="font-size:80%;opacity:0.8"> Transformer遵循这种整体架构，编码器和解码器都使用self-attention堆叠和point-wise、完全连接的层，分别显示在图1的左边和右边。</span></li><li>The <font color=orangered>Transformer</font> uses multi-head attention in three different ways:<span style="font-size:80%;opacity:0.8"> Transformer使用以3种方式使用multi-head attention：</span></li><li>Table 2: The <font color=orangered>Transformer</font> achieves better BLEU scores than previous state-of-the-art models on the English-to-German and English-to-French newstest2014 tests at a fraction of the training cost.<span style="font-size:80%;opacity:0.8"> 表2： Transformer在英语-德语和英语-法语newstest2014测试中获得的BLEU分数比以前的最新模型的分数更好，且训练成本只是它们的一小部分。</span></li><li>On the WMT 2014 English-to-German translation task, the big <font color=orangered>transformer</font> model (Transformer (big) in Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0 BLEU, establishing a new state-of-the-art BLEU score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 P100 GPUs.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>On the WMT 2014 English-to-German translation task, the big transformer model (<font color=orangered>Transformer</font> (big) in Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0 BLEU, establishing a new state-of-the-art BLEU score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 P100 GPUs.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>The <font color=orangered>Transformer</font> (big) model trained for English-to-French used dropout rate Pdrop = 0.1, instead of 0.3.<span style="font-size:80%;opacity:0.8">  英语-法语的Transformer (big) 模型使用丢弃率为Pdrop = 0.1，而不是0.3。</span></li><li>Table 3: Variations on the <font color=orangered>Transformer</font> architecture.<span style="font-size:80%;opacity:0.8"> 表3： Transformer架构的变体。</span></li><li>To evaluate the importance of different components of the <font color=orangered>Transformer</font>, we varied our base model in different ways, measuring the change in performance on English-to-German translation on the development set, newstest2013.<span style="font-size:80%;opacity:0.8"> 为了评估Transformer不同组件的重要性，我们以不同的方式改变我们的基础模型，测量开发集newstest2013上英文-德文翻译的性能变化。</span></li><li>Table 4: The <font color=orangered>Transformer</font> generalizes well to English constituency parsing (Results are on Section 23 of WSJ)<span style="font-size:80%;opacity:0.8"> 表4： The Transformer generalizes well to English constituency parsing (Results are on Section 23 of WSJ)</span></li><li>To evaluate if the <font color=orangered>Transformer</font> can generalize to other tasks we performed experiments on English constituency parsing. This task presents specific challenges: the output is subject to strong structural constraints and is significantly longer than the input.<span style="font-size:80%;opacity:0.8"> To evaluate if the Transformer can generalize to other tasks we performed experiments on English constituency parsing. 这项任务提出特别的挑战：输出受到很强的结构性约束，并且比输入要长很多。</span></li><li>We trained a 4-layer <font color=orangered>transformer</font> with dmodel = 1024 on the Wall Street Journal (WSJ) portion of the Penn Treebank [25], about 40K training sentences.<span style="font-size:80%;opacity:0.8"> 我们用dmodel = 1024 在Penn Treebank[25]的Wall Street Journal（WSJ）部分训练了一个4层transformer，约40K个训练句子。</span></li><li>In contrast to RNN sequence-to-sequence models [37], the <font color=orangered>Transformer</font> outperforms the BerkeleyParser [29] even when training only on the WSJ training set of 40K sentences.<span style="font-size:80%;opacity:0.8"> 与RNN序列到序列模型[37]相比，即使仅在WSJ训练40K句子组训练时，Transformer也胜过BerkeleyParser [29]。</span></li><li>In this work, we presented the <font color=orangered>Transformer</font>, the first sequence transduction model based entirely on attention, replacing the recurrent layers most commonly used in encoder-decoder architectures with multi-headed self-attention.<span style="font-size:80%;opacity:0.8"> 在这项工作中，我们提出了Transformer，第一个完全基于关注的序列转导模型，用multi-headed self-attention取代了编码器-解码器架构中最常用的循环层。</span></li><li>For translation tasks, the <font color=orangered>Transformer</font> can be trained significantly faster than architectures based on recurrent or convolutional layers.<span style="font-size:80%;opacity:0.8"> 对于翻译任务，Transformer可以比基于循环或卷积层的体系结构训练更快。</span></li><li>We plan to extend the <font color=orangered>Transformer</font> to problems involving input and output modalities other than text and to investigate local, restricted attention mechanisms to efficiently handle large inputs and outputs such as images, audio and video.<span style="font-size:80%;opacity:0.8">  我们计划将Transformer扩展到除文本之外的涉及输入和输出模式的问题，并调查局部的、受限attention机制以有效处理大型输入和输出，如图像、音频和视频。</span></li></ul>
 </td>
</tr>
<tr>
<td> 8 </td> <td> crucially </td> <td> [ˈkru:ʃɪəlɪ] </td> <td> 
<ul><li>Ashish, with Illia, designed and implemented the first Transformer models and has been <font color=orangered>crucially</font> involved in every aspect of this work.<span style="font-size:80%;opacity:0.8">  Ashish和Illia设计并实现第一个Transformer模型，并在这项工作中的各个方面起着至关重要的作用。</span></li></ul>
 </td>
</tr>
<tr>
<td> 9 </td> <td> Noam </td> <td> [ˈnəuəm] </td> <td> 
<ul><li><font color=orangered>Noam</font> proposed scaled dot-product attention, multi-head attention and the parameter-free position representation and became the other person involved in nearly every detail.<span style="font-size:80%;opacity:0.8">  Noam提出缩放版的点积attention、multi-head attention和与参数无关的位置表示，并成为在几乎每个细节中都涉及的另外一个人。</span></li></ul>
 </td>
</tr>
<tr>
<td> 10 </td> <td> dot-product </td> <td> [!≈ dɒt ˈprɒdʌkt] </td> <td> 
<ul><li>Noam proposed scaled <font color=orangered>dot-product</font> attention, multi-head attention and the parameter-free position representation and became the other person involved in nearly every detail.<span style="font-size:80%;opacity:0.8">  Noam提出缩放版的点积attention、multi-head attention和与参数无关的位置表示，并成为在几乎每个细节中都涉及的另外一个人。</span></li><li>3.2.1 Scaled <font color=orangered>Dot-Product</font> Attention<span style="font-size:80%;opacity:0.8"> 3.2.1 缩放版的点积attention</span></li><li>We call our particular attention &quot;Scaled <font color=orangered>Dot-Product</font> Attention&quot; (Figure 2).<span style="font-size:80%;opacity:0.8"> 我们称我们特殊的attention为“缩放版的点积attention”（图 2）。</span></li><li>The two most commonly used attention functions are additive attention [2], and <font color=orangered>dot-product</font> (multiplicative) attention.<span style="font-size:80%;opacity:0.8"> 两个最常用的attention函数是加法attention[2]和点积（乘法）attention。</span></li><li><font color=orangered>Dot-product</font> attention is identical to our algorithm, except for the scaling factor of $\frac 1 {\sqrt{d_k}}$.<span style="font-size:80%;opacity:0.8">  除了缩放因子$\frac 1 {\sqrt{d_k}}$之外，点积attention与我们的算法相同。</span></li><li>While the two are similar in theoretical complexity, <font color=orangered>dot-product</font> attention is much faster and more space-efficient in practice, since it can be implemented using highly optimized matrix multiplication code.<span style="font-size:80%;opacity:0.8">  虽然两者在理论上的复杂性相似，但在实践中点积attention的速度更快、更节省空间，因为它可以使用高度优化的矩阵乘法代码来实现。</span></li><li>Figure 2: (left) Scaled <font color=orangered>Dot-Product</font> Attention.<span style="font-size:80%;opacity:0.8"> 图2： （左）缩放版的点积attention。</span></li><li>We implement this inside of scaled <font color=orangered>dot-product</font> attention by masking out (setting to -∞) all values in the input of the softmax which correspond to illegal connections.<span style="font-size:80%;opacity:0.8">  通过屏蔽softmax的输入中所有不合法连接的值（设置为-∞），我们在缩放版的点积attention中实现。</span></li></ul>
 </td>
</tr>
<tr>
<td> 11 </td> <td> Niki </td> <td>  </td> <td> 
<ul><li><font color=forestgreen>Niki</font> designed, implemented, tuned and evaluated countless model variants in our original codebase and tensor2tensor.<span style="font-size:80%;opacity:0.8">  Niki在我们最初的代码库和tensor2tensor中设计、实现、调优和评估了无数的模型变体。</span></li></ul>
 </td>
</tr>
<tr>
<td> 12 </td> <td> variant </td> <td> [ˈveəriənt] </td> <td> 
<ul><li>Niki designed, implemented, tuned and evaluated countless model <font color=orangered>variants</font> in our original codebase and tensor2tensor.<span style="font-size:80%;opacity:0.8">  Niki在我们最初的代码库和tensor2tensor中设计、实现、调优和评估了无数的模型变体。</span></li><li>Llion also experimented with novel model <font color=orangered>variants</font>, was responsible for our initial codebase, and efficient inference and visualizations.<span style="font-size:80%;opacity:0.8">  Llion还尝试了新的模型变体，负责我们的初始代码库，以及高效的推断和可视化。</span></li></ul>
 </td>
</tr>
<tr>
<td> 13 </td> <td> codebase </td> <td>  </td> <td> 
<ul><li>Niki designed, implemented, tuned and evaluated countless model variants in our original <font color=forestgreen>codebase</font> and tensor2tensor.<span style="font-size:80%;opacity:0.8">  Niki在我们最初的代码库和tensor2tensor中设计、实现、调优和评估了无数的模型变体。</span></li><li>Llion also experimented with novel model variants, was responsible for our initial <font color=forestgreen>codebase</font>, and efficient inference and visualizations.<span style="font-size:80%;opacity:0.8">  Llion还尝试了新的模型变体，负责我们的初始代码库，以及高效的推断和可视化。</span></li><li>Lukasz and Aidan spent countless long days designing various parts of and implementing tensor2tensor, replacing our earlier <font color=forestgreen>codebase</font>, greatly improving results and massively accelerating our research.<span style="font-size:80%;opacity:0.8">  Lukasz和Aidan花费了无数的时间来设计tensor2tensor的各个部分，取代了我们之前的代码库，极大地改进了结果并大大加快了我们的研究。 </span></li></ul>
 </td>
</tr>
<tr>
<td> 14 </td> <td> tensor2tensor </td> <td>  </td> <td> 
<ul><li>Niki designed, implemented, tuned and evaluated countless model variants in our original codebase and <font color=forestgreen>tensor2tensor</font>.<span style="font-size:80%;opacity:0.8">  Niki在我们最初的代码库和tensor2tensor中设计、实现、调优和评估了无数的模型变体。</span></li><li>Lukasz and Aidan spent countless long days designing various parts of and implementing <font color=forestgreen>tensor2tensor</font>, replacing our earlier codebase, greatly improving results and massively accelerating our research.<span style="font-size:80%;opacity:0.8">  Lukasz和Aidan花费了无数的时间来设计tensor2tensor的各个部分，取代了我们之前的代码库，极大地改进了结果并大大加快了我们的研究。 </span></li></ul>
 </td>
</tr>
<tr>
<td> 15 </td> <td> Llion </td> <td>  </td> <td> 
<ul><li><font color=forestgreen>Llion</font> also experimented with novel model variants, was responsible for our initial codebase, and efficient inference and visualizations.<span style="font-size:80%;opacity:0.8">  Llion还尝试了新的模型变体，负责我们的初始代码库，以及高效的推断和可视化。</span></li></ul>
 </td>
</tr>
<tr>
<td> 16 </td> <td> visualization </td> <td> [ˌvɪʒʊəlaɪ'zeɪʃn] </td> <td> 
<ul><li>Llion also experimented with novel model variants, was responsible for our initial codebase, and efficient inference and <font color=orangered>visualizations</font>.<span style="font-size:80%;opacity:0.8">  Llion还尝试了新的模型变体，负责我们的初始代码库，以及高效的推断和可视化。</span></li></ul>
 </td>
</tr>
<tr>
<td> 17 </td> <td> Lukasz </td> <td>  </td> <td> 
<ul><li><font color=forestgreen>Lukasz</font> and Aidan spent countless long days designing various parts of and implementing tensor2tensor, replacing our earlier codebase, greatly improving results and massively accelerating our research.<span style="font-size:80%;opacity:0.8">  Lukasz和Aidan花费了无数的时间来设计tensor2tensor的各个部分，取代了我们之前的代码库，极大地改进了结果并大大加快了我们的研究。 </span></li></ul>
 </td>
</tr>
<tr>
<td> 18 </td> <td> Aidan </td> <td>  </td> <td> 
<ul><li>Lukasz and <font color=forestgreen>Aidan</font> spent countless long days designing various parts of and implementing tensor2tensor, replacing our earlier codebase, greatly improving results and massively accelerating our research.<span style="font-size:80%;opacity:0.8">  Lukasz和Aidan花费了无数的时间来设计tensor2tensor的各个部分，取代了我们之前的代码库，极大地改进了结果并大大加快了我们的研究。 </span></li></ul>
 </td>
</tr>
<tr>
<td> 19 </td> <td> massively </td> <td> ['mæsɪvlɪ] </td> <td> 
<ul><li>Lukasz and Aidan spent countless long days designing various parts of and implementing tensor2tensor, replacing our earlier codebase, greatly improving results and <font color=orangered>massively</font> accelerating our research.<span style="font-size:80%;opacity:0.8">  Lukasz和Aidan花费了无数的时间来设计tensor2tensor的各个部分，取代了我们之前的代码库，极大地改进了结果并大大加快了我们的研究。 </span></li></ul>
 </td>
</tr>
<tr>
<td> 20 </td> <td> transduction </td> <td> [træns'dʌkʃən] </td> <td> 
<ul><li>The dominant sequence <font color=orangered>transduction</font> models are based on complex recurrent or convolutional neural networks that include an encoder and a decoder.<span style="font-size:80%;opacity:0.8"> 主流序列转导模型基于复杂的循环神经网络或卷积神经网络，这些神经网络包含一个编码器和一个解码器。</span></li><li>Recurrent neural networks, long short-term memory [13] and gated recurrent [7] neural networks in particular, have been firmly established as state of the art approaches in sequence modeling and <font color=orangered>transduction</font> problems such as language modeling and machine translation [35, 2, 5].<span style="font-size:80%;opacity:0.8"> 在序列建模和转换问题中，如语言建模和机器翻译[35, 2, 5]，循环神经网络特别是长短期记忆[13]和门控循环[7]神经网络，已经被确立为最先进的方法。</span></li><li>Attention mechanisms have become an integral part of compelling sequence modeling and <font color=orangered>transduction</font> models in various tasks, allowing modeling of dependencies without regard to their distance in the input or output sequences [2, 19].<span style="font-size:80%;opacity:0.8"> 在各种任务中，attention机制已经成为序列建模和转导模型不可或缺的一部分，它可以建模依赖关系而不考虑其在输入或输出序列中的距离[2, 19]。</span></li><li>To the best of our knowledge, however, the Transformer is the first <font color=orangered>transduction</font> model relying entirely on self-attention to compute representations of its input and output without using sequence-aligned RNNs or convolution.<span style="font-size:80%;opacity:0.8"> 然而，就我们所知，Transformer是第一个完全依靠self-attention来计算输入和输出表示而不使用序列对齐RNN或卷积的转导模型。</span></li><li>Most competitive neural sequence <font color=orangered>transduction</font> models have an encoder-decoder structure [5, 2, 35].<span style="font-size:80%;opacity:0.8"> 大部分神经序列转导模型都有一个编码器-解码器结构[5, 2, 35]。</span></li><li>Similarly to other sequence <font color=orangered>transduction</font> models, we use learned embeddings to convert the input tokens and output tokens to vectors of dimension dmodel.<span style="font-size:80%;opacity:0.8"> 与其他序列转导模型类似，我们使用学习到的嵌入将输入词符和输出词符转换为维度为dmodel的向量。</span></li><li>In this section we compare various aspects of self-attention layers to the recurrent and convolutional layers commonly used for mapping one variable-length sequence of symbol representations $(x_1,\cdots,x_n)$ to another sequence of equal length $(z_1,\cdots,z_n)$, with $x_i$, $z_i \in \mathbb R^d$, such as a hidden layer in a typical sequence <font color=orangered>transduction</font> encoder or decoder.<span style="font-size:80%;opacity:0.8"> 本节，我们比较self-attention与循环层和卷积层的各个方面，它们通常用于映射变长的符号序列表示(x1,...,xn) 到另一个等长的序列(z1,...,zn)，其中xi,zi ∈ ℝd，例如一个典型的序列转导编码器或解码器中的隐藏层。</span></li><li>Learning long-range dependencies is a key challenge in many sequence <font color=orangered>transduction</font> tasks.<span style="font-size:80%;opacity:0.8">  学习长距离依赖性是许多序列转导任务中的关键挑战。</span></li><li>In this work, we presented the Transformer, the first sequence <font color=orangered>transduction</font> model based entirely on attention, replacing the recurrent layers most commonly used in encoder-decoder architectures with multi-headed self-attention.<span style="font-size:80%;opacity:0.8"> 在这项工作中，我们提出了Transformer，第一个完全基于关注的序列转导模型，用multi-headed self-attention取代了编码器-解码器架构中最常用的循环层。</span></li></ul>
 </td>
</tr>
<tr>
<td> 21 </td> <td> recurrent </td> <td> [rɪˈkʌrənt] </td> <td> 
<ul><li>The dominant sequence transduction models are based on complex <font color=orangered>recurrent</font> or convolutional neural networks that include an encoder and a decoder.<span style="font-size:80%;opacity:0.8"> 主流序列转导模型基于复杂的循环神经网络或卷积神经网络，这些神经网络包含一个编码器和一个解码器。</span></li><li><font color=orangered>Recurrent</font> neural networks, long short-term memory [13] and gated recurrent [7] neural networks in particular, have been firmly established as state of the art approaches in sequence modeling and transduction problems such as language modeling and machine translation [35, 2, 5].<span style="font-size:80%;opacity:0.8"> 在序列建模和转换问题中，如语言建模和机器翻译[35, 2, 5]，循环神经网络特别是长短期记忆[13]和门控循环[7]神经网络，已经被确立为最先进的方法。</span></li><li>Recurrent neural networks, long short-term memory [13] and gated <font color=orangered>recurrent</font> [7] neural networks in particular, have been firmly established as state of the art approaches in sequence modeling and transduction problems such as language modeling and machine translation [35, 2, 5].<span style="font-size:80%;opacity:0.8"> 在序列建模和转换问题中，如语言建模和机器翻译[35, 2, 5]，循环神经网络特别是长短期记忆[13]和门控循环[7]神经网络，已经被确立为最先进的方法。</span></li><li>Numerous efforts have since continued to push the boundaries of <font color=orangered>recurrent</font> language models and encoder-decoder architectures [38, 24, 15].<span style="font-size:80%;opacity:0.8">  自那以后，许多努力一直在推动循环语言模型和编码器-解码器架构的界限[38, 24, 15]。</span></li><li><font color=orangered>Recurrent</font> models typically factor computation along the symbol positions of the input and output sequences.<span style="font-size:80%;opacity:0.8"> 循环模型通常是对输入和输出序列的符号位置进行因子计算。</span></li><li>In all but a few cases [27], however, such attention mechanisms are used in conjunction with a <font color=orangered>recurrent</font> network.<span style="font-size:80%;opacity:0.8">  除少数情况外[27]，这种attention机制都与循环网络一起使用。</span></li><li>End-to-end memory networks are based on a <font color=orangered>recurrent</font> attention mechanism instead of sequence-aligned recurrence and have been shown to perform well on simple-language question answering and language modeling tasks [34].<span style="font-size:80%;opacity:0.8"> 端到端的记忆网络基于循环attention机制，而不是序列对齐的循环，并且已被证明在简单语言的问答和语言建模任务中表现良好[34]。</span></li><li>In this section we compare various aspects of self-attention layers to the <font color=orangered>recurrent</font> and convolutional layers commonly used for mapping one variable-length sequence of symbol representations $(x_1,\cdots,x_n)$ to another sequence of equal length $(z_1,\cdots,z_n)$, with $x_i$, $z_i \in \mathbb R^d$, such as a hidden layer in a typical sequence transduction encoder or decoder.<span style="font-size:80%;opacity:0.8"> 本节，我们比较self-attention与循环层和卷积层的各个方面，它们通常用于映射变长的符号序列表示(x1,...,xn) 到另一个等长的序列(z1,...,zn)，其中xi,zi ∈ ℝd，例如一个典型的序列转导编码器或解码器中的隐藏层。</span></li><li>As noted in Table 1, a self-attention layer connects all positions with a constant number of sequentially executed operations, whereas a <font color=orangered>recurrent</font> layer requires $O(n)$ sequential operations.<span style="font-size:80%;opacity:0.8"> 如表1所示，self-attention层将所有位置连接到恒定数量的顺序执行的操作，而循环层需要O(n) 顺序操作。</span></li><li>In terms of computational complexity, self-attention layers are faster than <font color=orangered>recurrent</font> layers when the sequence length n is smaller than the representation dimensionality d, which is most often the case with sentence representations used by state-of-the-art models in machine translations, such as word-piece [38] and byte-pair [31] representations.<span style="font-size:80%;opacity:0.8">  在计算复杂性方面，当序列长度n 小于表示维度d 时，self-attention层比循环层快，这是机器翻译中最先进的模型最常见情况，例如单词[38]表示法和字节对[31]表示法。</span></li><li>Convolutional layers are generally more expensive than <font color=orangered>recurrent</font> layers, by a factor of k.<span style="font-size:80%;opacity:0.8">  卷积层通常比循环层更昂贵，与因子k有关。</span></li><li>In this work, we presented the Transformer, the first sequence transduction model based entirely on attention, replacing the <font color=orangered>recurrent</font> layers most commonly used in encoder-decoder architectures with multi-headed self-attention.<span style="font-size:80%;opacity:0.8"> 在这项工作中，我们提出了Transformer，第一个完全基于关注的序列转导模型，用multi-headed self-attention取代了编码器-解码器架构中最常用的循环层。</span></li><li>For translation tasks, the Transformer can be trained significantly faster than architectures based on <font color=orangered>recurrent</font> or convolutional layers.<span style="font-size:80%;opacity:0.8"> 对于翻译任务，Transformer可以比基于循环或卷积层的体系结构训练更快。</span></li></ul>
 </td>
</tr>
<tr>
<td> 22 </td> <td> dispense </td> <td> [dɪˈspens] </td> <td> 
<ul><li>We propose a new simple network architecture, the Transformer, based solely on attention mechanisms, <font color=orangered>dispensing</font> with recurrence and convolutions entirely.<span style="font-size:80%;opacity:0.8">  我们提出一种新的简单的网络架构Transformer，仅基于attention机制并完全避免循环和卷积。</span></li></ul>
 </td>
</tr>
<tr>
<td> 23 </td> <td> parallelizable </td> <td>  </td> <td> 
<ul><li>Experiments on two machine translation tasks show these models to be superior in quality while being more <font color=forestgreen>parallelizable</font> and requiring significantly less time to train.<span style="font-size:80%;opacity:0.8">  对两个机器翻译任务的实验表明，这些模型在质量上更加优越、并行性更好并且需要的训练时间显著减少。</span></li></ul>
 </td>
</tr>
<tr>
<td> 24 </td> <td> BLEU </td> <td> [blju:] </td> <td> 
<ul><li>Our model achieves 28.4 <font color=orangered>BLEU</font> on the WMT 2014 English-to-German translation task, improving over the existing best results, including ensembles, by over 2 BLEU.<span style="font-size:80%;opacity:0.8">  我们的模型在WMT 2014英语-德语翻译任务上达到28.4 BLEU，超过现有最佳结果（包括整合模型）2个BLEU。</span></li><li>Our model achieves 28.4 BLEU on the WMT 2014 English-to-German translation task, improving over the existing best results, including ensembles, by over 2 <font color=orangered>BLEU</font>.<span style="font-size:80%;opacity:0.8">  我们的模型在WMT 2014英语-德语翻译任务上达到28.4 BLEU，超过现有最佳结果（包括整合模型）2个BLEU。</span></li><li>On the WMT 2014 English-to-French translation task, our model establishes a new single-model state-of-the-art <font color=orangered>BLEU</font> score of 41.8 after training for 3.5 days on eight GPUs, a small fraction of the training costs of the best models from the literature.<span style="font-size:80%;opacity:0.8">  在WMT 2014英语-法语翻译任务中，我们的模型建立了单模型新的最先进的BLEU分数41.8，它在8个GPU上训练了3.5天，这个时间只是目前文献中记载的最好的模型训练成本的一小部分。</span></li><li>This hurts perplexity, as the model learns to be more unsure, but improves accuracy and <font color=orangered>BLEU</font> score.<span style="font-size:80%;opacity:0.8">  这让模型不易理解，因为模型学得更加不确定，但提高了准确性和BLEU得分。</span></li><li>Table 2: The Transformer achieves better <font color=orangered>BLEU</font> scores than previous state-of-the-art models on the English-to-German and English-to-French newstest2014 tests at a fraction of the training cost.<span style="font-size:80%;opacity:0.8"> 表2： Transformer在英语-德语和英语-法语newstest2014测试中获得的BLEU分数比以前的最新模型的分数更好，且训练成本只是它们的一小部分。</span></li><li>On the WMT 2014 English-to-German translation task, the big transformer model (Transformer (big) in Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0 <font color=orangered>BLEU</font>, establishing a new state-of-the-art BLEU score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 P100 GPUs.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>On the WMT 2014 English-to-German translation task, the big transformer model (Transformer (big) in Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0 BLEU, establishing a new state-of-the-art <font color=orangered>BLEU</font> score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 P100 GPUs.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>On the WMT 2014 English-to-French translation task, our big model achieves a <font color=orangered>BLEU</font> score of 41.0, outperforming all of the previously published single models, at less than 1∕4 the training cost of the previous state-of-the-art model.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-法语翻译任务中，我们的大型模型的BLEU得分为41.0，超过了之前发布的所有单一模型，训练成本低于先前最先进模型的1 ∕ 4 。</span></li><li>In Table 3 rows (A), we vary the number of attention heads and the attention key and value dimensions, keeping the amount of computation constant, as described in Section 3.2.2.  While single-head attention is 0.9 <font color=orangered>BLEU</font> worse than the best setting, quality also drops off with too many heads.<span style="font-size:80%;opacity:0.8"> 在表3的行（A）中，我们改变attention head的数量和attention key和value的维度，保持计算量不变，如3.2.2节所述。 虽然只有一个head attention比最佳设置差0.9 BLEU，但质量也随着head太多而下降。</span></li></ul>
 </td>
</tr>
<tr>
<td> 25 </td> <td> WMT </td> <td> [!≈ 'dʌblju: em ti:] </td> <td> 
<ul><li>Our model achieves 28.4 BLEU on the <font color=orangered>WMT</font> 2014 English-to-German translation task, improving over the existing best results, including ensembles, by over 2 BLEU.<span style="font-size:80%;opacity:0.8">  我们的模型在WMT 2014英语-德语翻译任务上达到28.4 BLEU，超过现有最佳结果（包括整合模型）2个BLEU。</span></li><li>On the <font color=orangered>WMT</font> 2014 English-to-French translation task, our model establishes a new single-model state-of-the-art BLEU score of 41.8 after training for 3.5 days on eight GPUs, a small fraction of the training costs of the best models from the literature.<span style="font-size:80%;opacity:0.8">  在WMT 2014英语-法语翻译任务中，我们的模型建立了单模型新的最先进的BLEU分数41.8，它在8个GPU上训练了3.5天，这个时间只是目前文献中记载的最好的模型训练成本的一小部分。</span></li><li>We trained on the standard <font color=orangered>WMT</font> 2014 English-German dataset consisting of about 4.5 million sentence pairs.<span style="font-size:80%;opacity:0.8"> 我们在标准的WMT 2014英语-德语数据集上进行了训练，其中包含约450万个句子对。</span></li><li>For English-French, we used the significantly larger <font color=orangered>WMT</font> 2014 English-French dataset consisting of 36M sentences and split tokens into a 32000 word-piece vocabulary [38].<span style="font-size:80%;opacity:0.8">  对于英语-法语翻译，我们使用大得多的WMT 2014英法数据集，它包含3600万个句子，并将词符分成32000个word-piece词汇表[38]。</span></li><li>On the <font color=orangered>WMT</font> 2014 English-to-German translation task, the big transformer model (Transformer (big) in Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0 BLEU, establishing a new state-of-the-art BLEU score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 P100 GPUs.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>On the <font color=orangered>WMT</font> 2014 English-to-French translation task, our big model achieves a BLEU score of 41.0, outperforming all of the previously published single models, at less than 1∕4 the training cost of the previous state-of-the-art model.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-法语翻译任务中，我们的大型模型的BLEU得分为41.0，超过了之前发布的所有单一模型，训练成本低于先前最先进模型的1 ∕ 4 。</span></li><li>On both <font color=orangered>WMT</font> 2014 English-to-German and WMT 2014 English-to-French translation tasks, we achieve a new state of the art.<span style="font-size:80%;opacity:0.8">  在WMT 2014英语-德语和WMT 2014英语-法语翻译任务中，我们取得了最好的结果。</span></li><li>On both WMT 2014 English-to-German and <font color=orangered>WMT</font> 2014 English-to-French translation tasks, we achieve a new state of the art.<span style="font-size:80%;opacity:0.8">  在WMT 2014英语-德语和WMT 2014英语-法语翻译任务中，我们取得了最好的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 26 </td> <td> ensemble </td> <td> [ɒnˈsɒmbl] </td> <td> 
<ul><li>Our model achieves 28.4 BLEU on the WMT 2014 English-to-German translation task, improving over the existing best results, including <font color=orangered>ensembles</font>, by over 2 BLEU.<span style="font-size:80%;opacity:0.8">  我们的模型在WMT 2014英语-德语翻译任务上达到28.4 BLEU，超过现有最佳结果（包括整合模型）2个BLEU。</span></li><li>On the WMT 2014 English-to-German translation task, the big transformer model (Transformer (big) in Table 2) outperforms the best previously reported models (including <font color=orangered>ensembles</font>) by more than 2.0 BLEU, establishing a new state-of-the-art BLEU score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 P100 GPUs.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>Even our base model surpasses all previously published models and <font color=orangered>ensembles</font>, at a fraction of the training cost of any of the competitive models.<span style="font-size:80%;opacity:0.8">  即使我们的基础模型也超过了以前发布的所有模型和整合模型，且训练成本只是这些模型的一小部分。</span></li><li>In the former task our best model outperforms even all previously reported <font color=orangered>ensembles</font>.<span style="font-size:80%;opacity:0.8">  在前面的任务中，我们最好的模型甚至胜过以前报道过的所有整合模型。</span></li></ul>
 </td>
</tr>
<tr>
<td> 27 </td> <td> constituency </td> <td> [kənˈstɪtjuənsi] </td> <td> 
<ul><li>We show that the Transformer generalizes well to other tasks by applying it successfully to English <font color=orangered>constituency</font> parsing both with large and limited training data.<span style="font-size:80%;opacity:0.8">  通过在解析大量训练数据和有限训练数据的两种情况下将其应用到English constituency，我们表明Transformer可以很好地推广到其他任务。</span></li><li>6.3 English <font color=orangered>Constituency</font> Parsing<span style="font-size:80%;opacity:0.8"> 6.3 English Constituency Parsing</span></li><li>Table 4: The Transformer generalizes well to English <font color=orangered>constituency</font> parsing (Results are on Section 23 of WSJ)<span style="font-size:80%;opacity:0.8"> 表4： The Transformer generalizes well to English constituency parsing (Results are on Section 23 of WSJ)</span></li><li>To evaluate if the Transformer can generalize to other tasks we performed experiments on English <font color=orangered>constituency</font> parsing. This task presents specific challenges: the output is subject to strong structural constraints and is significantly longer than the input.<span style="font-size:80%;opacity:0.8"> To evaluate if the Transformer can generalize to other tasks we performed experiments on English constituency parsing. 这项任务提出特别的挑战：输出受到很强的结构性约束，并且比输入要长很多。</span></li></ul>
 </td>
</tr>
<tr>
<td> 28 </td> <td> parse </td> <td> [pɑ:z] </td> <td> 
<ul><li>We show that the Transformer generalizes well to other tasks by applying it successfully to English constituency <font color=orangered>parsing</font> both with large and limited training data.<span style="font-size:80%;opacity:0.8">  通过在解析大量训练数据和有限训练数据的两种情况下将其应用到English constituency，我们表明Transformer可以很好地推广到其他任务。</span></li><li>6.3 English Constituency <font color=orangered>Parsing</font><span style="font-size:80%;opacity:0.8"> 6.3 English Constituency Parsing</span></li><li>Table 4: The Transformer generalizes well to English constituency <font color=orangered>parsing</font> (Results are on Section 23 of WSJ)<span style="font-size:80%;opacity:0.8"> 表4： The Transformer generalizes well to English constituency parsing (Results are on Section 23 of WSJ)</span></li><li>To evaluate if the Transformer can generalize to other tasks we performed experiments on English constituency <font color=orangered>parsing</font>. This task presents specific challenges: the output is subject to strong structural constraints and is significantly longer than the input.<span style="font-size:80%;opacity:0.8"> To evaluate if the Transformer can generalize to other tasks we performed experiments on English constituency parsing. 这项任务提出特别的挑战：输出受到很强的结构性约束，并且比输入要长很多。</span></li></ul>
 </td>
</tr>
<tr>
<td> 29 </td> <td> encoder-decoder </td> <td> [!≈ ɪn'kəʊdə ˌdi:ˈkəʊdə(r)] </td> <td> 
<ul><li>Numerous efforts have since continued to push the boundaries of recurrent language models and <font color=orangered>encoder-decoder</font> architectures [38, 24, 15].<span style="font-size:80%;opacity:0.8">  自那以后，许多努力一直在推动循环语言模型和编码器-解码器架构的界限[38, 24, 15]。</span></li><li>Most competitive neural sequence transduction models have an <font color=orangered>encoder-decoder</font> structure [5, 2, 35].<span style="font-size:80%;opacity:0.8"> 大部分神经序列转导模型都有一个编码器-解码器结构[5, 2, 35]。</span></li><li>In &quot;<font color=orangered>encoder-decoder</font> attention&quot; layers, the queries come from the previous decoder layer, and the memory keys and values come from the output of the encoder.<span style="font-size:80%;opacity:0.8"> 在“编码器—解码器attention”层，query来自上面的解码器层，key和value来自编码器的输出。</span></li><li>This mimics the typical <font color=orangered>encoder-decoder</font> attention mechanisms in sequence-to-sequence models such as [38, 2, 9].<span style="font-size:80%;opacity:0.8">  这模仿序列到序列模型中典型的编码器—解码器的attention机制，例如[38, 2, 9]。</span></li><li>In this work, we presented the Transformer, the first sequence transduction model based entirely on attention, replacing the recurrent layers most commonly used in <font color=orangered>encoder-decoder</font> architectures with multi-headed self-attention.<span style="font-size:80%;opacity:0.8"> 在这项工作中，我们提出了Transformer，第一个完全基于关注的序列转导模型，用multi-headed self-attention取代了编码器-解码器架构中最常用的循环层。</span></li></ul>
 </td>
</tr>
<tr>
<td> 30 </td> <td> align </td> <td> [əˈlaɪn] </td> <td> 
<ul><li><font color=orangered>Aligning</font> the positions to steps in computation time, they generate a sequence of hidden states ht, as a function of the previous hidden state ht-1 and the input for position t.<span style="font-size:80%;opacity:0.8">  通过在计算期间将位置与步骤对齐，它们根据前一步的隐藏状态ht-1和输入产生位置t的隐藏状态序列ht。</span></li></ul>
 </td>
</tr>
<tr>
<td> 31 </td> <td> ht </td> <td>  </td> <td> 
<ul><li>Aligning the positions to steps in computation time, they generate a sequence of hidden states <font color=forestgreen>ht</font>, as a function of the previous hidden state ht-1 and the input for position t.<span style="font-size:80%;opacity:0.8">  通过在计算期间将位置与步骤对齐，它们根据前一步的隐藏状态ht-1和输入产生位置t的隐藏状态序列ht。</span></li><li>Aligning the positions to steps in computation time, they generate a sequence of hidden states ht, as a function of the previous hidden state <font color=forestgreen>ht</font>-1 and the input for position t.<span style="font-size:80%;opacity:0.8">  通过在计算期间将位置与步骤对齐，它们根据前一步的隐藏状态ht-1和输入产生位置t的隐藏状态序列ht。</span></li></ul>
 </td>
</tr>
<tr>
<td> 32 </td> <td> inherently </td> <td> [ɪnˈhɪərəntlɪ] </td> <td> 
<ul><li>This <font color=orangered>inherently</font> sequential nature precludes parallelization within training examples, which becomes critical at longer sequence lengths, as memory constraints limit batching across examples.<span style="font-size:80%;opacity:0.8"> 这种固有的顺序特性阻碍样本训练的并行化，这在更长的序列长度上变得至关重要，因为有限的内存限制样本的批次大小。</span></li></ul>
 </td>
</tr>
<tr>
<td> 33 </td> <td> sequential </td> <td> [sɪˈkwenʃl] </td> <td> 
<ul><li>This inherently <font color=orangered>sequential</font> nature precludes parallelization within training examples, which becomes critical at longer sequence lengths, as memory constraints limit batching across examples.<span style="font-size:80%;opacity:0.8"> 这种固有的顺序特性阻碍样本训练的并行化，这在更长的序列长度上变得至关重要，因为有限的内存限制样本的批次大小。</span></li><li>The fundamental constraint of <font color=orangered>sequential</font> computation, however, remains.<span style="font-size:80%;opacity:0.8">  然而，顺序计算的基本约束依然存在。</span></li><li>The goal of reducing <font color=orangered>sequential</font> computation also forms the foundation of the Extended Neural GPU [16], ByteNet [18] and ConvS2S [9], all of which use convolutional neural networks as basic building block, computing hidden representations in parallel for all input and output positions.<span style="font-size:80%;opacity:0.8"> 减少顺序计算的目标也构成扩展的神经网络GPU [16]、ByteNet [18]和ConvS2S [9]的基础，它们都使用卷积神经网络作为基本构建模块、并行计算所有输入和输出位置的隐藏表示。</span></li><li>Another is the amount of computation that can be parallelized, as measured by the minimum number of <font color=orangered>sequential</font> operations required.<span style="font-size:80%;opacity:0.8">  另一个是可以并行的计算量，以所需的最小顺序操作的数量来衡量。</span></li><li>Table 1: Maximum path lengths, per-layer complexity and minimum number of <font color=orangered>sequential</font> operations for different layer types.<span style="font-size:80%;opacity:0.8"> 表1： 不同图层类型的最大路径长度、每层复杂度和最少顺序操作数。</span></li><li>As noted in Table 1, a self-attention layer connects all positions with a constant number of sequentially executed operations, whereas a recurrent layer requires $O(n)$ <font color=orangered>sequential</font> operations.<span style="font-size:80%;opacity:0.8"> 如表1所示，self-attention层将所有位置连接到恒定数量的顺序执行的操作，而循环层需要O(n) 顺序操作。</span></li><li>Making generation less <font color=orangered>sequential</font> is another research goals of ours.<span style="font-size:80%;opacity:0.8">  让生成具有更少的顺序性是我们的另一个研究目标。</span></li></ul>
 </td>
</tr>
<tr>
<td> 34 </td> <td> parallelization </td> <td> [pærəlɪlaɪ'zeɪʃn] </td> <td> 
<ul><li>This inherently sequential nature precludes <font color=orangered>parallelization</font> within training examples, which becomes critical at longer sequence lengths, as memory constraints limit batching across examples.<span style="font-size:80%;opacity:0.8"> 这种固有的顺序特性阻碍样本训练的并行化，这在更长的序列长度上变得至关重要，因为有限的内存限制样本的批次大小。</span></li><li>The Transformer allows for significantly more <font color=orangered>parallelization</font> and can reach a new state of the art in translation quality after being trained for as little as twelve hours on eight P100 GPUs.<span style="font-size:80%;opacity:0.8">  Transformer允许进行更多的并行化，并且可以在八个P100 GPU上接受少至十二小时的训练后达到翻译质量的新的最佳结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 35 </td> <td> factorization </td> <td> [ˌfæktəraiˈzeiʃən] </td> <td> 
<ul><li>Recent work has achieved significant improvements in computational efficiency through <font color=orangered>factorization</font> tricks [21] and conditional computation [32], while also improving model performance in case of the latter.<span style="font-size:80%;opacity:0.8">  最近的工作通过巧妙的因子分解[21]和条件计算[32]在计算效率方面取得重大进展，后者还同时提高了模型性能。</span></li></ul>
 </td>
</tr>
<tr>
<td> 36 </td> <td> conditional </td> <td> [kənˈdɪʃənl] </td> <td> 
<ul><li>Recent work has achieved significant improvements in computational efficiency through factorization tricks [21] and <font color=orangered>conditional</font> computation [32], while also improving model performance in case of the latter.<span style="font-size:80%;opacity:0.8">  最近的工作通过巧妙的因子分解[21]和条件计算[32]在计算效率方面取得重大进展，后者还同时提高了模型性能。</span></li></ul>
 </td>
</tr>
<tr>
<td> 37 </td> <td> integral </td> <td> [ˈɪntɪgrəl] </td> <td> 
<ul><li>Attention mechanisms have become an <font color=orangered>integral</font> part of compelling sequence modeling and transduction models in various tasks, allowing modeling of dependencies without regard to their distance in the input or output sequences [2, 19].<span style="font-size:80%;opacity:0.8"> 在各种任务中，attention机制已经成为序列建模和转导模型不可或缺的一部分，它可以建模依赖关系而不考虑其在输入或输出序列中的距离[2, 19]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 38 </td> <td> conjunction </td> <td> [kənˈdʒʌŋkʃn] </td> <td> 
<ul><li>In all but a few cases [27], however, such attention mechanisms are used in <font color=orangered>conjunction</font> with a recurrent network.<span style="font-size:80%;opacity:0.8">  除少数情况外[27]，这种attention机制都与循环网络一起使用。</span></li></ul>
 </td>
</tr>
<tr>
<td> 39 </td> <td> eschew </td> <td> [ɪsˈtʃu:] </td> <td> 
<ul><li>In this work we propose the Transformer, a model architecture <font color=orangered>eschewing</font> recurrence and instead relying entirely on an attention mechanism to draw global dependencies between input and output.<span style="font-size:80%;opacity:0.8"> 在这项工作中我们提出Transformer，这种模型架构避免循环并完全依赖于attention机制来绘制输入和输出之间的全局依赖关系。</span></li></ul>
 </td>
</tr>
<tr>
<td> 40 </td> <td> P100 </td> <td>  </td> <td> 
<ul><li>The Transformer allows for significantly more parallelization and can reach a new state of the art in translation quality after being trained for as little as twelve hours on eight <font color=forestgreen>P100</font> GPUs.<span style="font-size:80%;opacity:0.8">  Transformer允许进行更多的并行化，并且可以在八个P100 GPU上接受少至十二小时的训练后达到翻译质量的新的最佳结果。</span></li><li>We trained our models on one machine with 8 NVIDIA <font color=forestgreen>P100</font> GPUs.<span style="font-size:80%;opacity:0.8"> 我们在一台具有8个NVIDIA P100 GPU的机器上训练我们的模型。</span></li><li>On the WMT 2014 English-to-German translation task, the big transformer model (Transformer (big) in Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0 BLEU, establishing a new state-of-the-art BLEU score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 <font color=forestgreen>P100</font> GPUs.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision floating-point capacity of each GPU (We used values of 2.8, 3.7, 6.0 and 9.5 TFLOPS for K80, K40, M40 and <font color=forestgreen>P100</font>, respectively).<span style="font-size:80%;opacity:0.8">  我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量(对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 41 </td> <td> ByteNet </td> <td>  </td> <td> 
<ul><li>The goal of reducing sequential computation also forms the foundation of the Extended Neural GPU [16], <font color=forestgreen>ByteNet</font> [18] and ConvS2S [9], all of which use convolutional neural networks as basic building block, computing hidden representations in parallel for all input and output positions.<span style="font-size:80%;opacity:0.8"> 减少顺序计算的目标也构成扩展的神经网络GPU [16]、ByteNet [18]和ConvS2S [9]的基础，它们都使用卷积神经网络作为基本构建模块、并行计算所有输入和输出位置的隐藏表示。</span></li><li>In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, linearly for ConvS2S and logarithmically for <font color=forestgreen>ByteNet</font>.<span style="font-size:80%;opacity:0.8">  在这些模型中，关联任意两个输入和输出位置的信号所需的操作次数会随着位置之间的距离而增加，ConvS2S是线性增加，而ByteNet是对数增加。</span></li></ul>
 </td>
</tr>
<tr>
<td> 42 </td> <td> ConvS2S </td> <td>  </td> <td> 
<ul><li>The goal of reducing sequential computation also forms the foundation of the Extended Neural GPU [16], ByteNet [18] and <font color=forestgreen>ConvS2S</font> [9], all of which use convolutional neural networks as basic building block, computing hidden representations in parallel for all input and output positions.<span style="font-size:80%;opacity:0.8"> 减少顺序计算的目标也构成扩展的神经网络GPU [16]、ByteNet [18]和ConvS2S [9]的基础，它们都使用卷积神经网络作为基本构建模块、并行计算所有输入和输出位置的隐藏表示。</span></li><li>In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, linearly for <font color=forestgreen>ConvS2S</font> and logarithmically for ByteNet.<span style="font-size:80%;opacity:0.8">  在这些模型中，关联任意两个输入和输出位置的信号所需的操作次数会随着位置之间的距离而增加，ConvS2S是线性增加，而ByteNet是对数增加。</span></li></ul>
 </td>
</tr>
<tr>
<td> 43 </td> <td> arbitrary </td> <td> [ˈɑ:bɪtrəri] </td> <td> 
<ul><li>In these models, the number of operations required to relate signals from two <font color=orangered>arbitrary</font> input or output positions grows in the distance between positions, linearly for ConvS2S and logarithmically for ByteNet.<span style="font-size:80%;opacity:0.8">  在这些模型中，关联任意两个输入和输出位置的信号所需的操作次数会随着位置之间的距离而增加，ConvS2S是线性增加，而ByteNet是对数增加。</span></li></ul>
 </td>
</tr>
<tr>
<td> 44 </td> <td> linearly </td> <td> [ˈliniəli] </td> <td> 
<ul><li>In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, <font color=orangered>linearly</font> for ConvS2S and logarithmically for ByteNet.<span style="font-size:80%;opacity:0.8">  在这些模型中，关联任意两个输入和输出位置的信号所需的操作次数会随着位置之间的距离而增加，ConvS2S是线性增加，而ByteNet是对数增加。</span></li><li>Instead of performing a single attention function with $d$ model-dimensional keys, values and queries, we found it beneficial to <font color=orangered>linearly</font> project the queries, keys and values $h$ times with different, learned linear projections to $d_k$, $d_k$ and $d_v$ dimensions, respectively.<span style="font-size:80%;opacity:0.8"> 我们发现将query、key和value分别用不同的、学到的线性映射h倍到dk、dk和dv维效果更好，而不是用d model维的query、key和value执行单个attention函数。</span></li><li>This corresponds to increasing the learning rate <font color=orangered>linearly</font> for the first warmup_steps training steps, and decreasing it thereafter proportionally to the inverse square root of the step number.<span style="font-size:80%;opacity:0.8"> 这对应于在第一次warmup_steps 步骤中线性地增加学习速率，并且随后将其与步骤数的平方根成比例地减小。</span></li></ul>
 </td>
</tr>
<tr>
<td> 45 </td> <td> logarithmically </td> <td> ['lɒɡərɪðmɪklɪ] </td> <td> 
<ul><li>In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, linearly for ConvS2S and <font color=orangered>logarithmically</font> for ByteNet.<span style="font-size:80%;opacity:0.8">  在这些模型中，关联任意两个输入和输出位置的信号所需的操作次数会随着位置之间的距离而增加，ConvS2S是线性增加，而ByteNet是对数增加。</span></li></ul>
 </td>
</tr>
<tr>
<td> 46 </td> <td> albeit </td> <td> [ˌɔ:lˈbi:ɪt] </td> <td> 
<ul><li>In the Transformer this is reduced to a constant number of operations, <font color=orangered>albeit</font> at the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we counteract with Multi-Head Attention as described in section 3.2.<span style="font-size:80%;opacity:0.8">  在Transformer中，这种操作减少到固定的次数，尽管由于对用attention权重化的位置取平均降低了效果，但是我使用Multi-Head Attention进行抵消，具体描述见 3.2。</span></li></ul>
 </td>
</tr>
<tr>
<td> 47 </td> <td> attention-weighted </td> <td> [!≈ əˈtenʃn ˈweɪtɪd] </td> <td> 
<ul><li>In the Transformer this is reduced to a constant number of operations, albeit at the cost of reduced effective resolution due to averaging <font color=orangered>attention-weighted</font> positions, an effect we counteract with Multi-Head Attention as described in section 3.2.<span style="font-size:80%;opacity:0.8">  在Transformer中，这种操作减少到固定的次数，尽管由于对用attention权重化的位置取平均降低了效果，但是我使用Multi-Head Attention进行抵消，具体描述见 3.2。</span></li></ul>
 </td>
</tr>
<tr>
<td> 48 </td> <td> counteract </td> <td> [ˌkaʊntərˈækt] </td> <td> 
<ul><li>In the Transformer this is reduced to a constant number of operations, albeit at the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we <font color=orangered>counteract</font> with Multi-Head Attention as described in section 3.2.<span style="font-size:80%;opacity:0.8">  在Transformer中，这种操作减少到固定的次数，尽管由于对用attention权重化的位置取平均降低了效果，但是我使用Multi-Head Attention进行抵消，具体描述见 3.2。</span></li><li>To <font color=orangered>counteract</font> this effect, we scale the dot products by $\frac 1 {\sqrt{d_k}}$.<span style="font-size:80%;opacity:0.8">  为了抵消这种影响，我们缩小点积 $\frac 1 {\sqrt{d_k}}$倍。</span></li></ul>
 </td>
</tr>
<tr>
<td> 49 </td> <td> intra-attention </td> <td> [!≈ 'ɪntrə əˈtenʃn] </td> <td> 
<ul><li>Self-attention, sometimes called <font color=orangered>intra-attention</font> is an attention mechanism relating different positions of a single sequence in order to compute a representation of the sequence.<span style="font-size:80%;opacity:0.8"> Self-attention，有时称为intra-attention，是一种attention机制，它关联单个序列的不同位置以计算序列的表示。</span></li></ul>
 </td>
</tr>
<tr>
<td> 50 </td> <td> abstractive </td> <td> [æb'strækәtiv] </td> <td> 
<ul><li>Self-attention has been used successfully in a variety of tasks including reading comprehension, <font color=orangered>abstractive</font> summarization, textual entailment and learning task-independent sentence representations [4, 27, 28, 22].<span style="font-size:80%;opacity:0.8">  Self-attention已成功用于各种任务，包括阅读理解、摘要概括、文本蕴涵和学习与任务无关的句子表征[4, 27, 28, 22]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 51 </td> <td> summarization </td> <td> [ˌsʌmərɪ'zeɪʃən] </td> <td> 
<ul><li>Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive <font color=orangered>summarization</font>, textual entailment and learning task-independent sentence representations [4, 27, 28, 22].<span style="font-size:80%;opacity:0.8">  Self-attention已成功用于各种任务，包括阅读理解、摘要概括、文本蕴涵和学习与任务无关的句子表征[4, 27, 28, 22]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 52 </td> <td> textual </td> <td> [ˈtekstʃuəl] </td> <td> 
<ul><li>Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive summarization, <font color=orangered>textual</font> entailment and learning task-independent sentence representations [4, 27, 28, 22].<span style="font-size:80%;opacity:0.8">  Self-attention已成功用于各种任务，包括阅读理解、摘要概括、文本蕴涵和学习与任务无关的句子表征[4, 27, 28, 22]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 53 </td> <td> entailment </td> <td> [en'teɪlmənt] </td> <td> 
<ul><li>Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive summarization, textual <font color=orangered>entailment</font> and learning task-independent sentence representations [4, 27, 28, 22].<span style="font-size:80%;opacity:0.8">  Self-attention已成功用于各种任务，包括阅读理解、摘要概括、文本蕴涵和学习与任务无关的句子表征[4, 27, 28, 22]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 54 </td> <td> task-independent </td> <td> [!≈ tɑ:sk ˌɪndɪˈpendənt] </td> <td> 
<ul><li>Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive summarization, textual entailment and learning <font color=orangered>task-independent</font> sentence representations [4, 27, 28, 22].<span style="font-size:80%;opacity:0.8">  Self-attention已成功用于各种任务，包括阅读理解、摘要概括、文本蕴涵和学习与任务无关的句子表征[4, 27, 28, 22]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 55 </td> <td> sequence-aligned </td> <td> [!≈ ˈsi:kwəns ə'laɪnd] </td> <td> 
<ul><li>End-to-end memory networks are based on a recurrent attention mechanism instead of <font color=orangered>sequence-aligned</font> recurrence and have been shown to perform well on simple-language question answering and language modeling tasks [34].<span style="font-size:80%;opacity:0.8"> 端到端的记忆网络基于循环attention机制，而不是序列对齐的循环，并且已被证明在简单语言的问答和语言建模任务中表现良好[34]。</span></li><li>To the best of our knowledge, however, the Transformer is the first transduction model relying entirely on self-attention to compute representations of its input and output without using <font color=orangered>sequence-aligned</font> RNNs or convolution.<span style="font-size:80%;opacity:0.8"> 然而，就我们所知，Transformer是第一个完全依靠self-attention来计算输入和输出表示而不使用序列对齐RNN或卷积的转导模型。</span></li></ul>
 </td>
</tr>
<tr>
<td> 56 </td> <td> simple-language </td> <td> [!≈ ˈsɪmpl ˈlæŋgwɪdʒ] </td> <td> 
<ul><li>End-to-end memory networks are based on a recurrent attention mechanism instead of sequence-aligned recurrence and have been shown to perform well on <font color=orangered>simple-language</font> question answering and language modeling tasks [34].<span style="font-size:80%;opacity:0.8"> 端到端的记忆网络基于循环attention机制，而不是序列对齐的循环，并且已被证明在简单语言的问答和语言建模任务中表现良好[34]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 57 </td> <td> xn </td> <td>  </td> <td> 
<ul><li>Here, the encoder maps an input sequence of symbol representations (x1,..., <font color=forestgreen>xn</font>) to a sequence of continuous representations z = (z1,..., zn).<span style="font-size:80%;opacity:0.8">  这里，编码器映射一个用符号表示的输入序列(x1,...,xn) 到一个连续的表示z = (z1,...,zn)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 58 </td> <td> zn </td> <td>  </td> <td> 
<ul><li>Here, the encoder maps an input sequence of symbol representations (x1,..., xn) to a sequence of continuous representations z = (z1,..., <font color=forestgreen>zn</font>).<span style="font-size:80%;opacity:0.8">  这里，编码器映射一个用符号表示的输入序列(x1,...,xn) 到一个连续的表示z = (z1,...,zn)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 59 </td> <td> ym </td> <td>  </td> <td> 
<ul><li>Given z, the decoder then generates an output sequence (y1,..., <font color=forestgreen>ym</font>) of symbols one element at a time.<span style="font-size:80%;opacity:0.8">  根据z，解码器生成符号的一个输出序列(y1,...,ym) ，一次一个元素。</span></li></ul>
 </td>
</tr>
<tr>
<td> 60 </td> <td> auto-regressive </td> <td> [!≈ ˈɔ:təʊ rɪˈgresɪv] </td> <td> 
<ul><li>At each step the model is <font color=orangered>auto-regressive</font> [10], consuming the previously generated symbols as additional input when generating the next.<span style="font-size:80%;opacity:0.8">  在每一步中，模型都是自回归的[10]，当生成下一个时，使用先前生成的符号作为附加输入。</span></li><li>We need to prevent leftward information flow in the decoder to preserve the <font color=orangered>auto-regressive</font> property.<span style="font-size:80%;opacity:0.8">  我们需要防止解码器中的向左信息流来保持自回归属性。</span></li></ul>
 </td>
</tr>
<tr>
<td> 61 </td> <td> point-wise </td> <td> [!≈ pɔɪnt waɪz] </td> <td> 
<ul><li>The Transformer follows this overall architecture using stacked self-attention and <font color=orangered>point-wise</font>, fully connected layers for both the encoder and decoder, shown in the left and right halves of Figure 1, respectively.<span style="font-size:80%;opacity:0.8"> Transformer遵循这种整体架构，编码器和解码器都使用self-attention堆叠和point-wise、完全连接的层，分别显示在图1的左边和右边。</span></li><li>Even with $k = n$, however, the complexity of a separable convolution is equal to the combination of a self-attention layer and a <font color=orangered>point-wise</font> feed-forward layer, the approach we take in our model.<span style="font-size:80%;opacity:0.8">  然而，即使k = n，一个可分卷积的复杂度等同于self-attention层和point-wise前向层的组合，即我们的模型采用的方法。</span></li></ul>
 </td>
</tr>
<tr>
<td> 62 </td> <td> sub-layer </td> <td> [!≈ sʌb ˈleɪə(r)] </td> <td> 
<ul><li>Each layer has two <font color=orangered>sub-layers</font>.<span style="font-size:80%;opacity:0.8">  每一层都有两个子层。</span></li><li>We employ a residual connection [11] around each of the two <font color=orangered>sub-layers</font>, followed by layer normalization [1].<span style="font-size:80%;opacity:0.8">  我们对每个子层再采用一个残差连接[11] ，接着进行层标准化[1]。</span></li><li>That is, the output of each <font color=orangered>sub-layer</font> is LayerNorm(x + Sublayer(x)), where Sublayer(x) is the function implemented by the sub-layer itself.<span style="font-size:80%;opacity:0.8">  也就是说，每个子层的输出是LayerNorm(x + Sublayer(x))，其中Sublayer(x) 是由子层本身实现的函数。</span></li><li>That is, the output of each sub-layer is LayerNorm(x + Sublayer(x)), where Sublayer(x) is the function implemented by the <font color=orangered>sub-layer</font> itself.<span style="font-size:80%;opacity:0.8">  也就是说，每个子层的输出是LayerNorm(x + Sublayer(x))，其中Sublayer(x) 是由子层本身实现的函数。</span></li><li>To facilitate these residual connections, all <font color=orangered>sub-layers</font> in the model, as well as the embedding layers, produce outputs of dimension dmodel = 512.<span style="font-size:80%;opacity:0.8">  为了方便这些残差连接，模型中的所有子层以及嵌入层产生的输出维度都为dmodel = 512。</span></li><li>In addition to the two <font color=orangered>sub-layers</font> in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head attention over the output of the encoder stack.<span style="font-size:80%;opacity:0.8">  除了每个编码器层中的两个子层之外，解码器还插入第三个子层，该层对编码器堆栈的输出执行multi-head attention。</span></li><li>In addition to the two sub-layers in each encoder layer, the decoder inserts a third <font color=orangered>sub-layer</font>, which performs multi-head attention over the output of the encoder stack.<span style="font-size:80%;opacity:0.8">  除了每个编码器层中的两个子层之外，解码器还插入第三个子层，该层对编码器堆栈的输出执行multi-head attention。</span></li><li>Similar to the encoder, we employ residual connections around each of the <font color=orangered>sub-layers</font>, followed by layer normalization.<span style="font-size:80%;opacity:0.8">  与编码器类似，我们在每个子层再采用残差连接，然后进行层标准化。</span></li><li>We also modify the self-attention <font color=orangered>sub-layer</font> in the decoder stack to prevent positions from attending to subsequent positions.<span style="font-size:80%;opacity:0.8">  我们还修改解码器堆栈中的self-attention子层，以防止位置关注到后面的位置。</span></li><li>In addition to attention <font color=orangered>sub-layers</font>, each of the layers in our encoder and decoder contains a fully connected feed-forward network, which is applied to each position separately and identically.<span style="font-size:80%;opacity:0.8"> 除了attention子层之外，我们的编码器和解码器中的每个层都包含一个完全连接的前馈网络，该前馈网络单独且相同地应用于每个位置。</span></li><li>Residual Dropout We apply dropout [33] to the output of each <font color=orangered>sub-layer</font>, before it is added to the sub-layer input and normalized.<span style="font-size:80%;opacity:0.8"> 残差丢弃 我们将丢弃[33]应用到每个子层的输出，在将它与子层的输入相加和规范化之前。</span></li><li>Residual Dropout We apply dropout [33] to the output of each sub-layer, before it is added to the <font color=orangered>sub-layer</font> input and normalized.<span style="font-size:80%;opacity:0.8"> 残差丢弃 我们将丢弃[33]应用到每个子层的输出，在将它与子层的输入相加和规范化之前。</span></li></ul>
 </td>
</tr>
<tr>
<td> 63 </td> <td> position-wise </td> <td> [!≈ pəˈzɪʃn waɪz] </td> <td> 
<ul><li>The first is a multi-head self-attention mechanism, and the second is a simple, <font color=orangered>position-wise</font> fully connected feed-forward network.<span style="font-size:80%;opacity:0.8">  第一个子层是一个multi-head self-attention机制，第二个子层是一个简单的、位置完全连接的前馈网络。</span></li><li>3.3 <font color=orangered>Position-wise</font> Feed-Forward Networks<span style="font-size:80%;opacity:0.8"> 3.3 基于位置的前馈网络</span></li></ul>
 </td>
</tr>
<tr>
<td> 64 </td> <td> feed-forward </td> <td> ['fi:df'ɔ:wəd] </td> <td> 
<ul><li>The first is a multi-head self-attention mechanism, and the second is a simple, position-wise fully connected <font color=orangered>feed-forward</font> network.<span style="font-size:80%;opacity:0.8">  第一个子层是一个multi-head self-attention机制，第二个子层是一个简单的、位置完全连接的前馈网络。</span></li><li>Additive attention computes the compatibility function using a <font color=orangered>feed-forward</font> network with a single hidden layer.<span style="font-size:80%;opacity:0.8">  加法attention使用具有单个隐藏层的前馈网络计算兼容性函数。</span></li><li>3.3 Position-wise <font color=orangered>Feed-Forward</font> Networks<span style="font-size:80%;opacity:0.8"> 3.3 基于位置的前馈网络</span></li><li>In addition to attention sub-layers, each of the layers in our encoder and decoder contains a fully connected <font color=orangered>feed-forward</font> network, which is applied to each position separately and identically.<span style="font-size:80%;opacity:0.8"> 除了attention子层之外，我们的编码器和解码器中的每个层都包含一个完全连接的前馈网络，该前馈网络单独且相同地应用于每个位置。</span></li><li>Even with $k = n$, however, the complexity of a separable convolution is equal to the combination of a self-attention layer and a point-wise <font color=orangered>feed-forward</font> layer, the approach we take in our model.<span style="font-size:80%;opacity:0.8">  然而，即使k = n，一个可分卷积的复杂度等同于self-attention层和point-wise前向层的组合，即我们的模型采用的方法。</span></li></ul>
 </td>
</tr>
<tr>
<td> 65 </td> <td> residual </td> <td> [rɪˈzɪdjuəl] </td> <td> 
<ul><li>We employ a <font color=orangered>residual</font> connection [11] around each of the two sub-layers, followed by layer normalization [1].<span style="font-size:80%;opacity:0.8">  我们对每个子层再采用一个残差连接[11] ，接着进行层标准化[1]。</span></li><li>To facilitate these <font color=orangered>residual</font> connections, all sub-layers in the model, as well as the embedding layers, produce outputs of dimension dmodel = 512.<span style="font-size:80%;opacity:0.8">  为了方便这些残差连接，模型中的所有子层以及嵌入层产生的输出维度都为dmodel = 512。</span></li><li>Similar to the encoder, we employ <font color=orangered>residual</font> connections around each of the sub-layers, followed by layer normalization.<span style="font-size:80%;opacity:0.8">  与编码器类似，我们在每个子层再采用残差连接，然后进行层标准化。</span></li><li><font color=orangered>Residual</font> Dropout We apply dropout [33] to the output of each sub-layer, before it is added to the sub-layer input and normalized.<span style="font-size:80%;opacity:0.8"> 残差丢弃 我们将丢弃[33]应用到每个子层的输出，在将它与子层的输入相加和规范化之前。</span></li></ul>
 </td>
</tr>
<tr>
<td> 66 </td> <td> LayerNorm </td> <td>  </td> <td> 
<ul><li>That is, the output of each sub-layer is <font color=forestgreen>LayerNorm</font>(x + Sublayer(x)), where Sublayer(x) is the function implemented by the sub-layer itself.<span style="font-size:80%;opacity:0.8">  也就是说，每个子层的输出是LayerNorm(x + Sublayer(x))，其中Sublayer(x) 是由子层本身实现的函数。</span></li></ul>
 </td>
</tr>
<tr>
<td> 67 </td> <td> Sublayer </td> <td> ['sʌb'leiә] </td> <td> 
<ul><li>That is, the output of each sub-layer is LayerNorm(x + <font color=orangered>Sublayer</font>(x)), where Sublayer(x) is the function implemented by the sub-layer itself.<span style="font-size:80%;opacity:0.8">  也就是说，每个子层的输出是LayerNorm(x + Sublayer(x))，其中Sublayer(x) 是由子层本身实现的函数。</span></li><li>That is, the output of each sub-layer is LayerNorm(x + Sublayer(x)), where <font color=orangered>Sublayer</font>(x) is the function implemented by the sub-layer itself.<span style="font-size:80%;opacity:0.8">  也就是说，每个子层的输出是LayerNorm(x + Sublayer(x))，其中Sublayer(x) 是由子层本身实现的函数。</span></li></ul>
 </td>
</tr>
<tr>
<td> 68 </td> <td> dmodel </td> <td>  </td> <td> 
<ul><li>To facilitate these residual connections, all sub-layers in the model, as well as the embedding layers, produce outputs of dimension <font color=forestgreen>dmodel</font> = 512.<span style="font-size:80%;opacity:0.8">  为了方便这些残差连接，模型中的所有子层以及嵌入层产生的输出维度都为dmodel = 512。</span></li><li>Similarly to other sequence transduction models, we use learned embeddings to convert the input tokens and output tokens to vectors of dimension <font color=forestgreen>dmodel</font>.<span style="font-size:80%;opacity:0.8"> 与其他序列转导模型类似，我们使用学习到的嵌入将输入词符和输出词符转换为维度为dmodel的向量。</span></li><li>The positional encodings have the same dimension <font color=forestgreen>dmodel</font> as the embeddings, so that the two can be summed.<span style="font-size:80%;opacity:0.8">  位置编码和嵌入的维度dmodel相同，所以它们俩可以相加。</span></li><li>We trained a 4-layer transformer with <font color=forestgreen>dmodel</font> = 1024 on the Wall Street Journal (WSJ) portion of the Penn Treebank [25], about 40K training sentences.<span style="font-size:80%;opacity:0.8"> 我们用dmodel = 1024 在Penn Treebank[25]的Wall Street Journal（WSJ）部分训练了一个4层transformer，约40K个训练句子。</span></li></ul>
 </td>
</tr>
<tr>
<td> 69 </td> <td> embeddings </td> <td> [ɪm'bɛd] </td> <td> 
<ul><li>This masking, combined with fact that the output <font color=orangered>embeddings</font> are offset by one position, ensures that the predictions for position i can depend only on the known outputs at positions less than i.<span style="font-size:80%;opacity:0.8">  这种掩码结合将输出嵌入偏移一个位置，确保对位置的预测 i 只能依赖小于i 的已知输出。</span></li><li>3.4 <font color=orangered>Embeddings</font> and Softmax<span style="font-size:80%;opacity:0.8"> 3.4 嵌入和Softmax</span></li><li>Similarly to other sequence transduction models, we use learned <font color=orangered>embeddings</font> to convert the input tokens and output tokens to vectors of dimension dmodel.<span style="font-size:80%;opacity:0.8"> 与其他序列转导模型类似，我们使用学习到的嵌入将输入词符和输出词符转换为维度为dmodel的向量。</span></li><li>To this end, we add &quot;positional encodings&quot; to the input <font color=orangered>embeddings</font> at the bottoms of the encoder and decoder stacks.<span style="font-size:80%;opacity:0.8">  为此，我们将“位置编码”添加到编码器和解码器堆栈底部的输入嵌入中。</span></li><li>The positional encodings have the same dimension dmodel as the <font color=orangered>embeddings</font>, so that the two can be summed.<span style="font-size:80%;opacity:0.8">  位置编码和嵌入的维度dmodel相同，所以它们俩可以相加。</span></li><li>We also experimented with using learned positional <font color=orangered>embeddings</font> [9] instead, and found that the two versions produced nearly identical results (see Table 3 row (E)).<span style="font-size:80%;opacity:0.8"> 我们还使用学习到的位置嵌入9进行了试验，发现这两个版本产生几乎相同的结果（参见表 3 行(E)）。</span></li><li>In addition, we apply dropout to the sums of the <font color=orangered>embeddings</font> and the positional encodings in both the encoder and decoder stacks.<span style="font-size:80%;opacity:0.8">  此外，在编码器和解码器堆栈中，我们将丢弃应用到嵌入和位置编码的和。</span></li><li>In row (E) we replace our sinusoidal positional encoding with learned positional <font color=orangered>embeddings</font> [9], and observe nearly identical results to the base model.<span style="font-size:80%;opacity:0.8">  在行（E）中，我们用学习到的位置嵌入[9]来替换我们的正弦位置编码，并观察到与基本模型几乎相同的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 70 </td> <td> key-value </td> <td> [!≈ ki: ˈvælju:] </td> <td> 
<ul><li>An attention function can be described as mapping a query and a set of <font color=orangered>key-value</font> pairs to an output, where the query, keys, values, and output are all vectors.<span style="font-size:80%;opacity:0.8"> Attention函数可以描述为将query和一组key-value对映射到输出，其中query、key、value和输出都是向量。</span></li></ul>
 </td>
</tr>
<tr>
<td> 71 </td> <td> additive </td> <td> [ˈædətɪv] </td> <td> 
<ul><li>The two most commonly used attention functions are <font color=orangered>additive</font> attention [2], and dot-product (multiplicative) attention.<span style="font-size:80%;opacity:0.8"> 两个最常用的attention函数是加法attention[2]和点积（乘法）attention。</span></li><li><font color=orangered>Additive</font> attention computes the compatibility function using a feed-forward network with a single hidden layer.<span style="font-size:80%;opacity:0.8">  加法attention使用具有单个隐藏层的前馈网络计算兼容性函数。</span></li><li>While for small values of $d_k$ the two mechanisms perform similarly, <font color=orangered>additive</font> attention outperforms dot product attention without scaling for larger values of $d_k$ [3].<span style="font-size:80%;opacity:0.8"> 当dk的值比较小的时候，这两个机制的性能相差相近，当dk比较大时，加法attention比不带缩放的点积attention性能好[3]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 72 </td> <td> multiplicative </td> <td> ['mʌltɪplɪkeɪtɪv] </td> <td> 
<ul><li>The two most commonly used attention functions are additive attention [2], and dot-product (<font color=orangered>multiplicative</font>) attention.<span style="font-size:80%;opacity:0.8"> 两个最常用的attention函数是加法attention[2]和点积（乘法）attention。</span></li></ul>
 </td>
</tr>
<tr>
<td> 73 </td> <td> space-efficient </td> <td> [!≈ speɪs ɪˈfɪʃnt] </td> <td> 
<ul><li>While the two are similar in theoretical complexity, dot-product attention is much faster and more <font color=orangered>space-efficient</font> in practice, since it can be implemented using highly optimized matrix multiplication code.<span style="font-size:80%;opacity:0.8">  虽然两者在理论上的复杂性相似，但在实践中点积attention的速度更快、更节省空间，因为它可以使用高度优化的矩阵乘法代码来实现。</span></li></ul>
 </td>
</tr>
<tr>
<td> 74 </td> <td> multiplication </td> <td> [ˌmʌltɪplɪˈkeɪʃn] </td> <td> 
<ul><li>While the two are similar in theoretical complexity, dot-product attention is much faster and more space-efficient in practice, since it can be implemented using highly optimized matrix <font color=orangered>multiplication</font> code.<span style="font-size:80%;opacity:0.8">  虽然两者在理论上的复杂性相似，但在实践中点积attention的速度更快、更节省空间，因为它可以使用高度优化的矩阵乘法代码来实现。</span></li></ul>
 </td>
</tr>
<tr>
<td> 75 </td> <td> dk </td> <td> ['di:k'eɪ] </td> <td> 
<ul><li>We suspect that for large values of <font color=orangered>dk</font>, the dot products grow large in magnitude, pushing the softmax function into regions where it has extremely small gradients (To illustrate why the dot products get large, assume that the components of q and k are independent random variables with mean 0 and variance 1.<span style="font-size:80%;opacity:0.8">  我们怀疑，对于很大的dk值，点积大幅度增长，将softmax函数推向具有极小梯度的区域(4为了说明点积为什么变大，假设q和k的组成是均值为0和方差为1的独立随机变量。</span></li><li>Then their dot product, q ⋅ k = ∑ i=1dk qiki, has mean 0 and variance <font color=orangered>dk</font>).<span style="font-size:80%;opacity:0.8">  那么它们的点积q ⋅ k = ∑ i=1dk qi ki 的均值为0，方差为dk)。</span></li><li>In Table 3 rows (B), we observe that reducing the attention key size <font color=orangered>dk</font> hurts model quality.<span style="font-size:80%;opacity:0.8"> 在表3行（B）中，我们观察到减小key的大小dk会有损模型质量。</span></li></ul>
 </td>
</tr>
<tr>
<td> 76 </td> <td> variance </td> <td> [ˈveəriəns] </td> <td> 
<ul><li>We suspect that for large values of dk, the dot products grow large in magnitude, pushing the softmax function into regions where it has extremely small gradients (To illustrate why the dot products get large, assume that the components of q and k are independent random variables with mean 0 and <font color=orangered>variance</font> 1.<span style="font-size:80%;opacity:0.8">  我们怀疑，对于很大的dk值，点积大幅度增长，将softmax函数推向具有极小梯度的区域(4为了说明点积为什么变大，假设q和k的组成是均值为0和方差为1的独立随机变量。</span></li><li>Then their dot product, q ⋅ k = ∑ i=1dk qiki, has mean 0 and <font color=orangered>variance</font> dk).<span style="font-size:80%;opacity:0.8">  那么它们的点积q ⋅ k = ∑ i=1dk qi ki 的均值为0，方差为dk)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 77 </td> <td> qiki </td> <td>  </td> <td> 
<ul><li>Then their dot product, q ⋅ k = ∑ i=1dk <font color=forestgreen>qiki</font>, has mean 0 and variance dk).<span style="font-size:80%;opacity:0.8">  那么它们的点积q ⋅ k = ∑ i=1dk qi ki 的均值为0，方差为dk)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 78 </td> <td> model-dimensional </td> <td> [!≈ ˈmɒdl dɪ'menʃənəl] </td> <td> 
<ul><li>Instead of performing a single attention function with $d$ <font color=orangered>model-dimensional</font> keys, values and queries, we found it beneficial to linearly project the queries, keys and values $h$ times with different, learned linear projections to $d_k$, $d_k$ and $d_v$ dimensions, respectively.<span style="font-size:80%;opacity:0.8"> 我们发现将query、key和value分别用不同的、学到的线性映射h倍到dk、dk和dv维效果更好，而不是用d model维的query、key和value执行单个attention函数。</span></li></ul>
 </td>
</tr>
<tr>
<td> 79 </td> <td> concatenate </td> <td> [kɒn'kætɪneɪt] </td> <td> 
<ul><li>These are <font color=orangered>concatenated</font> and once again projected, resulting in the final values, as depicted in Figure 2.<span style="font-size:80%;opacity:0.8">  将它们连接并再次映射，产生最终值，如图所示 2。</span></li></ul>
 </td>
</tr>
<tr>
<td> 80 </td> <td> jointly </td> <td> [dʒɔɪntlɪ] </td> <td> 
<ul><li>Multi-head attention allows the model to <font color=orangered>jointly</font> attend to information from different representation subspaces at different positions.<span style="font-size:80%;opacity:0.8"> Multi-head attention允许模型的不同表示子空间联合关注不同位置的信息。</span></li></ul>
 </td>
</tr>
<tr>
<td> 81 </td> <td> mimic </td> <td> [ˈmɪmɪk] </td> <td> 
<ul><li>This <font color=orangered>mimics</font> the typical encoder-decoder attention mechanisms in sequence-to-sequence models such as [38, 2, 9].<span style="font-size:80%;opacity:0.8">  这模仿序列到序列模型中典型的编码器—解码器的attention机制，例如[38, 2, 9]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 82 </td> <td> leftward </td> <td> [ˈleftwəd] </td> <td> 
<ul><li>We need to prevent <font color=orangered>leftward</font> information flow in the decoder to preserve the auto-regressive property.<span style="font-size:80%;opacity:0.8">  我们需要防止解码器中的向左信息流来保持自回归属性。</span></li></ul>
 </td>
</tr>
<tr>
<td> 83 </td> <td> identically </td> <td> [aɪ'dentɪklɪ] </td> <td> 
<ul><li>In addition to attention sub-layers, each of the layers in our encoder and decoder contains a fully connected feed-forward network, which is applied to each position separately and <font color=orangered>identically</font>.<span style="font-size:80%;opacity:0.8"> 除了attention子层之外，我们的编码器和解码器中的每个层都包含一个完全连接的前馈网络，该前馈网络单独且相同地应用于每个位置。</span></li></ul>
 </td>
</tr>
<tr>
<td> 84 </td> <td> inner-layer </td> <td> [!≈ ˈɪnə(r) ˈleɪə(r)] </td> <td> 
<ul><li>The dimensionality of input and output is $d_{model} = 512$, and the <font color=orangered>inner-layer</font> has dimensionality $d_{ff} = 2048$.<span style="font-size:80%;opacity:0.8">  输入和输出的维度为dmodel = 512，内部层的维度为dff = 2048。</span></li></ul>
 </td>
</tr>
<tr>
<td> 85 </td> <td> next-token </td> <td> [!≈ nekst ˈtəʊkən] </td> <td> 
<ul><li>We also use the usual learned linear transformation and softmax function to convert the decoder output to predicted <font color=orangered>next-token</font> probabilities.<span style="font-size:80%;opacity:0.8">  我们还使用普通的线性变换和softmax函数将解码器输出转换为预测的下一个词符的概率。</span></li></ul>
 </td>
</tr>
<tr>
<td> 86 </td> <td> positional </td> <td> [pəˈzɪʃənəl] </td> <td> 
<ul><li>3.5 <font color=orangered>Positional</font> Encoding<span style="font-size:80%;opacity:0.8"> 3.5 位置编码</span></li><li>To this end, we add &quot;<font color=orangered>positional</font> encodings&quot; to the input embeddings at the bottoms of the encoder and decoder stacks.<span style="font-size:80%;opacity:0.8">  为此，我们将“位置编码”添加到编码器和解码器堆栈底部的输入嵌入中。</span></li><li>The <font color=orangered>positional</font> encodings have the same dimension dmodel as the embeddings, so that the two can be summed.<span style="font-size:80%;opacity:0.8">  位置编码和嵌入的维度dmodel相同，所以它们俩可以相加。</span></li><li>There are many choices of <font color=orangered>positional</font> encodings, learned and fixed [9].<span style="font-size:80%;opacity:0.8">  有多种位置编码可以选择，例如通过学习得到的位置编码和固定的位置编码[9]。</span></li><li>That is, each dimension of the <font color=orangered>positional</font> encoding corresponds to a sinusoid.<span style="font-size:80%;opacity:0.8">  也就是说，位置编码的每个维度对应于一个正弦曲线。</span></li><li>We also experimented with using learned <font color=orangered>positional</font> embeddings [9] instead, and found that the two versions produced nearly identical results (see Table 3 row (E)).<span style="font-size:80%;opacity:0.8"> 我们还使用学习到的位置嵌入9进行了试验，发现这两个版本产生几乎相同的结果（参见表 3 行(E)）。</span></li><li>In addition, we apply dropout to the sums of the embeddings and the <font color=orangered>positional</font> encodings in both the encoder and decoder stacks.<span style="font-size:80%;opacity:0.8">  此外，在编码器和解码器堆栈中，我们将丢弃应用到嵌入和位置编码的和。</span></li><li>In row (E) we replace our sinusoidal <font color=orangered>positional</font> encoding with learned positional embeddings [9], and observe nearly identical results to the base model.<span style="font-size:80%;opacity:0.8">  在行（E）中，我们用学习到的位置嵌入[9]来替换我们的正弦位置编码，并观察到与基本模型几乎相同的结果。</span></li><li>In row (E) we replace our sinusoidal positional encoding with learned <font color=orangered>positional</font> embeddings [9], and observe nearly identical results to the base model.<span style="font-size:80%;opacity:0.8">  在行（E）中，我们用学习到的位置嵌入[9]来替换我们的正弦位置编码，并观察到与基本模型几乎相同的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 87 </td> <td> encodings </td> <td> [!≈ ɪn'kəʊdɪŋz] </td> <td> 
<ul><li>To this end, we add &quot;positional <font color=orangered>encodings</font>&quot; to the input embeddings at the bottoms of the encoder and decoder stacks.<span style="font-size:80%;opacity:0.8">  为此，我们将“位置编码”添加到编码器和解码器堆栈底部的输入嵌入中。</span></li><li>The positional <font color=orangered>encodings</font> have the same dimension dmodel as the embeddings, so that the two can be summed.<span style="font-size:80%;opacity:0.8">  位置编码和嵌入的维度dmodel相同，所以它们俩可以相加。</span></li><li>There are many choices of positional <font color=orangered>encodings</font>, learned and fixed [9].<span style="font-size:80%;opacity:0.8">  有多种位置编码可以选择，例如通过学习得到的位置编码和固定的位置编码[9]。</span></li><li>In addition, we apply dropout to the sums of the embeddings and the positional <font color=orangered>encodings</font> in both the encoder and decoder stacks.<span style="font-size:80%;opacity:0.8">  此外，在编码器和解码器堆栈中，我们将丢弃应用到嵌入和位置编码的和。</span></li></ul>
 </td>
</tr>
<tr>
<td> 88 </td> <td> sine </td> <td> [saɪn] </td> <td> 
<ul><li>In this work, we use <font color=orangered>sine</font> and cosine functions of different frequencies:<span style="font-size:80%;opacity:0.8"> 在这项工作中，我们使用不同频率的正弦和余弦函数：</span></li></ul>
 </td>
</tr>
<tr>
<td> 89 </td> <td> cosine </td> <td> [ˈkəʊsaɪn] </td> <td> 
<ul><li>In this work, we use sine and <font color=orangered>cosine</font> functions of different frequencies:<span style="font-size:80%;opacity:0.8"> 在这项工作中，我们使用不同频率的正弦和余弦函数：</span></li></ul>
 </td>
</tr>
<tr>
<td> 90 </td> <td> sinusoid </td> <td> ['saɪnəsɔɪd] </td> <td> 
<ul><li>That is, each dimension of the positional encoding corresponds to a <font color=orangered>sinusoid</font>.<span style="font-size:80%;opacity:0.8">  也就是说，位置编码的每个维度对应于一个正弦曲线。</span></li></ul>
 </td>
</tr>
<tr>
<td> 91 </td> <td> geometric </td> <td> [ˌdʒi:əˈmetrɪk] </td> <td> 
<ul><li>The wavelengths form a <font color=orangered>geometric</font> progression from $2\pi$ to $10000 \cdot 2\pi$.<span style="font-size:80%;opacity:0.8">  这些波长形成一个几何级数，从2π 到10000 ⋅ 2π。</span></li></ul>
 </td>
</tr>
<tr>
<td> 92 </td> <td> progression </td> <td> [prəˈgreʃn] </td> <td> 
<ul><li>The wavelengths form a geometric <font color=orangered>progression</font> from $2\pi$ to $10000 \cdot 2\pi$.<span style="font-size:80%;opacity:0.8">  这些波长形成一个几何级数，从2π 到10000 ⋅ 2π。</span></li></ul>
 </td>
</tr>
<tr>
<td> 93 </td> <td> hypothesize </td> <td> [haɪˈpɒθəsaɪz] </td> <td> 
<ul><li>We chose this function because we <font color=orangered>hypothesized</font> it would allow the model to easily learn to attend by relative positions, since for any fixed offset $k$, $PE_{pos+k}$ can be represented as a linear function of $PE_{pos}$.<span style="font-size:80%;opacity:0.8">  我们选择这个函数是因为我们假设它允许模型很容易学习对相对位置的关注，因为对任意确定的偏移k, PEpos+k可以表示为PEpos的线性函数。</span></li></ul>
 </td>
</tr>
<tr>
<td> 94 </td> <td> sinusoidal </td> <td> [ˌsɪnə'sɔɪdl] </td> <td> 
<ul><li>We chose the <font color=orangered>sinusoidal</font> version because it may allow the model to extrapolate to sequence lengths longer than the ones encountered during training.<span style="font-size:80%;opacity:0.8">  我们选择了正弦曲线，因为它可以允许模型推断比训练期间遇到的更长的序列。</span></li><li>In row (E) we replace our <font color=orangered>sinusoidal</font> positional encoding with learned positional embeddings [9], and observe nearly identical results to the base model.<span style="font-size:80%;opacity:0.8">  在行（E）中，我们用学习到的位置嵌入[9]来替换我们的正弦位置编码，并观察到与基本模型几乎相同的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 95 </td> <td> extrapolate </td> <td> [ɪkˈstræpəleɪt] </td> <td> 
<ul><li>We chose the sinusoidal version because it may allow the model to <font color=orangered>extrapolate</font> to sequence lengths longer than the ones encountered during training.<span style="font-size:80%;opacity:0.8">  我们选择了正弦曲线，因为它可以允许模型推断比训练期间遇到的更长的序列。</span></li></ul>
 </td>
</tr>
<tr>
<td> 96 </td> <td> variable-length </td> <td> ['veərɪəbll'eŋθ] </td> <td> 
<ul><li>In this section we compare various aspects of self-attention layers to the recurrent and convolutional layers commonly used for mapping one <font color=orangered>variable-length</font> sequence of symbol representations $(x_1,\cdots,x_n)$ to another sequence of equal length $(z_1,\cdots,z_n)$, with $x_i$, $z_i \in \mathbb R^d$, such as a hidden layer in a typical sequence transduction encoder or decoder.<span style="font-size:80%;opacity:0.8"> 本节，我们比较self-attention与循环层和卷积层的各个方面，它们通常用于映射变长的符号序列表示(x1,...,xn) 到另一个等长的序列(z1,...,zn)，其中xi,zi ∈ ℝd，例如一个典型的序列转导编码器或解码器中的隐藏层。</span></li></ul>
 </td>
</tr>
<tr>
<td> 97 </td> <td> desiderata </td> <td> [dɪˌzɪdə'reɪtə] </td> <td> 
<ul><li>Motivating our use of self-attention we consider three <font color=orangered>desiderata</font>.<span style="font-size:80%;opacity:0.8">  我们使用self-attention是考虑到解决三个问题。</span></li></ul>
 </td>
</tr>
<tr>
<td> 98 </td> <td> parallelized </td> <td> ['pærəlelaɪz] </td> <td> 
<ul><li>Another is the amount of computation that can be <font color=orangered>parallelized</font>, as measured by the minimum number of sequential operations required.<span style="font-size:80%;opacity:0.8">  另一个是可以并行的计算量，以所需的最小顺序操作的数量来衡量。</span></li></ul>
 </td>
</tr>
<tr>
<td> 99 </td> <td> long-range </td> <td> [lɒŋ reɪndʒ] </td> <td> 
<ul><li>The third is the path length between <font color=orangered>long-range</font> dependencies in the network.<span style="font-size:80%;opacity:0.8"> 第三个是网络中长距离依赖之间的路径长度。</span></li><li>Learning <font color=orangered>long-range</font> dependencies is a key challenge in many sequence transduction tasks.<span style="font-size:80%;opacity:0.8">  学习长距离依赖性是许多序列转导任务中的关键挑战。</span></li><li>The shorter these paths between any combination of positions in the input and output sequences, the easier it is to learn <font color=orangered>long-range</font> dependencies [12].<span style="font-size:80%;opacity:0.8">  输入和输出序列中任意位置组合之间的这些路径越短，学习远距离依赖性就越容易[12]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 100 </td> <td> traverse </td> <td> [trəˈvɜ:s] </td> <td> 
<ul><li>One key factor affecting the ability to learn such dependencies is the length of the paths forward and backward signals have to <font color=orangered>traverse</font> in the network.<span style="font-size:80%;opacity:0.8">  影响学习这种依赖性能力的一个关键因素是前向和后向信号必须在网络中传播的路径长度。</span></li></ul>
 </td>
</tr>
<tr>
<td> 101 </td> <td> sequentially </td> <td> [sɪ'kwenʃəlɪ] </td> <td> 
<ul><li>As noted in Table 1, a self-attention layer connects all positions with a constant number of <font color=orangered>sequentially</font> executed operations, whereas a recurrent layer requires $O(n)$ sequential operations.<span style="font-size:80%;opacity:0.8"> 如表1所示，self-attention层将所有位置连接到恒定数量的顺序执行的操作，而循环层需要O(n) 顺序操作。</span></li></ul>
 </td>
</tr>
<tr>
<td> 102 </td> <td> word-piece </td> <td> [!≈ wɜ:d pi:s] </td> <td> 
<ul><li>In terms of computational complexity, self-attention layers are faster than recurrent layers when the sequence length n is smaller than the representation dimensionality d, which is most often the case with sentence representations used by state-of-the-art models in machine translations, such as <font color=orangered>word-piece</font> [38] and byte-pair [31] representations.<span style="font-size:80%;opacity:0.8">  在计算复杂性方面，当序列长度n 小于表示维度d 时，self-attention层比循环层快，这是机器翻译中最先进的模型最常见情况，例如单词[38]表示法和字节对[31]表示法。</span></li><li>For English-French, we used the significantly larger WMT 2014 English-French dataset consisting of 36M sentences and split tokens into a 32000 <font color=orangered>word-piece</font> vocabulary [38].<span style="font-size:80%;opacity:0.8">  对于英语-法语翻译，我们使用大得多的WMT 2014英法数据集，它包含3600万个句子，并将词符分成32000个word-piece词汇表[38]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 103 </td> <td> byte-pair </td> <td> [!≈ baɪt peə(r)] </td> <td> 
<ul><li>In terms of computational complexity, self-attention layers are faster than recurrent layers when the sequence length n is smaller than the representation dimensionality d, which is most often the case with sentence representations used by state-of-the-art models in machine translations, such as word-piece [38] and <font color=orangered>byte-pair</font> [31] representations.<span style="font-size:80%;opacity:0.8">  在计算复杂性方面，当序列长度n 小于表示维度d 时，self-attention层比循环层快，这是机器翻译中最先进的模型最常见情况，例如单词[38]表示法和字节对[31]表示法。</span></li><li>Sentences were encoded using <font color=orangered>byte-pair</font> encoding [3], which has a shared source-target vocabulary of about 37000 tokens.<span style="font-size:80%;opacity:0.8">  这些句子使用字节对编码[3]进行编码，源语句和目标语句共享大约37000个词符的词汇表。</span></li><li>All metrics are on the English-to-German translation development set, newstest2013. Listed perplexities are per-wordpiece, according to our <font color=orangered>byte-pair</font> encoding, and should not be compared to per-word perplexities.<span style="font-size:80%;opacity:0.8">  Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.</span></li></ul>
 </td>
</tr>
<tr>
<td> 104 </td> <td> contiguous </td> <td> [kənˈtɪgjuəs] </td> <td> 
<ul><li>Doing so requires a stack of $O(n/k)$ convolutional layers in the case of <font color=orangered>contiguous</font> kernels, or O(logk(n)) in the case of dilated convolutions [18], increasing the length of the longest paths between any two positions in the network.<span style="font-size:80%;opacity:0.8">  要这么做，在邻近核的情况下需要O(n∕k) 个卷积层， 在扩展卷积的情况下需要O(logk(n)) 个层[18]，它们增加了网络中任意两个位置之间的最长路径的长度。</span></li></ul>
 </td>
</tr>
<tr>
<td> 105 </td> <td> logk </td> <td>  </td> <td> 
<ul><li>Doing so requires a stack of $O(n/k)$ convolutional layers in the case of contiguous kernels, or O(<font color=forestgreen>logk</font>(n)) in the case of dilated convolutions [18], increasing the length of the longest paths between any two positions in the network.<span style="font-size:80%;opacity:0.8">  要这么做，在邻近核的情况下需要O(n∕k) 个卷积层， 在扩展卷积的情况下需要O(logk(n)) 个层[18]，它们增加了网络中任意两个位置之间的最长路径的长度。</span></li></ul>
 </td>
</tr>
<tr>
<td> 106 </td> <td> dilate </td> <td> [daɪˈleɪt] </td> <td> 
<ul><li>Doing so requires a stack of $O(n/k)$ convolutional layers in the case of contiguous kernels, or O(logk(n)) in the case of <font color=orangered>dilated</font> convolutions [18], increasing the length of the longest paths between any two positions in the network.<span style="font-size:80%;opacity:0.8">  要这么做，在邻近核的情况下需要O(n∕k) 个卷积层， 在扩展卷积的情况下需要O(logk(n)) 个层[18]，它们增加了网络中任意两个位置之间的最长路径的长度。</span></li></ul>
 </td>
</tr>
<tr>
<td> 107 </td> <td> separable </td> <td> [ˈsepərəbl] </td> <td> 
<ul><li><font color=orangered>Separable</font> convolutions [6], however, decrease the complexity considerably, to $O(k\cdot n \cdot d + n\cdot d^2)$.<span style="font-size:80%;opacity:0.8"> 然而，可分卷积[6]大幅减少复杂度到O(k ⋅n⋅d + n⋅d2)。</span></li><li>Even with $k = n$, however, the complexity of a <font color=orangered>separable</font> convolution is equal to the combination of a self-attention layer and a point-wise feed-forward layer, the approach we take in our model.<span style="font-size:80%;opacity:0.8">  然而，即使k = n，一个可分卷积的复杂度等同于self-attention层和point-wise前向层的组合，即我们的模型采用的方法。</span></li></ul>
 </td>
</tr>
<tr>
<td> 108 </td> <td> interpretable </td> <td> [ɪn'tɜ:prɪtəbl] </td> <td> 
<ul><li>As side benefit, self-attention could yield more <font color=orangered>interpretable</font> models.<span style="font-size:80%;opacity:0.8"> 间接的好处是self-attention可以产生更可解释的模型。</span></li></ul>
 </td>
</tr>
<tr>
<td> 109 </td> <td> syntactic </td> <td> [sɪnˈtæktɪk] </td> <td> 
<ul><li>Not only do individual attention heads clearly learn to perform different tasks, many appear to exhibit behavior related to the <font color=orangered>syntactic</font> and semantic structure of the sentences.<span style="font-size:80%;opacity:0.8">  每个attention head不仅清楚地学习到执行不同的任务，许多似乎展现与句子的句法和语义结构的行为。</span></li></ul>
 </td>
</tr>
<tr>
<td> 110 </td> <td> semantic </td> <td> [sɪˈmæntɪk] </td> <td> 
<ul><li>Not only do individual attention heads clearly learn to perform different tasks, many appear to exhibit behavior related to the syntactic and <font color=orangered>semantic</font> structure of the sentences.<span style="font-size:80%;opacity:0.8">  每个attention head不仅清楚地学习到执行不同的任务，许多似乎展现与句子的句法和语义结构的行为。</span></li></ul>
 </td>
</tr>
<tr>
<td> 111 </td> <td> English-German </td> <td> [!≈ 'iŋgliʃ ˈdʒɜ:mən] </td> <td> 
<ul><li>We trained on the standard WMT 2014 <font color=orangered>English-German</font> dataset consisting of about 4.5 million sentence pairs.<span style="font-size:80%;opacity:0.8"> 我们在标准的WMT 2014英语-德语数据集上进行了训练，其中包含约450万个句子对。</span></li></ul>
 </td>
</tr>
<tr>
<td> 112 </td> <td> source-target </td> <td> [!≈ sɔ:s ˈtɑ:gɪt] </td> <td> 
<ul><li>Sentences were encoded using byte-pair encoding [3], which has a shared <font color=orangered>source-target</font> vocabulary of about 37000 tokens.<span style="font-size:80%;opacity:0.8">  这些句子使用字节对编码[3]进行编码，源语句和目标语句共享大约37000个词符的词汇表。</span></li></ul>
 </td>
</tr>
<tr>
<td> 113 </td> <td> English-French </td> <td> [!≈ 'iŋgliʃ frentʃ] </td> <td> 
<ul><li>For <font color=orangered>English-French</font>, we used the significantly larger WMT 2014 English-French dataset consisting of 36M sentences and split tokens into a 32000 word-piece vocabulary [38].<span style="font-size:80%;opacity:0.8">  对于英语-法语翻译，我们使用大得多的WMT 2014英法数据集，它包含3600万个句子，并将词符分成32000个word-piece词汇表[38]。</span></li><li>For English-French, we used the significantly larger WMT 2014 <font color=orangered>English-French</font> dataset consisting of 36M sentences and split tokens into a 32000 word-piece vocabulary [38].<span style="font-size:80%;opacity:0.8">  对于英语-法语翻译，我们使用大得多的WMT 2014英法数据集，它包含3600万个句子，并将词符分成32000个word-piece词汇表[38]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 114 </td> <td> NVIDIA </td> <td> [ɪn'vɪdɪə] </td> <td> 
<ul><li>We trained our models on one machine with 8 <font color=orangered>NVIDIA</font> P100 GPUs.<span style="font-size:80%;opacity:0.8"> 我们在一台具有8个NVIDIA P100 GPU的机器上训练我们的模型。</span></li></ul>
 </td>
</tr>
<tr>
<td> 115 </td> <td> hyperparameters </td> <td>  </td> <td> 
<ul><li>For our base models using the <font color=forestgreen>hyperparameters</font> described throughout the paper, each training step took about 0.4 seconds.<span style="font-size:80%;opacity:0.8">  使用本文描述的超参数的基础模型，每个训练步骤耗时约0.4秒。</span></li><li>These <font color=forestgreen>hyperparameters</font> were chosen after experimentation on the development set.<span style="font-size:80%;opacity:0.8">  这些超参数是在开发集上进行实验后选定的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 116 </td> <td> optimizer </td> <td> ['ɑ:ptɪmaɪzər] </td> <td> 
<ul><li>5.3 <font color=orangered>Optimizer</font><span style="font-size:80%;opacity:0.8"> 5.3 优化器</span></li><li>We used the Adam <font color=orangered>optimizer</font> [20] with $\beta_1 = 0.9$, $\beta_2 = 0.98$ and $\epsilon = 10^{-9}$.<span style="font-size:80%;opacity:0.8"> 我们使用Adam优化器[20]，其中$\beta_1 = 0.9$, $\beta_2 = 0.98$及$\epsilon = 10^{-9}$。</span></li></ul>
 </td>
</tr>
<tr>
<td> 117 </td> <td> proportionally </td> <td> [prə'pɔ:ʃənlɪ] </td> <td> 
<ul><li>This corresponds to increasing the learning rate linearly for the first warmup_steps training steps, and decreasing it thereafter <font color=orangered>proportionally</font> to the inverse square root of the step number.<span style="font-size:80%;opacity:0.8"> 这对应于在第一次warmup_steps 步骤中线性地增加学习速率，并且随后将其与步骤数的平方根成比例地减小。</span></li></ul>
 </td>
</tr>
<tr>
<td> 118 </td> <td> inverse </td> <td> [ˌɪnˈvɜ:s] </td> <td> 
<ul><li>This corresponds to increasing the learning rate linearly for the first warmup_steps training steps, and decreasing it thereafter proportionally to the <font color=orangered>inverse</font> square root of the step number.<span style="font-size:80%;opacity:0.8"> 这对应于在第一次warmup_steps 步骤中线性地增加学习速率，并且随后将其与步骤数的平方根成比例地减小。</span></li></ul>
 </td>
</tr>
<tr>
<td> 119 </td> <td> normalize </td> <td> [ˈnɔ:məlaɪz] </td> <td> 
<ul><li>Residual Dropout We apply dropout [33] to the output of each sub-layer, before it is added to the sub-layer input and <font color=orangered>normalized</font>.<span style="font-size:80%;opacity:0.8"> 残差丢弃 我们将丢弃[33]应用到每个子层的输出，在将它与子层的输入相加和规范化之前。</span></li></ul>
 </td>
</tr>
<tr>
<td> 120 </td> <td> perplexity </td> <td> [pəˈpleksəti] </td> <td> 
<ul><li>This hurts <font color=orangered>perplexity</font>, as the model learns to be more unsure, but improves accuracy and BLEU score.<span style="font-size:80%;opacity:0.8">  这让模型不易理解，因为模型学得更加不确定，但提高了准确性和BLEU得分。</span></li><li>All metrics are on the English-to-German translation development set, newstest2013. Listed <font color=orangered>perplexities</font> are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.<span style="font-size:80%;opacity:0.8">  Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.</span></li><li>All metrics are on the English-to-German translation development set, newstest2013. Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word <font color=orangered>perplexities</font>.<span style="font-size:80%;opacity:0.8">  Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.</span></li></ul>
 </td>
</tr>
<tr>
<td> 121 </td> <td> newstest </td> <td>  </td> <td> 
<ul><li>Table 2: The Transformer achieves better BLEU scores than previous state-of-the-art models on the English-to-German and English-to-French <font color=forestgreen>newstest</font>2014 tests at a fraction of the training cost.<span style="font-size:80%;opacity:0.8"> 表2： Transformer在英语-德语和英语-法语newstest2014测试中获得的BLEU分数比以前的最新模型的分数更好，且训练成本只是它们的一小部分。</span></li><li>All metrics are on the English-to-German translation development set, <font color=forestgreen>newstest</font>2013. Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.<span style="font-size:80%;opacity:0.8">  Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.</span></li><li>To evaluate the importance of different components of the Transformer, we varied our base model in different ways, measuring the change in performance on English-to-German translation on the development set, <font color=forestgreen>newstest</font>2013.<span style="font-size:80%;opacity:0.8"> 为了评估Transformer不同组件的重要性，我们以不同的方式改变我们的基础模型，测量开发集newstest2013上英文-德文翻译的性能变化。</span></li></ul>
 </td>
</tr>
<tr>
<td> 122 </td> <td> surpass </td> <td> [səˈpɑ:s] </td> <td> 
<ul><li>Even our base model <font color=orangered>surpasses</font> all previously published models and ensembles, at a fraction of the training cost of any of the competitive models.<span style="font-size:80%;opacity:0.8">  即使我们的基础模型也超过了以前发布的所有模型和整合模型，且训练成本只是这些模型的一小部分。</span></li></ul>
 </td>
</tr>
<tr>
<td> 123 </td> <td> Pdrop </td> <td>  </td> <td> 
<ul><li>The Transformer (big) model trained for English-to-French used dropout rate <font color=forestgreen>Pdrop</font> = 0.1, instead of 0.3.<span style="font-size:80%;opacity:0.8">  英语-法语的Transformer (big) 模型使用丢弃率为Pdrop = 0.1，而不是0.3。</span></li></ul>
 </td>
</tr>
<tr>
<td> 124 </td> <td> experimentation </td> <td> [ɪkˌsperɪmenˈteɪʃn] </td> <td> 
<ul><li>These hyperparameters were chosen after <font color=orangered>experimentation</font> on the development set.<span style="font-size:80%;opacity:0.8">  这些超参数是在开发集上进行实验后选定的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 125 </td> <td> floating-point </td> <td> ['fləʊtɪŋ'pɔɪnt] </td> <td> 
<ul><li>We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision <font color=orangered>floating-point</font> capacity of each GPU (We used values of 2.8, 3.7, 6.0 and 9.5 TFLOPS for K80, K40, M40 and P100, respectively).<span style="font-size:80%;opacity:0.8">  我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量(对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 126 </td> <td> TFLOPS </td> <td> [!≈ ti: ef el əu pi: es] </td> <td> 
<ul><li>We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision floating-point capacity of each GPU (We used values of 2.8, 3.7, 6.0 and 9.5 <font color=orangered>TFLOPS</font> for K80, K40, M40 and P100, respectively).<span style="font-size:80%;opacity:0.8">  我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量(对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 127 </td> <td> K80 </td> <td>  </td> <td> 
<ul><li>We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision floating-point capacity of each GPU (We used values of 2.8, 3.7, 6.0 and 9.5 TFLOPS for <font color=forestgreen>K80</font>, K40, M40 and P100, respectively).<span style="font-size:80%;opacity:0.8">  我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量(对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 128 </td> <td> K40 </td> <td>  </td> <td> 
<ul><li>We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision floating-point capacity of each GPU (We used values of 2.8, 3.7, 6.0 and 9.5 TFLOPS for K80, <font color=forestgreen>K40</font>, M40 and P100, respectively).<span style="font-size:80%;opacity:0.8">  我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量(对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 129 </td> <td> M40 </td> <td>  </td> <td> 
<ul><li>We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision floating-point capacity of each GPU (We used values of 2.8, 3.7, 6.0 and 9.5 TFLOPS for K80, K40, <font color=forestgreen>M40</font> and P100, respectively).<span style="font-size:80%;opacity:0.8">  我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量(对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 130 </td> <td> Unlisted </td> <td> [ˌʌnˈlɪstɪd] </td> <td> 
<ul><li><font color=orangered>Unlisted</font> values are identical to those of the base model.<span style="font-size:80%;opacity:0.8">  未列出的值与基本模型的值相同。 所有指标都基于英文到德文翻译开发集newstest2013。</span></li></ul>
 </td>
</tr>
<tr>
<td> 131 </td> <td> per-wordpiece </td> <td>  </td> <td> 
<ul><li>All metrics are on the English-to-German translation development set, newstest2013. Listed perplexities are <font color=forestgreen>per-wordpiece</font>, according to our byte-pair encoding, and should not be compared to per-word perplexities.<span style="font-size:80%;opacity:0.8">  Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.</span></li></ul>
 </td>
</tr>
<tr>
<td> 132 </td> <td> over-fitting </td> <td> [!≈ ˈəʊvə(r) ˈfɪtɪŋ] </td> <td> 
<ul><li>We further observe in rows (C) and (D) that, as expected, bigger models are better, and dropout is very helpful in avoiding <font color=orangered>over-fitting</font>.<span style="font-size:80%;opacity:0.8">  我们在行（C）和（D）中进一步观察到，如预期的那样，更大的模型更好，并且丢弃对避免过度拟合非常有帮助。</span></li></ul>
 </td>
</tr>
<tr>
<td> 133 </td> <td> WSJ </td> <td> [!≈ 'dʌblju: es dʒeɪ] </td> <td> 
<ul><li>Table 4: The Transformer generalizes well to English constituency parsing (Results are on Section 23 of <font color=orangered>WSJ</font>)<span style="font-size:80%;opacity:0.8"> 表4： The Transformer generalizes well to English constituency parsing (Results are on Section 23 of WSJ)</span></li><li>We trained a 4-layer transformer with dmodel = 1024 on the Wall Street Journal (<font color=orangered>WSJ</font>) portion of the Penn Treebank [25], about 40K training sentences.<span style="font-size:80%;opacity:0.8"> 我们用dmodel = 1024 在Penn Treebank[25]的Wall Street Journal（WSJ）部分训练了一个4层transformer，约40K个训练句子。</span></li><li>We used a vocabulary of 16K tokens for the <font color=orangered>WSJ</font> only setting and a vocabulary of 32K tokens for the semi-supervised setting.<span style="font-size:80%;opacity:0.8">  我们使用了一个16K词符的词汇表作为WSJ唯一设置，和一个32K词符的词汇表用于半监督设置。</span></li><li>In contrast to RNN sequence-to-sequence models [37], the Transformer outperforms the BerkeleyParser [29] even when training only on the <font color=orangered>WSJ</font> training set of 40K sentences.<span style="font-size:80%;opacity:0.8"> 与RNN序列到序列模型[37]相比，即使仅在WSJ训练40K句子组训练时，Transformer也胜过BerkeleyParser [29]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 134 </td> <td> small-data </td> <td> [!≈ smɔ:l ˈdeɪtə] </td> <td> 
<ul><li>Furthermore, RNN sequence-to-sequence models have not been able to attain state-of-the-art results in <font color=orangered>small-data</font> regimes [37].<span style="font-size:80%;opacity:0.8">  此外，RNN序列到序列模型还没有能够在小数据[37]中获得最好的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 135 </td> <td> Penn </td> <td> [pen] </td> <td> 
<ul><li>We trained a 4-layer transformer with dmodel = 1024 on the Wall Street Journal (WSJ) portion of the <font color=orangered>Penn</font> Treebank [25], about 40K training sentences.<span style="font-size:80%;opacity:0.8"> 我们用dmodel = 1024 在Penn Treebank[25]的Wall Street Journal（WSJ）部分训练了一个4层transformer，约40K个训练句子。</span></li></ul>
 </td>
</tr>
<tr>
<td> 136 </td> <td> Treebank </td> <td> [ˈtri:bænk] </td> <td> 
<ul><li>We trained a 4-layer transformer with dmodel = 1024 on the Wall Street Journal (WSJ) portion of the Penn <font color=orangered>Treebank</font> [25], about 40K training sentences.<span style="font-size:80%;opacity:0.8"> 我们用dmodel = 1024 在Penn Treebank[25]的Wall Street Journal（WSJ）部分训练了一个4层transformer，约40K个训练句子。</span></li></ul>
 </td>
</tr>
<tr>
<td> 137 </td> <td> semi-supervised </td> <td> [!≈ ˈsemi 'sju:pəvaɪzd] </td> <td> 
<ul><li>We also trained it in a <font color=orangered>semi-supervised</font> setting, using the larger high-confidence and BerkleyParser corpora from with approximately 17M sentences [37].<span style="font-size:80%;opacity:0.8">  我们还使用更大的高置信度和BerkleyParser语料库，在半监督环境中对其进行了训练，大约17M个句子[37]。</span></li><li>We used a vocabulary of 16K tokens for the WSJ only setting and a vocabulary of 32K tokens for the <font color=orangered>semi-supervised</font> setting.<span style="font-size:80%;opacity:0.8">  我们使用了一个16K词符的词汇表作为WSJ唯一设置，和一个32K词符的词汇表用于半监督设置。</span></li></ul>
 </td>
</tr>
<tr>
<td> 138 </td> <td> BerkleyParser </td> <td>  </td> <td> 
<ul><li>We also trained it in a semi-supervised setting, using the larger high-confidence and <font color=forestgreen>BerkleyParser</font> corpora from with approximately 17M sentences [37].<span style="font-size:80%;opacity:0.8">  我们还使用更大的高置信度和BerkleyParser语料库，在半监督环境中对其进行了训练，大约17M个句子[37]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 139 </td> <td> corpora </td> <td> [ˈkɔ:pərə] </td> <td> 
<ul><li>We also trained it in a semi-supervised setting, using the larger high-confidence and BerkleyParser <font color=orangered>corpora</font> from with approximately 17M sentences [37].<span style="font-size:80%;opacity:0.8">  我们还使用更大的高置信度和BerkleyParser语料库，在半监督环境中对其进行了训练，大约17M个句子[37]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 140 </td> <td> BerkeleyParser </td> <td>  </td> <td> 
<ul><li>In contrast to RNN sequence-to-sequence models [37], the Transformer outperforms the <font color=forestgreen>BerkeleyParser</font> [29] even when training only on the WSJ training set of 40K sentences.<span style="font-size:80%;opacity:0.8"> 与RNN序列到序列模型[37]相比，即使仅在WSJ训练40K句子组训练时，Transformer也胜过BerkeleyParser [29]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 141 </td> <td> modality </td> <td> [məʊˈdæləti] </td> <td> 
<ul><li>We plan to extend the Transformer to problems involving input and output <font color=orangered>modalities</font> other than text and to investigate local, restricted attention mechanisms to efficiently handle large inputs and outputs such as images, audio and video.<span style="font-size:80%;opacity:0.8">  我们计划将Transformer扩展到除文本之外的涉及输入和输出模式的问题，并调查局部的、受限attention机制以有效处理大型输入和输出，如图像、音频和视频。</span></li></ul>
 </td>
</tr>
<tr>
<td> 142 </td> <td> Nal </td> <td>  </td> <td> 
<ul><li>Acknowledgements We are grateful to <font color=forestgreen>Nal</font> Kalchbrenner and Stephan Gouws for their fruitful comments, corrections and inspiration.<span style="font-size:80%;opacity:0.8"> 致谢 我们感谢Nal Kalchbrenner和Stephan Gouws富有成效的评论、更正和灵感。</span></li></ul>
 </td>
</tr>
<tr>
<td> 143 </td> <td> Kalchbrenner </td> <td>  </td> <td> 
<ul><li>Acknowledgements We are grateful to Nal <font color=forestgreen>Kalchbrenner</font> and Stephan Gouws for their fruitful comments, corrections and inspiration.<span style="font-size:80%;opacity:0.8"> 致谢 我们感谢Nal Kalchbrenner和Stephan Gouws富有成效的评论、更正和灵感。</span></li></ul>
 </td>
</tr>
<tr>
<td> 144 </td> <td> Stephan </td> <td>  </td> <td> 
<ul><li>Acknowledgements We are grateful to Nal Kalchbrenner and <font color=forestgreen>Stephan</font> Gouws for their fruitful comments, corrections and inspiration.<span style="font-size:80%;opacity:0.8"> 致谢 我们感谢Nal Kalchbrenner和Stephan Gouws富有成效的评论、更正和灵感。</span></li></ul>
 </td>
</tr>
<tr>
<td> 145 </td> <td> Gouws </td> <td>  </td> <td> 
<ul><li>Acknowledgements We are grateful to Nal Kalchbrenner and Stephan <font color=forestgreen>Gouws</font> for their fruitful comments, corrections and inspiration.<span style="font-size:80%;opacity:0.8"> 致谢 我们感谢Nal Kalchbrenner和Stephan Gouws富有成效的评论、更正和灵感。</span></li></ul>
 </td>
</tr>
</table>
</div>
<div class="two-list">
<table>
<caption>
    <h2> Words List (frequency)</h2>
</caption>
<thead>
<tr>
<td> # </td> <td> word (frequency) </td> <td> phonetic </td> <td> sentence </td>
</tr>
</thead>
<tr>
<td> 1 </td> <td> transformer<br>(24) </td> <td> [trænsˈfɔ:mə(r)] </td> <td> 
<ul><li>Ashish, with Illia, designed and implemented the first <font color=orangered>Transformer</font> models and has been crucially involved in every aspect of this work.<span style="font-size:80%;opacity:0.8"> Ashish和Illia设计并实现第一个Transformer模型，并在这项工作中的各个方面起着至关重要的作用。</span></li><li>We propose a new simple network architecture, the <font color=orangered>Transformer</font>, based solely on attention mechanisms, dispensing with recurrence and convolutions entirely.<span style="font-size:80%;opacity:0.8"> 我们提出一种新的简单的网络架构Transformer，仅基于attention机制并完全避免循环和卷积。</span></li><li>We show that the <font color=orangered>Transformer</font> generalizes well to other tasks by applying it successfully to English constituency parsing both with large and limited training data.<span style="font-size:80%;opacity:0.8"> 通过在解析大量训练数据和有限训练数据的两种情况下将其应用到English constituency，我们表明Transformer可以很好地推广到其他任务。</span></li><li>In this work we propose the <font color=orangered>Transformer</font>, a model architecture eschewing recurrence and instead relying entirely on an attention mechanism to draw global dependencies between input and output.<span style="font-size:80%;opacity:0.8">在这项工作中我们提出Transformer，这种模型架构避免循环并完全依赖于attention机制来绘制输入和输出之间的全局依赖关系。</span></li><li>The <font color=orangered>Transformer</font> allows for significantly more parallelization and can reach a new state of the art in translation quality after being trained for as little as twelve hours on eight P100 GPUs.<span style="font-size:80%;opacity:0.8"> Transformer允许进行更多的并行化，并且可以在八个P100 GPU上接受少至十二小时的训练后达到翻译质量的新的最佳结果。</span></li><li>In the <font color=orangered>Transformer</font> this is reduced to a constant number of operations, albeit at the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we counteract with Multi-Head Attention as described in section 3.2.<span style="font-size:80%;opacity:0.8"> 在Transformer中，这种操作减少到固定的次数，尽管由于对用attention权重化的位置取平均降低了效果，但是我使用Multi-Head Attention进行抵消，具体描述见 3.2。</span></li><li>To the best of our knowledge, however, the <font color=orangered>Transformer</font> is the first transduction model relying entirely on self-attention to compute representations of its input and output without using sequence-aligned RNNs or convolution.<span style="font-size:80%;opacity:0.8">然而，就我们所知，Transformer是第一个完全依靠self-attention来计算输入和输出表示而不使用序列对齐RNN或卷积的转导模型。</span></li><li>In the following sections, we will describe the <font color=orangered>Transformer</font>, motivate self-attention and discuss its advantages over models such as [17, 18] and [9].<span style="font-size:80%;opacity:0.8"> 在下面的章节中，我们将描述Transformer、引出self-attention并讨论它相对[17, 18]和[9]几个模型的优势。</span></li><li>Figure 1: The <font color=orangered>Transformer</font> - model architecture.<span style="font-size:80%;opacity:0.8">图1： Transformer — 模型架构。</span></li><li>The <font color=orangered>Transformer</font> follows this overall architecture using stacked self-attention and point-wise, fully connected layers for both the encoder and decoder, shown in the left and right halves of Figure 1, respectively.<span style="font-size:80%;opacity:0.8">Transformer遵循这种整体架构，编码器和解码器都使用self-attention堆叠和point-wise、完全连接的层，分别显示在图1的左边和右边。</span></li><li>The <font color=orangered>Transformer</font> uses multi-head attention in three different ways:<span style="font-size:80%;opacity:0.8">Transformer使用以3种方式使用multi-head attention：</span></li><li>Table 2: The <font color=orangered>Transformer</font> achieves better BLEU scores than previous state-of-the-art models on the English-to-German and English-to-French newstest2014 tests at a fraction of the training cost.<span style="font-size:80%;opacity:0.8">表2： Transformer在英语-德语和英语-法语newstest2014测试中获得的BLEU分数比以前的最新模型的分数更好，且训练成本只是它们的一小部分。</span></li><li>On the WMT 2014 English-to-German translation task, the big <font color=orangered>transformer</font> model (Transformer (big) in Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0 BLEU, establishing a new state-of-the-art BLEU score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 P100 GPUs.<span style="font-size:80%;opacity:0.8">在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>On the WMT 2014 English-to-German translation task, the big transformer model (<font color=orangered>Transformer</font> (big) in Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0 BLEU, establishing a new state-of-the-art BLEU score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 P100 GPUs.<span style="font-size:80%;opacity:0.8">在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>The <font color=orangered>Transformer</font> (big) model trained for English-to-French used dropout rate Pdrop = 0.1, instead of 0.3.<span style="font-size:80%;opacity:0.8"> 英语-法语的Transformer (big) 模型使用丢弃率为Pdrop = 0.1，而不是0.3。</span></li><li>Table 3: Variations on the <font color=orangered>Transformer</font> architecture.<span style="font-size:80%;opacity:0.8">表3： Transformer架构的变体。</span></li><li>To evaluate the importance of different components of the <font color=orangered>Transformer</font>, we varied our base model in different ways, measuring the change in performance on English-to-German translation on the development set, newstest2013.<span style="font-size:80%;opacity:0.8">为了评估Transformer不同组件的重要性，我们以不同的方式改变我们的基础模型，测量开发集newstest2013上英文-德文翻译的性能变化。</span></li><li>Table 4: The <font color=orangered>Transformer</font> generalizes well to English constituency parsing (Results are on Section 23 of WSJ)<span style="font-size:80%;opacity:0.8">表4： The Transformer generalizes well to English constituency parsing (Results are on Section 23 of WSJ)</span></li><li>To evaluate if the <font color=orangered>Transformer</font> can generalize to other tasks we performed experiments on English constituency parsing. This task presents specific challenges: the output is subject to strong structural constraints and is significantly longer than the input.<span style="font-size:80%;opacity:0.8">To evaluate if the Transformer can generalize to other tasks we performed experiments on English constituency parsing. 这项任务提出特别的挑战：输出受到很强的结构性约束，并且比输入要长很多。</span></li><li>We trained a 4-layer <font color=orangered>transformer</font> with dmodel = 1024 on the Wall Street Journal (WSJ) portion of the Penn Treebank [25], about 40K training sentences.<span style="font-size:80%;opacity:0.8">我们用dmodel = 1024 在Penn Treebank[25]的Wall Street Journal（WSJ）部分训练了一个4层transformer，约40K个训练句子。</span></li><li>In contrast to RNN sequence-to-sequence models [37], the <font color=orangered>Transformer</font> outperforms the BerkeleyParser [29] even when training only on the WSJ training set of 40K sentences.<span style="font-size:80%;opacity:0.8">与RNN序列到序列模型[37]相比，即使仅在WSJ训练40K句子组训练时，Transformer也胜过BerkeleyParser [29]。</span></li><li>In this work, we presented the <font color=orangered>Transformer</font>, the first sequence transduction model based entirely on attention, replacing the recurrent layers most commonly used in encoder-decoder architectures with multi-headed self-attention.<span style="font-size:80%;opacity:0.8">在这项工作中，我们提出了Transformer，第一个完全基于关注的序列转导模型，用multi-headed self-attention取代了编码器-解码器架构中最常用的循环层。</span></li><li>For translation tasks, the <font color=orangered>Transformer</font> can be trained significantly faster than architectures based on recurrent or convolutional layers.<span style="font-size:80%;opacity:0.8">对于翻译任务，Transformer可以比基于循环或卷积层的体系结构训练更快。</span></li><li>We plan to extend the <font color=orangered>Transformer</font> to problems involving input and output modalities other than text and to investigate local, restricted attention mechanisms to efficiently handle large inputs and outputs such as images, audio and video.<span style="font-size:80%;opacity:0.8"> 我们计划将Transformer扩展到除文本之外的涉及输入和输出模式的问题，并调查局部的、受限attention机制以有效处理大型输入和输出，如图像、音频和视频。</span></li></ul>
 </td>
</tr>
<tr>
<td> 2 </td> <td> recurrent<br>(13) </td> <td> [rɪˈkʌrənt] </td> <td> 
<ul><li>The dominant sequence transduction models are based on complex <font color=orangered>recurrent</font> or convolutional neural networks that include an encoder and a decoder.<span style="font-size:80%;opacity:0.8">主流序列转导模型基于复杂的循环神经网络或卷积神经网络，这些神经网络包含一个编码器和一个解码器。</span></li><li><font color=orangered>Recurrent</font> neural networks, long short-term memory [13] and gated recurrent [7] neural networks in particular, have been firmly established as state of the art approaches in sequence modeling and transduction problems such as language modeling and machine translation [35, 2, 5].<span style="font-size:80%;opacity:0.8">在序列建模和转换问题中，如语言建模和机器翻译[35, 2, 5]，循环神经网络特别是长短期记忆[13]和门控循环[7]神经网络，已经被确立为最先进的方法。</span></li><li>Recurrent neural networks, long short-term memory [13] and gated <font color=orangered>recurrent</font> [7] neural networks in particular, have been firmly established as state of the art approaches in sequence modeling and transduction problems such as language modeling and machine translation [35, 2, 5].<span style="font-size:80%;opacity:0.8">在序列建模和转换问题中，如语言建模和机器翻译[35, 2, 5]，循环神经网络特别是长短期记忆[13]和门控循环[7]神经网络，已经被确立为最先进的方法。</span></li><li>Numerous efforts have since continued to push the boundaries of <font color=orangered>recurrent</font> language models and encoder-decoder architectures [38, 24, 15].<span style="font-size:80%;opacity:0.8"> 自那以后，许多努力一直在推动循环语言模型和编码器-解码器架构的界限[38, 24, 15]。</span></li><li><font color=orangered>Recurrent</font> models typically factor computation along the symbol positions of the input and output sequences.<span style="font-size:80%;opacity:0.8">循环模型通常是对输入和输出序列的符号位置进行因子计算。</span></li><li>In all but a few cases [27], however, such attention mechanisms are used in conjunction with a <font color=orangered>recurrent</font> network.<span style="font-size:80%;opacity:0.8"> 除少数情况外[27]，这种attention机制都与循环网络一起使用。</span></li><li>End-to-end memory networks are based on a <font color=orangered>recurrent</font> attention mechanism instead of sequence-aligned recurrence and have been shown to perform well on simple-language question answering and language modeling tasks [34].<span style="font-size:80%;opacity:0.8">端到端的记忆网络基于循环attention机制，而不是序列对齐的循环，并且已被证明在简单语言的问答和语言建模任务中表现良好[34]。</span></li><li>In this section we compare various aspects of self-attention layers to the <font color=orangered>recurrent</font> and convolutional layers commonly used for mapping one variable-length sequence of symbol representations $(x_1,\cdots,x_n)$ to another sequence of equal length $(z_1,\cdots,z_n)$, with $x_i$, $z_i \in \mathbb R^d$, such as a hidden layer in a typical sequence transduction encoder or decoder.<span style="font-size:80%;opacity:0.8">本节，我们比较self-attention与循环层和卷积层的各个方面，它们通常用于映射变长的符号序列表示(x1,...,xn) 到另一个等长的序列(z1,...,zn)，其中xi,zi ∈ ℝd，例如一个典型的序列转导编码器或解码器中的隐藏层。</span></li><li>As noted in Table 1, a self-attention layer connects all positions with a constant number of sequentially executed operations, whereas a <font color=orangered>recurrent</font> layer requires $O(n)$ sequential operations.<span style="font-size:80%;opacity:0.8">如表1所示，self-attention层将所有位置连接到恒定数量的顺序执行的操作，而循环层需要O(n) 顺序操作。</span></li><li>In terms of computational complexity, self-attention layers are faster than <font color=orangered>recurrent</font> layers when the sequence length n is smaller than the representation dimensionality d, which is most often the case with sentence representations used by state-of-the-art models in machine translations, such as word-piece [38] and byte-pair [31] representations.<span style="font-size:80%;opacity:0.8"> 在计算复杂性方面，当序列长度n 小于表示维度d 时，self-attention层比循环层快，这是机器翻译中最先进的模型最常见情况，例如单词[38]表示法和字节对[31]表示法。</span></li><li>Convolutional layers are generally more expensive than <font color=orangered>recurrent</font> layers, by a factor of k.<span style="font-size:80%;opacity:0.8"> 卷积层通常比循环层更昂贵，与因子k有关。</span></li><li>In this work, we presented the Transformer, the first sequence transduction model based entirely on attention, replacing the <font color=orangered>recurrent</font> layers most commonly used in encoder-decoder architectures with multi-headed self-attention.<span style="font-size:80%;opacity:0.8">在这项工作中，我们提出了Transformer，第一个完全基于关注的序列转导模型，用multi-headed self-attention取代了编码器-解码器架构中最常用的循环层。</span></li><li>For translation tasks, the Transformer can be trained significantly faster than architectures based on <font color=orangered>recurrent</font> or convolutional layers.<span style="font-size:80%;opacity:0.8">对于翻译任务，Transformer可以比基于循环或卷积层的体系结构训练更快。</span></li></ul>
 </td>
</tr>
<tr>
<td> 3 </td> <td> sub-layer<br>(12) </td> <td> [!≈ sʌb ˈleɪə(r)] </td> <td> 
<ul><li>Each layer has two <font color=orangered>sub-layers</font>.<span style="font-size:80%;opacity:0.8"> 每一层都有两个子层。</span></li><li>We employ a residual connection [11] around each of the two <font color=orangered>sub-layers</font>, followed by layer normalization [1].<span style="font-size:80%;opacity:0.8"> 我们对每个子层再采用一个残差连接[11] ，接着进行层标准化[1]。</span></li><li>That is, the output of each <font color=orangered>sub-layer</font> is LayerNorm(x + Sublayer(x)), where Sublayer(x) is the function implemented by the sub-layer itself.<span style="font-size:80%;opacity:0.8"> 也就是说，每个子层的输出是LayerNorm(x + Sublayer(x))，其中Sublayer(x) 是由子层本身实现的函数。</span></li><li>That is, the output of each sub-layer is LayerNorm(x + Sublayer(x)), where Sublayer(x) is the function implemented by the <font color=orangered>sub-layer</font> itself.<span style="font-size:80%;opacity:0.8"> 也就是说，每个子层的输出是LayerNorm(x + Sublayer(x))，其中Sublayer(x) 是由子层本身实现的函数。</span></li><li>To facilitate these residual connections, all <font color=orangered>sub-layers</font> in the model, as well as the embedding layers, produce outputs of dimension dmodel = 512.<span style="font-size:80%;opacity:0.8"> 为了方便这些残差连接，模型中的所有子层以及嵌入层产生的输出维度都为dmodel = 512。</span></li><li>In addition to the two <font color=orangered>sub-layers</font> in each encoder layer, the decoder inserts a third sub-layer, which performs multi-head attention over the output of the encoder stack.<span style="font-size:80%;opacity:0.8"> 除了每个编码器层中的两个子层之外，解码器还插入第三个子层，该层对编码器堆栈的输出执行multi-head attention。</span></li><li>In addition to the two sub-layers in each encoder layer, the decoder inserts a third <font color=orangered>sub-layer</font>, which performs multi-head attention over the output of the encoder stack.<span style="font-size:80%;opacity:0.8"> 除了每个编码器层中的两个子层之外，解码器还插入第三个子层，该层对编码器堆栈的输出执行multi-head attention。</span></li><li>Similar to the encoder, we employ residual connections around each of the <font color=orangered>sub-layers</font>, followed by layer normalization.<span style="font-size:80%;opacity:0.8"> 与编码器类似，我们在每个子层再采用残差连接，然后进行层标准化。</span></li><li>We also modify the self-attention <font color=orangered>sub-layer</font> in the decoder stack to prevent positions from attending to subsequent positions.<span style="font-size:80%;opacity:0.8"> 我们还修改解码器堆栈中的self-attention子层，以防止位置关注到后面的位置。</span></li><li>In addition to attention <font color=orangered>sub-layers</font>, each of the layers in our encoder and decoder contains a fully connected feed-forward network, which is applied to each position separately and identically.<span style="font-size:80%;opacity:0.8">除了attention子层之外，我们的编码器和解码器中的每个层都包含一个完全连接的前馈网络，该前馈网络单独且相同地应用于每个位置。</span></li><li>Residual Dropout We apply dropout [33] to the output of each <font color=orangered>sub-layer</font>, before it is added to the sub-layer input and normalized.<span style="font-size:80%;opacity:0.8">残差丢弃 我们将丢弃[33]应用到每个子层的输出，在将它与子层的输入相加和规范化之前。</span></li><li>Residual Dropout We apply dropout [33] to the output of each sub-layer, before it is added to the <font color=orangered>sub-layer</font> input and normalized.<span style="font-size:80%;opacity:0.8">残差丢弃 我们将丢弃[33]应用到每个子层的输出，在将它与子层的输入相加和规范化之前。</span></li></ul>
 </td>
</tr>
<tr>
<td> 4 </td> <td> transduction<br>(9) </td> <td> [træns'dʌkʃən] </td> <td> 
<ul><li>The dominant sequence <font color=orangered>transduction</font> models are based on complex recurrent or convolutional neural networks that include an encoder and a decoder.<span style="font-size:80%;opacity:0.8">主流序列转导模型基于复杂的循环神经网络或卷积神经网络，这些神经网络包含一个编码器和一个解码器。</span></li><li>Recurrent neural networks, long short-term memory [13] and gated recurrent [7] neural networks in particular, have been firmly established as state of the art approaches in sequence modeling and <font color=orangered>transduction</font> problems such as language modeling and machine translation [35, 2, 5].<span style="font-size:80%;opacity:0.8">在序列建模和转换问题中，如语言建模和机器翻译[35, 2, 5]，循环神经网络特别是长短期记忆[13]和门控循环[7]神经网络，已经被确立为最先进的方法。</span></li><li>Attention mechanisms have become an integral part of compelling sequence modeling and <font color=orangered>transduction</font> models in various tasks, allowing modeling of dependencies without regard to their distance in the input or output sequences [2, 19].<span style="font-size:80%;opacity:0.8">在各种任务中，attention机制已经成为序列建模和转导模型不可或缺的一部分，它可以建模依赖关系而不考虑其在输入或输出序列中的距离[2, 19]。</span></li><li>To the best of our knowledge, however, the Transformer is the first <font color=orangered>transduction</font> model relying entirely on self-attention to compute representations of its input and output without using sequence-aligned RNNs or convolution.<span style="font-size:80%;opacity:0.8">然而，就我们所知，Transformer是第一个完全依靠self-attention来计算输入和输出表示而不使用序列对齐RNN或卷积的转导模型。</span></li><li>Most competitive neural sequence <font color=orangered>transduction</font> models have an encoder-decoder structure [5, 2, 35].<span style="font-size:80%;opacity:0.8">大部分神经序列转导模型都有一个编码器-解码器结构[5, 2, 35]。</span></li><li>Similarly to other sequence <font color=orangered>transduction</font> models, we use learned embeddings to convert the input tokens and output tokens to vectors of dimension dmodel.<span style="font-size:80%;opacity:0.8">与其他序列转导模型类似，我们使用学习到的嵌入将输入词符和输出词符转换为维度为dmodel的向量。</span></li><li>In this section we compare various aspects of self-attention layers to the recurrent and convolutional layers commonly used for mapping one variable-length sequence of symbol representations $(x_1,\cdots,x_n)$ to another sequence of equal length $(z_1,\cdots,z_n)$, with $x_i$, $z_i \in \mathbb R^d$, such as a hidden layer in a typical sequence <font color=orangered>transduction</font> encoder or decoder.<span style="font-size:80%;opacity:0.8">本节，我们比较self-attention与循环层和卷积层的各个方面，它们通常用于映射变长的符号序列表示(x1,...,xn) 到另一个等长的序列(z1,...,zn)，其中xi,zi ∈ ℝd，例如一个典型的序列转导编码器或解码器中的隐藏层。</span></li><li>Learning long-range dependencies is a key challenge in many sequence <font color=orangered>transduction</font> tasks.<span style="font-size:80%;opacity:0.8"> 学习长距离依赖性是许多序列转导任务中的关键挑战。</span></li><li>In this work, we presented the Transformer, the first sequence <font color=orangered>transduction</font> model based entirely on attention, replacing the recurrent layers most commonly used in encoder-decoder architectures with multi-headed self-attention.<span style="font-size:80%;opacity:0.8">在这项工作中，我们提出了Transformer，第一个完全基于关注的序列转导模型，用multi-headed self-attention取代了编码器-解码器架构中最常用的循环层。</span></li></ul>
 </td>
</tr>
<tr>
<td> 5 </td> <td> BLEU<br>(9) </td> <td> [blju:] </td> <td> 
<ul><li>Our model achieves 28.4 <font color=orangered>BLEU</font> on the WMT 2014 English-to-German translation task, improving over the existing best results, including ensembles, by over 2 BLEU.<span style="font-size:80%;opacity:0.8"> 我们的模型在WMT 2014英语-德语翻译任务上达到28.4 BLEU，超过现有最佳结果（包括整合模型）2个BLEU。</span></li><li>Our model achieves 28.4 BLEU on the WMT 2014 English-to-German translation task, improving over the existing best results, including ensembles, by over 2 <font color=orangered>BLEU</font>.<span style="font-size:80%;opacity:0.8"> 我们的模型在WMT 2014英语-德语翻译任务上达到28.4 BLEU，超过现有最佳结果（包括整合模型）2个BLEU。</span></li><li>On the WMT 2014 English-to-French translation task, our model establishes a new single-model state-of-the-art <font color=orangered>BLEU</font> score of 41.8 after training for 3.5 days on eight GPUs, a small fraction of the training costs of the best models from the literature.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-法语翻译任务中，我们的模型建立了单模型新的最先进的BLEU分数41.8，它在8个GPU上训练了3.5天，这个时间只是目前文献中记载的最好的模型训练成本的一小部分。</span></li><li>This hurts perplexity, as the model learns to be more unsure, but improves accuracy and <font color=orangered>BLEU</font> score.<span style="font-size:80%;opacity:0.8"> 这让模型不易理解，因为模型学得更加不确定，但提高了准确性和BLEU得分。</span></li><li>Table 2: The Transformer achieves better <font color=orangered>BLEU</font> scores than previous state-of-the-art models on the English-to-German and English-to-French newstest2014 tests at a fraction of the training cost.<span style="font-size:80%;opacity:0.8">表2： Transformer在英语-德语和英语-法语newstest2014测试中获得的BLEU分数比以前的最新模型的分数更好，且训练成本只是它们的一小部分。</span></li><li>On the WMT 2014 English-to-German translation task, the big transformer model (Transformer (big) in Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0 <font color=orangered>BLEU</font>, establishing a new state-of-the-art BLEU score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 P100 GPUs.<span style="font-size:80%;opacity:0.8">在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>On the WMT 2014 English-to-German translation task, the big transformer model (Transformer (big) in Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0 BLEU, establishing a new state-of-the-art <font color=orangered>BLEU</font> score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 P100 GPUs.<span style="font-size:80%;opacity:0.8">在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>On the WMT 2014 English-to-French translation task, our big model achieves a <font color=orangered>BLEU</font> score of 41.0, outperforming all of the previously published single models, at less than 1∕4 the training cost of the previous state-of-the-art model.<span style="font-size:80%;opacity:0.8">在WMT 2014英语-法语翻译任务中，我们的大型模型的BLEU得分为41.0，超过了之前发布的所有单一模型，训练成本低于先前最先进模型的1 ∕ 4 。</span></li><li>In Table 3 rows (A), we vary the number of attention heads and the attention key and value dimensions, keeping the amount of computation constant, as described in Section 3.2.2.  While single-head attention is 0.9 <font color=orangered>BLEU</font> worse than the best setting, quality also drops off with too many heads.<span style="font-size:80%;opacity:0.8">在表3的行（A）中，我们改变attention head的数量和attention key和value的维度，保持计算量不变，如3.2.2节所述。 虽然只有一个head attention比最佳设置差0.9 BLEU，但质量也随着head太多而下降。</span></li></ul>
 </td>
</tr>
<tr>
<td> 6 </td> <td> positional<br>(9) </td> <td> [pəˈzɪʃənəl] </td> <td> 
<ul><li>3.5 <font color=orangered>Positional</font> Encoding<span style="font-size:80%;opacity:0.8">3.5 位置编码</span></li><li>To this end, we add &quot;<font color=orangered>positional</font> encodings&quot; to the input embeddings at the bottoms of the encoder and decoder stacks.<span style="font-size:80%;opacity:0.8"> 为此，我们将“位置编码”添加到编码器和解码器堆栈底部的输入嵌入中。</span></li><li>The <font color=orangered>positional</font> encodings have the same dimension dmodel as the embeddings, so that the two can be summed.<span style="font-size:80%;opacity:0.8"> 位置编码和嵌入的维度dmodel相同，所以它们俩可以相加。</span></li><li>There are many choices of <font color=orangered>positional</font> encodings, learned and fixed [9].<span style="font-size:80%;opacity:0.8"> 有多种位置编码可以选择，例如通过学习得到的位置编码和固定的位置编码[9]。</span></li><li>That is, each dimension of the <font color=orangered>positional</font> encoding corresponds to a sinusoid.<span style="font-size:80%;opacity:0.8"> 也就是说，位置编码的每个维度对应于一个正弦曲线。</span></li><li>We also experimented with using learned <font color=orangered>positional</font> embeddings [9] instead, and found that the two versions produced nearly identical results (see Table 3 row (E)).<span style="font-size:80%;opacity:0.8">我们还使用学习到的位置嵌入9进行了试验，发现这两个版本产生几乎相同的结果（参见表 3 行(E)）。</span></li><li>In addition, we apply dropout to the sums of the embeddings and the <font color=orangered>positional</font> encodings in both the encoder and decoder stacks.<span style="font-size:80%;opacity:0.8"> 此外，在编码器和解码器堆栈中，我们将丢弃应用到嵌入和位置编码的和。</span></li><li>In row (E) we replace our sinusoidal <font color=orangered>positional</font> encoding with learned positional embeddings [9], and observe nearly identical results to the base model.<span style="font-size:80%;opacity:0.8"> 在行（E）中，我们用学习到的位置嵌入[9]来替换我们的正弦位置编码，并观察到与基本模型几乎相同的结果。</span></li><li>In row (E) we replace our sinusoidal positional encoding with learned <font color=orangered>positional</font> embeddings [9], and observe nearly identical results to the base model.<span style="font-size:80%;opacity:0.8"> 在行（E）中，我们用学习到的位置嵌入[9]来替换我们的正弦位置编码，并观察到与基本模型几乎相同的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 7 </td> <td> dot-product<br>(8) </td> <td> [!≈ dɒt ˈprɒdʌkt] </td> <td> 
<ul><li>Noam proposed scaled <font color=orangered>dot-product</font> attention, multi-head attention and the parameter-free position representation and became the other person involved in nearly every detail.<span style="font-size:80%;opacity:0.8"> Noam提出缩放版的点积attention、multi-head attention和与参数无关的位置表示，并成为在几乎每个细节中都涉及的另外一个人。</span></li><li>3.2.1 Scaled <font color=orangered>Dot-Product</font> Attention<span style="font-size:80%;opacity:0.8">3.2.1 缩放版的点积attention</span></li><li>We call our particular attention &quot;Scaled <font color=orangered>Dot-Product</font> Attention&quot; (Figure 2).<span style="font-size:80%;opacity:0.8">我们称我们特殊的attention为“缩放版的点积attention”（图 2）。</span></li><li>The two most commonly used attention functions are additive attention [2], and <font color=orangered>dot-product</font> (multiplicative) attention.<span style="font-size:80%;opacity:0.8">两个最常用的attention函数是加法attention[2]和点积（乘法）attention。</span></li><li><font color=orangered>Dot-product</font> attention is identical to our algorithm, except for the scaling factor of $\frac 1 {\sqrt{d_k}}$.<span style="font-size:80%;opacity:0.8"> 除了缩放因子$\frac 1 {\sqrt{d_k}}$之外，点积attention与我们的算法相同。</span></li><li>While the two are similar in theoretical complexity, <font color=orangered>dot-product</font> attention is much faster and more space-efficient in practice, since it can be implemented using highly optimized matrix multiplication code.<span style="font-size:80%;opacity:0.8"> 虽然两者在理论上的复杂性相似，但在实践中点积attention的速度更快、更节省空间，因为它可以使用高度优化的矩阵乘法代码来实现。</span></li><li>Figure 2: (left) Scaled <font color=orangered>Dot-Product</font> Attention.<span style="font-size:80%;opacity:0.8">图2： （左）缩放版的点积attention。</span></li><li>We implement this inside of scaled <font color=orangered>dot-product</font> attention by masking out (setting to -∞) all values in the input of the softmax which correspond to illegal connections.<span style="font-size:80%;opacity:0.8"> 通过屏蔽softmax的输入中所有不合法连接的值（设置为-∞），我们在缩放版的点积attention中实现。</span></li></ul>
 </td>
</tr>
<tr>
<td> 8 </td> <td> WMT<br>(8) </td> <td> [!≈ 'dʌblju: em ti:] </td> <td> 
<ul><li>Our model achieves 28.4 BLEU on the <font color=orangered>WMT</font> 2014 English-to-German translation task, improving over the existing best results, including ensembles, by over 2 BLEU.<span style="font-size:80%;opacity:0.8"> 我们的模型在WMT 2014英语-德语翻译任务上达到28.4 BLEU，超过现有最佳结果（包括整合模型）2个BLEU。</span></li><li>On the <font color=orangered>WMT</font> 2014 English-to-French translation task, our model establishes a new single-model state-of-the-art BLEU score of 41.8 after training for 3.5 days on eight GPUs, a small fraction of the training costs of the best models from the literature.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-法语翻译任务中，我们的模型建立了单模型新的最先进的BLEU分数41.8，它在8个GPU上训练了3.5天，这个时间只是目前文献中记载的最好的模型训练成本的一小部分。</span></li><li>We trained on the standard <font color=orangered>WMT</font> 2014 English-German dataset consisting of about 4.5 million sentence pairs.<span style="font-size:80%;opacity:0.8">我们在标准的WMT 2014英语-德语数据集上进行了训练，其中包含约450万个句子对。</span></li><li>For English-French, we used the significantly larger <font color=orangered>WMT</font> 2014 English-French dataset consisting of 36M sentences and split tokens into a 32000 word-piece vocabulary [38].<span style="font-size:80%;opacity:0.8"> 对于英语-法语翻译，我们使用大得多的WMT 2014英法数据集，它包含3600万个句子，并将词符分成32000个word-piece词汇表[38]。</span></li><li>On the <font color=orangered>WMT</font> 2014 English-to-German translation task, the big transformer model (Transformer (big) in Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0 BLEU, establishing a new state-of-the-art BLEU score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 P100 GPUs.<span style="font-size:80%;opacity:0.8">在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>On the <font color=orangered>WMT</font> 2014 English-to-French translation task, our big model achieves a BLEU score of 41.0, outperforming all of the previously published single models, at less than 1∕4 the training cost of the previous state-of-the-art model.<span style="font-size:80%;opacity:0.8">在WMT 2014英语-法语翻译任务中，我们的大型模型的BLEU得分为41.0，超过了之前发布的所有单一模型，训练成本低于先前最先进模型的1 ∕ 4 。</span></li><li>On both <font color=orangered>WMT</font> 2014 English-to-German and WMT 2014 English-to-French translation tasks, we achieve a new state of the art.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-德语和WMT 2014英语-法语翻译任务中，我们取得了最好的结果。</span></li><li>On both WMT 2014 English-to-German and <font color=orangered>WMT</font> 2014 English-to-French translation tasks, we achieve a new state of the art.<span style="font-size:80%;opacity:0.8"> 在WMT 2014英语-德语和WMT 2014英语-法语翻译任务中，我们取得了最好的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 9 </td> <td> embeddings<br>(8) </td> <td> [ɪm'bɛd] </td> <td> 
<ul><li>This masking, combined with fact that the output <font color=orangered>embeddings</font> are offset by one position, ensures that the predictions for position i can depend only on the known outputs at positions less than i.<span style="font-size:80%;opacity:0.8"> 这种掩码结合将输出嵌入偏移一个位置，确保对位置的预测 i 只能依赖小于i 的已知输出。</span></li><li>3.4 <font color=orangered>Embeddings</font> and Softmax<span style="font-size:80%;opacity:0.8">3.4 嵌入和Softmax</span></li><li>Similarly to other sequence transduction models, we use learned <font color=orangered>embeddings</font> to convert the input tokens and output tokens to vectors of dimension dmodel.<span style="font-size:80%;opacity:0.8">与其他序列转导模型类似，我们使用学习到的嵌入将输入词符和输出词符转换为维度为dmodel的向量。</span></li><li>To this end, we add &quot;positional encodings&quot; to the input <font color=orangered>embeddings</font> at the bottoms of the encoder and decoder stacks.<span style="font-size:80%;opacity:0.8"> 为此，我们将“位置编码”添加到编码器和解码器堆栈底部的输入嵌入中。</span></li><li>The positional encodings have the same dimension dmodel as the <font color=orangered>embeddings</font>, so that the two can be summed.<span style="font-size:80%;opacity:0.8"> 位置编码和嵌入的维度dmodel相同，所以它们俩可以相加。</span></li><li>We also experimented with using learned positional <font color=orangered>embeddings</font> [9] instead, and found that the two versions produced nearly identical results (see Table 3 row (E)).<span style="font-size:80%;opacity:0.8">我们还使用学习到的位置嵌入9进行了试验，发现这两个版本产生几乎相同的结果（参见表 3 行(E)）。</span></li><li>In addition, we apply dropout to the sums of the <font color=orangered>embeddings</font> and the positional encodings in both the encoder and decoder stacks.<span style="font-size:80%;opacity:0.8"> 此外，在编码器和解码器堆栈中，我们将丢弃应用到嵌入和位置编码的和。</span></li><li>In row (E) we replace our sinusoidal positional encoding with learned positional <font color=orangered>embeddings</font> [9], and observe nearly identical results to the base model.<span style="font-size:80%;opacity:0.8"> 在行（E）中，我们用学习到的位置嵌入[9]来替换我们的正弦位置编码，并观察到与基本模型几乎相同的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 10 </td> <td> sequential<br>(7) </td> <td> [sɪˈkwenʃl] </td> <td> 
<ul><li>This inherently <font color=orangered>sequential</font> nature precludes parallelization within training examples, which becomes critical at longer sequence lengths, as memory constraints limit batching across examples.<span style="font-size:80%;opacity:0.8">这种固有的顺序特性阻碍样本训练的并行化，这在更长的序列长度上变得至关重要，因为有限的内存限制样本的批次大小。</span></li><li>The fundamental constraint of <font color=orangered>sequential</font> computation, however, remains.<span style="font-size:80%;opacity:0.8"> 然而，顺序计算的基本约束依然存在。</span></li><li>The goal of reducing <font color=orangered>sequential</font> computation also forms the foundation of the Extended Neural GPU [16], ByteNet [18] and ConvS2S [9], all of which use convolutional neural networks as basic building block, computing hidden representations in parallel for all input and output positions.<span style="font-size:80%;opacity:0.8">减少顺序计算的目标也构成扩展的神经网络GPU [16]、ByteNet [18]和ConvS2S [9]的基础，它们都使用卷积神经网络作为基本构建模块、并行计算所有输入和输出位置的隐藏表示。</span></li><li>Another is the amount of computation that can be parallelized, as measured by the minimum number of <font color=orangered>sequential</font> operations required.<span style="font-size:80%;opacity:0.8"> 另一个是可以并行的计算量，以所需的最小顺序操作的数量来衡量。</span></li><li>Table 1: Maximum path lengths, per-layer complexity and minimum number of <font color=orangered>sequential</font> operations for different layer types.<span style="font-size:80%;opacity:0.8">表1： 不同图层类型的最大路径长度、每层复杂度和最少顺序操作数。</span></li><li>As noted in Table 1, a self-attention layer connects all positions with a constant number of sequentially executed operations, whereas a recurrent layer requires $O(n)$ <font color=orangered>sequential</font> operations.<span style="font-size:80%;opacity:0.8">如表1所示，self-attention层将所有位置连接到恒定数量的顺序执行的操作，而循环层需要O(n) 顺序操作。</span></li><li>Making generation less <font color=orangered>sequential</font> is another research goals of ours.<span style="font-size:80%;opacity:0.8"> 让生成具有更少的顺序性是我们的另一个研究目标。</span></li></ul>
 </td>
</tr>
<tr>
<td> 11 </td> <td> encoder-decoder<br>(5) </td> <td> [!≈ ɪn'kəʊdə ˌdi:ˈkəʊdə(r)] </td> <td> 
<ul><li>Numerous efforts have since continued to push the boundaries of recurrent language models and <font color=orangered>encoder-decoder</font> architectures [38, 24, 15].<span style="font-size:80%;opacity:0.8"> 自那以后，许多努力一直在推动循环语言模型和编码器-解码器架构的界限[38, 24, 15]。</span></li><li>Most competitive neural sequence transduction models have an <font color=orangered>encoder-decoder</font> structure [5, 2, 35].<span style="font-size:80%;opacity:0.8">大部分神经序列转导模型都有一个编码器-解码器结构[5, 2, 35]。</span></li><li>In &quot;<font color=orangered>encoder-decoder</font> attention&quot; layers, the queries come from the previous decoder layer, and the memory keys and values come from the output of the encoder.<span style="font-size:80%;opacity:0.8">在“编码器—解码器attention”层，query来自上面的解码器层，key和value来自编码器的输出。</span></li><li>This mimics the typical <font color=orangered>encoder-decoder</font> attention mechanisms in sequence-to-sequence models such as [38, 2, 9].<span style="font-size:80%;opacity:0.8"> 这模仿序列到序列模型中典型的编码器—解码器的attention机制，例如[38, 2, 9]。</span></li><li>In this work, we presented the Transformer, the first sequence transduction model based entirely on attention, replacing the recurrent layers most commonly used in <font color=orangered>encoder-decoder</font> architectures with multi-headed self-attention.<span style="font-size:80%;opacity:0.8">在这项工作中，我们提出了Transformer，第一个完全基于关注的序列转导模型，用multi-headed self-attention取代了编码器-解码器架构中最常用的循环层。</span></li></ul>
 </td>
</tr>
<tr>
<td> 12 </td> <td> feed-forward<br>(5) </td> <td> ['fi:df'ɔ:wəd] </td> <td> 
<ul><li>The first is a multi-head self-attention mechanism, and the second is a simple, position-wise fully connected <font color=orangered>feed-forward</font> network.<span style="font-size:80%;opacity:0.8"> 第一个子层是一个multi-head self-attention机制，第二个子层是一个简单的、位置完全连接的前馈网络。</span></li><li>Additive attention computes the compatibility function using a <font color=orangered>feed-forward</font> network with a single hidden layer.<span style="font-size:80%;opacity:0.8"> 加法attention使用具有单个隐藏层的前馈网络计算兼容性函数。</span></li><li>3.3 Position-wise <font color=orangered>Feed-Forward</font> Networks<span style="font-size:80%;opacity:0.8">3.3 基于位置的前馈网络</span></li><li>In addition to attention sub-layers, each of the layers in our encoder and decoder contains a fully connected <font color=orangered>feed-forward</font> network, which is applied to each position separately and identically.<span style="font-size:80%;opacity:0.8">除了attention子层之外，我们的编码器和解码器中的每个层都包含一个完全连接的前馈网络，该前馈网络单独且相同地应用于每个位置。</span></li><li>Even with $k = n$, however, the complexity of a separable convolution is equal to the combination of a self-attention layer and a point-wise <font color=orangered>feed-forward</font> layer, the approach we take in our model.<span style="font-size:80%;opacity:0.8"> 然而，即使k = n，一个可分卷积的复杂度等同于self-attention层和point-wise前向层的组合，即我们的模型采用的方法。</span></li></ul>
 </td>
</tr>
<tr>
<td> 13 </td> <td> ensemble<br>(4) </td> <td> [ɒnˈsɒmbl] </td> <td> 
<ul><li>Our model achieves 28.4 BLEU on the WMT 2014 English-to-German translation task, improving over the existing best results, including <font color=orangered>ensembles</font>, by over 2 BLEU.<span style="font-size:80%;opacity:0.8"> 我们的模型在WMT 2014英语-德语翻译任务上达到28.4 BLEU，超过现有最佳结果（包括整合模型）2个BLEU。</span></li><li>On the WMT 2014 English-to-German translation task, the big transformer model (Transformer (big) in Table 2) outperforms the best previously reported models (including <font color=orangered>ensembles</font>) by more than 2.0 BLEU, establishing a new state-of-the-art BLEU score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 P100 GPUs.<span style="font-size:80%;opacity:0.8">在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>Even our base model surpasses all previously published models and <font color=orangered>ensembles</font>, at a fraction of the training cost of any of the competitive models.<span style="font-size:80%;opacity:0.8"> 即使我们的基础模型也超过了以前发布的所有模型和整合模型，且训练成本只是这些模型的一小部分。</span></li><li>In the former task our best model outperforms even all previously reported <font color=orangered>ensembles</font>.<span style="font-size:80%;opacity:0.8"> 在前面的任务中，我们最好的模型甚至胜过以前报道过的所有整合模型。</span></li></ul>
 </td>
</tr>
<tr>
<td> 14 </td> <td> constituency<br>(4) </td> <td> [kənˈstɪtjuənsi] </td> <td> 
<ul><li>We show that the Transformer generalizes well to other tasks by applying it successfully to English <font color=orangered>constituency</font> parsing both with large and limited training data.<span style="font-size:80%;opacity:0.8"> 通过在解析大量训练数据和有限训练数据的两种情况下将其应用到English constituency，我们表明Transformer可以很好地推广到其他任务。</span></li><li>6.3 English <font color=orangered>Constituency</font> Parsing<span style="font-size:80%;opacity:0.8">6.3 English Constituency Parsing</span></li><li>Table 4: The Transformer generalizes well to English <font color=orangered>constituency</font> parsing (Results are on Section 23 of WSJ)<span style="font-size:80%;opacity:0.8">表4： The Transformer generalizes well to English constituency parsing (Results are on Section 23 of WSJ)</span></li><li>To evaluate if the Transformer can generalize to other tasks we performed experiments on English <font color=orangered>constituency</font> parsing. This task presents specific challenges: the output is subject to strong structural constraints and is significantly longer than the input.<span style="font-size:80%;opacity:0.8">To evaluate if the Transformer can generalize to other tasks we performed experiments on English constituency parsing. 这项任务提出特别的挑战：输出受到很强的结构性约束，并且比输入要长很多。</span></li></ul>
 </td>
</tr>
<tr>
<td> 15 </td> <td> parse<br>(4) </td> <td> [pɑ:z] </td> <td> 
<ul><li>We show that the Transformer generalizes well to other tasks by applying it successfully to English constituency <font color=orangered>parsing</font> both with large and limited training data.<span style="font-size:80%;opacity:0.8"> 通过在解析大量训练数据和有限训练数据的两种情况下将其应用到English constituency，我们表明Transformer可以很好地推广到其他任务。</span></li><li>6.3 English Constituency <font color=orangered>Parsing</font><span style="font-size:80%;opacity:0.8">6.3 English Constituency Parsing</span></li><li>Table 4: The Transformer generalizes well to English constituency <font color=orangered>parsing</font> (Results are on Section 23 of WSJ)<span style="font-size:80%;opacity:0.8">表4： The Transformer generalizes well to English constituency parsing (Results are on Section 23 of WSJ)</span></li><li>To evaluate if the Transformer can generalize to other tasks we performed experiments on English constituency <font color=orangered>parsing</font>. This task presents specific challenges: the output is subject to strong structural constraints and is significantly longer than the input.<span style="font-size:80%;opacity:0.8">To evaluate if the Transformer can generalize to other tasks we performed experiments on English constituency parsing. 这项任务提出特别的挑战：输出受到很强的结构性约束，并且比输入要长很多。</span></li></ul>
 </td>
</tr>
<tr>
<td> 16 </td> <td> P100<br>(4) </td> <td>  </td> <td> 
<ul><li>The Transformer allows for significantly more parallelization and can reach a new state of the art in translation quality after being trained for as little as twelve hours on eight <font color=forestgreen>P100</font> GPUs.<span style="font-size:80%;opacity:0.8"> Transformer允许进行更多的并行化，并且可以在八个P100 GPU上接受少至十二小时的训练后达到翻译质量的新的最佳结果。</span></li><li>We trained our models on one machine with 8 NVIDIA <font color=forestgreen>P100</font> GPUs.<span style="font-size:80%;opacity:0.8">我们在一台具有8个NVIDIA P100 GPU的机器上训练我们的模型。</span></li><li>On the WMT 2014 English-to-German translation task, the big transformer model (Transformer (big) in Table 2) outperforms the best previously reported models (including ensembles) by more than 2.0 BLEU, establishing a new state-of-the-art BLEU score of 28.4.  The configuration of this model is listed in the bottom line of Table 3.  Training took 3.5 days on 8 <font color=forestgreen>P100</font> GPUs.<span style="font-size:80%;opacity:0.8">在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包括整合模型）高出2.0 个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。</span></li><li>We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision floating-point capacity of each GPU (We used values of 2.8, 3.7, 6.0 and 9.5 TFLOPS for K80, K40, M40 and <font color=forestgreen>P100</font>, respectively).<span style="font-size:80%;opacity:0.8"> 我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量(对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 17 </td> <td> residual<br>(4) </td> <td> [rɪˈzɪdjuəl] </td> <td> 
<ul><li>We employ a <font color=orangered>residual</font> connection [11] around each of the two sub-layers, followed by layer normalization [1].<span style="font-size:80%;opacity:0.8"> 我们对每个子层再采用一个残差连接[11] ，接着进行层标准化[1]。</span></li><li>To facilitate these <font color=orangered>residual</font> connections, all sub-layers in the model, as well as the embedding layers, produce outputs of dimension dmodel = 512.<span style="font-size:80%;opacity:0.8"> 为了方便这些残差连接，模型中的所有子层以及嵌入层产生的输出维度都为dmodel = 512。</span></li><li>Similar to the encoder, we employ <font color=orangered>residual</font> connections around each of the sub-layers, followed by layer normalization.<span style="font-size:80%;opacity:0.8"> 与编码器类似，我们在每个子层再采用残差连接，然后进行层标准化。</span></li><li><font color=orangered>Residual</font> Dropout We apply dropout [33] to the output of each sub-layer, before it is added to the sub-layer input and normalized.<span style="font-size:80%;opacity:0.8">残差丢弃 我们将丢弃[33]应用到每个子层的输出，在将它与子层的输入相加和规范化之前。</span></li></ul>
 </td>
</tr>
<tr>
<td> 18 </td> <td> dmodel<br>(4) </td> <td>  </td> <td> 
<ul><li>To facilitate these residual connections, all sub-layers in the model, as well as the embedding layers, produce outputs of dimension <font color=forestgreen>dmodel</font> = 512.<span style="font-size:80%;opacity:0.8"> 为了方便这些残差连接，模型中的所有子层以及嵌入层产生的输出维度都为dmodel = 512。</span></li><li>Similarly to other sequence transduction models, we use learned embeddings to convert the input tokens and output tokens to vectors of dimension <font color=forestgreen>dmodel</font>.<span style="font-size:80%;opacity:0.8">与其他序列转导模型类似，我们使用学习到的嵌入将输入词符和输出词符转换为维度为dmodel的向量。</span></li><li>The positional encodings have the same dimension <font color=forestgreen>dmodel</font> as the embeddings, so that the two can be summed.<span style="font-size:80%;opacity:0.8"> 位置编码和嵌入的维度dmodel相同，所以它们俩可以相加。</span></li><li>We trained a 4-layer transformer with <font color=forestgreen>dmodel</font> = 1024 on the Wall Street Journal (WSJ) portion of the Penn Treebank [25], about 40K training sentences.<span style="font-size:80%;opacity:0.8">我们用dmodel = 1024 在Penn Treebank[25]的Wall Street Journal（WSJ）部分训练了一个4层transformer，约40K个训练句子。</span></li></ul>
 </td>
</tr>
<tr>
<td> 19 </td> <td> encodings<br>(4) </td> <td> [!≈ ɪn'kəʊdɪŋz] </td> <td> 
<ul><li>To this end, we add &quot;positional <font color=orangered>encodings</font>&quot; to the input embeddings at the bottoms of the encoder and decoder stacks.<span style="font-size:80%;opacity:0.8"> 为此，我们将“位置编码”添加到编码器和解码器堆栈底部的输入嵌入中。</span></li><li>The positional <font color=orangered>encodings</font> have the same dimension dmodel as the embeddings, so that the two can be summed.<span style="font-size:80%;opacity:0.8"> 位置编码和嵌入的维度dmodel相同，所以它们俩可以相加。</span></li><li>There are many choices of positional <font color=orangered>encodings</font>, learned and fixed [9].<span style="font-size:80%;opacity:0.8"> 有多种位置编码可以选择，例如通过学习得到的位置编码和固定的位置编码[9]。</span></li><li>In addition, we apply dropout to the sums of the embeddings and the positional <font color=orangered>encodings</font> in both the encoder and decoder stacks.<span style="font-size:80%;opacity:0.8"> 此外，在编码器和解码器堆栈中，我们将丢弃应用到嵌入和位置编码的和。</span></li></ul>
 </td>
</tr>
<tr>
<td> 20 </td> <td> WSJ<br>(4) </td> <td> [!≈ 'dʌblju: es dʒeɪ] </td> <td> 
<ul><li>Table 4: The Transformer generalizes well to English constituency parsing (Results are on Section 23 of <font color=orangered>WSJ</font>)<span style="font-size:80%;opacity:0.8">表4： The Transformer generalizes well to English constituency parsing (Results are on Section 23 of WSJ)</span></li><li>We trained a 4-layer transformer with dmodel = 1024 on the Wall Street Journal (<font color=orangered>WSJ</font>) portion of the Penn Treebank [25], about 40K training sentences.<span style="font-size:80%;opacity:0.8">我们用dmodel = 1024 在Penn Treebank[25]的Wall Street Journal（WSJ）部分训练了一个4层transformer，约40K个训练句子。</span></li><li>We used a vocabulary of 16K tokens for the <font color=orangered>WSJ</font> only setting and a vocabulary of 32K tokens for the semi-supervised setting.<span style="font-size:80%;opacity:0.8"> 我们使用了一个16K词符的词汇表作为WSJ唯一设置，和一个32K词符的词汇表用于半监督设置。</span></li><li>In contrast to RNN sequence-to-sequence models [37], the Transformer outperforms the BerkeleyParser [29] even when training only on the <font color=orangered>WSJ</font> training set of 40K sentences.<span style="font-size:80%;opacity:0.8">与RNN序列到序列模型[37]相比，即使仅在WSJ训练40K句子组训练时，Transformer也胜过BerkeleyParser [29]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 21 </td> <td> codebase<br>(3) </td> <td>  </td> <td> 
<ul><li>Niki designed, implemented, tuned and evaluated countless model variants in our original <font color=forestgreen>codebase</font> and tensor2tensor.<span style="font-size:80%;opacity:0.8"> Niki在我们最初的代码库和tensor2tensor中设计、实现、调优和评估了无数的模型变体。</span></li><li>Llion also experimented with novel model variants, was responsible for our initial <font color=forestgreen>codebase</font>, and efficient inference and visualizations.<span style="font-size:80%;opacity:0.8"> Llion还尝试了新的模型变体，负责我们的初始代码库，以及高效的推断和可视化。</span></li><li>Lukasz and Aidan spent countless long days designing various parts of and implementing tensor2tensor, replacing our earlier <font color=forestgreen>codebase</font>, greatly improving results and massively accelerating our research.<span style="font-size:80%;opacity:0.8"> Lukasz和Aidan花费了无数的时间来设计tensor2tensor的各个部分，取代了我们之前的代码库，极大地改进了结果并大大加快了我们的研究。 </span></li></ul>
 </td>
</tr>
<tr>
<td> 22 </td> <td> linearly<br>(3) </td> <td> [ˈliniəli] </td> <td> 
<ul><li>In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, <font color=orangered>linearly</font> for ConvS2S and logarithmically for ByteNet.<span style="font-size:80%;opacity:0.8"> 在这些模型中，关联任意两个输入和输出位置的信号所需的操作次数会随着位置之间的距离而增加，ConvS2S是线性增加，而ByteNet是对数增加。</span></li><li>Instead of performing a single attention function with $d$ model-dimensional keys, values and queries, we found it beneficial to <font color=orangered>linearly</font> project the queries, keys and values $h$ times with different, learned linear projections to $d_k$, $d_k$ and $d_v$ dimensions, respectively.<span style="font-size:80%;opacity:0.8">我们发现将query、key和value分别用不同的、学到的线性映射h倍到dk、dk和dv维效果更好，而不是用d model维的query、key和value执行单个attention函数。</span></li><li>This corresponds to increasing the learning rate <font color=orangered>linearly</font> for the first warmup_steps training steps, and decreasing it thereafter proportionally to the inverse square root of the step number.<span style="font-size:80%;opacity:0.8">这对应于在第一次warmup_steps 步骤中线性地增加学习速率，并且随后将其与步骤数的平方根成比例地减小。</span></li></ul>
 </td>
</tr>
<tr>
<td> 23 </td> <td> additive<br>(3) </td> <td> [ˈædətɪv] </td> <td> 
<ul><li>The two most commonly used attention functions are <font color=orangered>additive</font> attention [2], and dot-product (multiplicative) attention.<span style="font-size:80%;opacity:0.8">两个最常用的attention函数是加法attention[2]和点积（乘法）attention。</span></li><li><font color=orangered>Additive</font> attention computes the compatibility function using a feed-forward network with a single hidden layer.<span style="font-size:80%;opacity:0.8"> 加法attention使用具有单个隐藏层的前馈网络计算兼容性函数。</span></li><li>While for small values of $d_k$ the two mechanisms perform similarly, <font color=orangered>additive</font> attention outperforms dot product attention without scaling for larger values of $d_k$ [3].<span style="font-size:80%;opacity:0.8">当dk的值比较小的时候，这两个机制的性能相差相近，当dk比较大时，加法attention比不带缩放的点积attention性能好[3]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 24 </td> <td> dk<br>(3) </td> <td> ['di:k'eɪ] </td> <td> 
<ul><li>We suspect that for large values of <font color=orangered>dk</font>, the dot products grow large in magnitude, pushing the softmax function into regions where it has extremely small gradients (To illustrate why the dot products get large, assume that the components of q and k are independent random variables with mean 0 and variance 1.<span style="font-size:80%;opacity:0.8"> 我们怀疑，对于很大的dk值，点积大幅度增长，将softmax函数推向具有极小梯度的区域(4为了说明点积为什么变大，假设q和k的组成是均值为0和方差为1的独立随机变量。</span></li><li>Then their dot product, q ⋅ k = ∑ i=1dk qiki, has mean 0 and variance <font color=orangered>dk</font>).<span style="font-size:80%;opacity:0.8"> 那么它们的点积q ⋅ k = ∑ i=1dk qi ki 的均值为0，方差为dk)。</span></li><li>In Table 3 rows (B), we observe that reducing the attention key size <font color=orangered>dk</font> hurts model quality.<span style="font-size:80%;opacity:0.8">在表3行（B）中，我们观察到减小key的大小dk会有损模型质量。</span></li></ul>
 </td>
</tr>
<tr>
<td> 25 </td> <td> long-range<br>(3) </td> <td> [lɒŋ reɪndʒ] </td> <td> 
<ul><li>The third is the path length between <font color=orangered>long-range</font> dependencies in the network.<span style="font-size:80%;opacity:0.8">第三个是网络中长距离依赖之间的路径长度。</span></li><li>Learning <font color=orangered>long-range</font> dependencies is a key challenge in many sequence transduction tasks.<span style="font-size:80%;opacity:0.8"> 学习长距离依赖性是许多序列转导任务中的关键挑战。</span></li><li>The shorter these paths between any combination of positions in the input and output sequences, the easier it is to learn <font color=orangered>long-range</font> dependencies [12].<span style="font-size:80%;opacity:0.8"> 输入和输出序列中任意位置组合之间的这些路径越短，学习远距离依赖性就越容易[12]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 26 </td> <td> byte-pair<br>(3) </td> <td> [!≈ baɪt peə(r)] </td> <td> 
<ul><li>In terms of computational complexity, self-attention layers are faster than recurrent layers when the sequence length n is smaller than the representation dimensionality d, which is most often the case with sentence representations used by state-of-the-art models in machine translations, such as word-piece [38] and <font color=orangered>byte-pair</font> [31] representations.<span style="font-size:80%;opacity:0.8"> 在计算复杂性方面，当序列长度n 小于表示维度d 时，self-attention层比循环层快，这是机器翻译中最先进的模型最常见情况，例如单词[38]表示法和字节对[31]表示法。</span></li><li>Sentences were encoded using <font color=orangered>byte-pair</font> encoding [3], which has a shared source-target vocabulary of about 37000 tokens.<span style="font-size:80%;opacity:0.8"> 这些句子使用字节对编码[3]进行编码，源语句和目标语句共享大约37000个词符的词汇表。</span></li><li>All metrics are on the English-to-German translation development set, newstest2013. Listed perplexities are per-wordpiece, according to our <font color=orangered>byte-pair</font> encoding, and should not be compared to per-word perplexities.<span style="font-size:80%;opacity:0.8"> Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.</span></li></ul>
 </td>
</tr>
<tr>
<td> 27 </td> <td> perplexity<br>(3) </td> <td> [pəˈpleksəti] </td> <td> 
<ul><li>This hurts <font color=orangered>perplexity</font>, as the model learns to be more unsure, but improves accuracy and BLEU score.<span style="font-size:80%;opacity:0.8"> 这让模型不易理解，因为模型学得更加不确定，但提高了准确性和BLEU得分。</span></li><li>All metrics are on the English-to-German translation development set, newstest2013. Listed <font color=orangered>perplexities</font> are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.<span style="font-size:80%;opacity:0.8"> Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.</span></li><li>All metrics are on the English-to-German translation development set, newstest2013. Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word <font color=orangered>perplexities</font>.<span style="font-size:80%;opacity:0.8"> Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.</span></li></ul>
 </td>
</tr>
<tr>
<td> 28 </td> <td> newstest<br>(3) </td> <td>  </td> <td> 
<ul><li>Table 2: The Transformer achieves better BLEU scores than previous state-of-the-art models on the English-to-German and English-to-French <font color=forestgreen>newstest</font>2014 tests at a fraction of the training cost.<span style="font-size:80%;opacity:0.8">表2： Transformer在英语-德语和英语-法语newstest2014测试中获得的BLEU分数比以前的最新模型的分数更好，且训练成本只是它们的一小部分。</span></li><li>All metrics are on the English-to-German translation development set, <font color=forestgreen>newstest</font>2013. Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.<span style="font-size:80%;opacity:0.8"> Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.</span></li><li>To evaluate the importance of different components of the Transformer, we varied our base model in different ways, measuring the change in performance on English-to-German translation on the development set, <font color=forestgreen>newstest</font>2013.<span style="font-size:80%;opacity:0.8">为了评估Transformer不同组件的重要性，我们以不同的方式改变我们的基础模型，测量开发集newstest2013上英文-德文翻译的性能变化。</span></li></ul>
 </td>
</tr>
<tr>
<td> 29 </td> <td> variant<br>(2) </td> <td> [ˈveəriənt] </td> <td> 
<ul><li>Niki designed, implemented, tuned and evaluated countless model <font color=orangered>variants</font> in our original codebase and tensor2tensor.<span style="font-size:80%;opacity:0.8"> Niki在我们最初的代码库和tensor2tensor中设计、实现、调优和评估了无数的模型变体。</span></li><li>Llion also experimented with novel model <font color=orangered>variants</font>, was responsible for our initial codebase, and efficient inference and visualizations.<span style="font-size:80%;opacity:0.8"> Llion还尝试了新的模型变体，负责我们的初始代码库，以及高效的推断和可视化。</span></li></ul>
 </td>
</tr>
<tr>
<td> 30 </td> <td> tensor2tensor<br>(2) </td> <td>  </td> <td> 
<ul><li>Niki designed, implemented, tuned and evaluated countless model variants in our original codebase and <font color=forestgreen>tensor2tensor</font>.<span style="font-size:80%;opacity:0.8"> Niki在我们最初的代码库和tensor2tensor中设计、实现、调优和评估了无数的模型变体。</span></li><li>Lukasz and Aidan spent countless long days designing various parts of and implementing <font color=forestgreen>tensor2tensor</font>, replacing our earlier codebase, greatly improving results and massively accelerating our research.<span style="font-size:80%;opacity:0.8"> Lukasz和Aidan花费了无数的时间来设计tensor2tensor的各个部分，取代了我们之前的代码库，极大地改进了结果并大大加快了我们的研究。 </span></li></ul>
 </td>
</tr>
<tr>
<td> 31 </td> <td> ht<br>(2) </td> <td>  </td> <td> 
<ul><li>Aligning the positions to steps in computation time, they generate a sequence of hidden states <font color=forestgreen>ht</font>, as a function of the previous hidden state ht-1 and the input for position t.<span style="font-size:80%;opacity:0.8"> 通过在计算期间将位置与步骤对齐，它们根据前一步的隐藏状态ht-1和输入产生位置t的隐藏状态序列ht。</span></li><li>Aligning the positions to steps in computation time, they generate a sequence of hidden states ht, as a function of the previous hidden state <font color=forestgreen>ht</font>-1 and the input for position t.<span style="font-size:80%;opacity:0.8"> 通过在计算期间将位置与步骤对齐，它们根据前一步的隐藏状态ht-1和输入产生位置t的隐藏状态序列ht。</span></li></ul>
 </td>
</tr>
<tr>
<td> 32 </td> <td> parallelization<br>(2) </td> <td> [pærəlɪlaɪ'zeɪʃn] </td> <td> 
<ul><li>This inherently sequential nature precludes <font color=orangered>parallelization</font> within training examples, which becomes critical at longer sequence lengths, as memory constraints limit batching across examples.<span style="font-size:80%;opacity:0.8">这种固有的顺序特性阻碍样本训练的并行化，这在更长的序列长度上变得至关重要，因为有限的内存限制样本的批次大小。</span></li><li>The Transformer allows for significantly more <font color=orangered>parallelization</font> and can reach a new state of the art in translation quality after being trained for as little as twelve hours on eight P100 GPUs.<span style="font-size:80%;opacity:0.8"> Transformer允许进行更多的并行化，并且可以在八个P100 GPU上接受少至十二小时的训练后达到翻译质量的新的最佳结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 33 </td> <td> ByteNet<br>(2) </td> <td>  </td> <td> 
<ul><li>The goal of reducing sequential computation also forms the foundation of the Extended Neural GPU [16], <font color=forestgreen>ByteNet</font> [18] and ConvS2S [9], all of which use convolutional neural networks as basic building block, computing hidden representations in parallel for all input and output positions.<span style="font-size:80%;opacity:0.8">减少顺序计算的目标也构成扩展的神经网络GPU [16]、ByteNet [18]和ConvS2S [9]的基础，它们都使用卷积神经网络作为基本构建模块、并行计算所有输入和输出位置的隐藏表示。</span></li><li>In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, linearly for ConvS2S and logarithmically for <font color=forestgreen>ByteNet</font>.<span style="font-size:80%;opacity:0.8"> 在这些模型中，关联任意两个输入和输出位置的信号所需的操作次数会随着位置之间的距离而增加，ConvS2S是线性增加，而ByteNet是对数增加。</span></li></ul>
 </td>
</tr>
<tr>
<td> 34 </td> <td> ConvS2S<br>(2) </td> <td>  </td> <td> 
<ul><li>The goal of reducing sequential computation also forms the foundation of the Extended Neural GPU [16], ByteNet [18] and <font color=forestgreen>ConvS2S</font> [9], all of which use convolutional neural networks as basic building block, computing hidden representations in parallel for all input and output positions.<span style="font-size:80%;opacity:0.8">减少顺序计算的目标也构成扩展的神经网络GPU [16]、ByteNet [18]和ConvS2S [9]的基础，它们都使用卷积神经网络作为基本构建模块、并行计算所有输入和输出位置的隐藏表示。</span></li><li>In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, linearly for <font color=forestgreen>ConvS2S</font> and logarithmically for ByteNet.<span style="font-size:80%;opacity:0.8"> 在这些模型中，关联任意两个输入和输出位置的信号所需的操作次数会随着位置之间的距离而增加，ConvS2S是线性增加，而ByteNet是对数增加。</span></li></ul>
 </td>
</tr>
<tr>
<td> 35 </td> <td> counteract<br>(2) </td> <td> [ˌkaʊntərˈækt] </td> <td> 
<ul><li>In the Transformer this is reduced to a constant number of operations, albeit at the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we <font color=orangered>counteract</font> with Multi-Head Attention as described in section 3.2.<span style="font-size:80%;opacity:0.8"> 在Transformer中，这种操作减少到固定的次数，尽管由于对用attention权重化的位置取平均降低了效果，但是我使用Multi-Head Attention进行抵消，具体描述见 3.2。</span></li><li>To <font color=orangered>counteract</font> this effect, we scale the dot products by $\frac 1 {\sqrt{d_k}}$.<span style="font-size:80%;opacity:0.8"> 为了抵消这种影响，我们缩小点积 $\frac 1 {\sqrt{d_k}}$倍。</span></li></ul>
 </td>
</tr>
<tr>
<td> 36 </td> <td> sequence-aligned<br>(2) </td> <td> [!≈ ˈsi:kwəns ə'laɪnd] </td> <td> 
<ul><li>End-to-end memory networks are based on a recurrent attention mechanism instead of <font color=orangered>sequence-aligned</font> recurrence and have been shown to perform well on simple-language question answering and language modeling tasks [34].<span style="font-size:80%;opacity:0.8">端到端的记忆网络基于循环attention机制，而不是序列对齐的循环，并且已被证明在简单语言的问答和语言建模任务中表现良好[34]。</span></li><li>To the best of our knowledge, however, the Transformer is the first transduction model relying entirely on self-attention to compute representations of its input and output without using <font color=orangered>sequence-aligned</font> RNNs or convolution.<span style="font-size:80%;opacity:0.8">然而，就我们所知，Transformer是第一个完全依靠self-attention来计算输入和输出表示而不使用序列对齐RNN或卷积的转导模型。</span></li></ul>
 </td>
</tr>
<tr>
<td> 37 </td> <td> auto-regressive<br>(2) </td> <td> [!≈ ˈɔ:təʊ rɪˈgresɪv] </td> <td> 
<ul><li>At each step the model is <font color=orangered>auto-regressive</font> [10], consuming the previously generated symbols as additional input when generating the next.<span style="font-size:80%;opacity:0.8"> 在每一步中，模型都是自回归的[10]，当生成下一个时，使用先前生成的符号作为附加输入。</span></li><li>We need to prevent leftward information flow in the decoder to preserve the <font color=orangered>auto-regressive</font> property.<span style="font-size:80%;opacity:0.8"> 我们需要防止解码器中的向左信息流来保持自回归属性。</span></li></ul>
 </td>
</tr>
<tr>
<td> 38 </td> <td> point-wise<br>(2) </td> <td> [!≈ pɔɪnt waɪz] </td> <td> 
<ul><li>The Transformer follows this overall architecture using stacked self-attention and <font color=orangered>point-wise</font>, fully connected layers for both the encoder and decoder, shown in the left and right halves of Figure 1, respectively.<span style="font-size:80%;opacity:0.8">Transformer遵循这种整体架构，编码器和解码器都使用self-attention堆叠和point-wise、完全连接的层，分别显示在图1的左边和右边。</span></li><li>Even with $k = n$, however, the complexity of a separable convolution is equal to the combination of a self-attention layer and a <font color=orangered>point-wise</font> feed-forward layer, the approach we take in our model.<span style="font-size:80%;opacity:0.8"> 然而，即使k = n，一个可分卷积的复杂度等同于self-attention层和point-wise前向层的组合，即我们的模型采用的方法。</span></li></ul>
 </td>
</tr>
<tr>
<td> 39 </td> <td> position-wise<br>(2) </td> <td> [!≈ pəˈzɪʃn waɪz] </td> <td> 
<ul><li>The first is a multi-head self-attention mechanism, and the second is a simple, <font color=orangered>position-wise</font> fully connected feed-forward network.<span style="font-size:80%;opacity:0.8"> 第一个子层是一个multi-head self-attention机制，第二个子层是一个简单的、位置完全连接的前馈网络。</span></li><li>3.3 <font color=orangered>Position-wise</font> Feed-Forward Networks<span style="font-size:80%;opacity:0.8">3.3 基于位置的前馈网络</span></li></ul>
 </td>
</tr>
<tr>
<td> 40 </td> <td> Sublayer<br>(2) </td> <td> ['sʌb'leiә] </td> <td> 
<ul><li>That is, the output of each sub-layer is LayerNorm(x + <font color=orangered>Sublayer</font>(x)), where Sublayer(x) is the function implemented by the sub-layer itself.<span style="font-size:80%;opacity:0.8"> 也就是说，每个子层的输出是LayerNorm(x + Sublayer(x))，其中Sublayer(x) 是由子层本身实现的函数。</span></li><li>That is, the output of each sub-layer is LayerNorm(x + Sublayer(x)), where <font color=orangered>Sublayer</font>(x) is the function implemented by the sub-layer itself.<span style="font-size:80%;opacity:0.8"> 也就是说，每个子层的输出是LayerNorm(x + Sublayer(x))，其中Sublayer(x) 是由子层本身实现的函数。</span></li></ul>
 </td>
</tr>
<tr>
<td> 41 </td> <td> variance<br>(2) </td> <td> [ˈveəriəns] </td> <td> 
<ul><li>We suspect that for large values of dk, the dot products grow large in magnitude, pushing the softmax function into regions where it has extremely small gradients (To illustrate why the dot products get large, assume that the components of q and k are independent random variables with mean 0 and <font color=orangered>variance</font> 1.<span style="font-size:80%;opacity:0.8"> 我们怀疑，对于很大的dk值，点积大幅度增长，将softmax函数推向具有极小梯度的区域(4为了说明点积为什么变大，假设q和k的组成是均值为0和方差为1的独立随机变量。</span></li><li>Then their dot product, q ⋅ k = ∑ i=1dk qiki, has mean 0 and <font color=orangered>variance</font> dk).<span style="font-size:80%;opacity:0.8"> 那么它们的点积q ⋅ k = ∑ i=1dk qi ki 的均值为0，方差为dk)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 42 </td> <td> sinusoidal<br>(2) </td> <td> [ˌsɪnə'sɔɪdl] </td> <td> 
<ul><li>We chose the <font color=orangered>sinusoidal</font> version because it may allow the model to extrapolate to sequence lengths longer than the ones encountered during training.<span style="font-size:80%;opacity:0.8"> 我们选择了正弦曲线，因为它可以允许模型推断比训练期间遇到的更长的序列。</span></li><li>In row (E) we replace our <font color=orangered>sinusoidal</font> positional encoding with learned positional embeddings [9], and observe nearly identical results to the base model.<span style="font-size:80%;opacity:0.8"> 在行（E）中，我们用学习到的位置嵌入[9]来替换我们的正弦位置编码，并观察到与基本模型几乎相同的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 43 </td> <td> word-piece<br>(2) </td> <td> [!≈ wɜ:d pi:s] </td> <td> 
<ul><li>In terms of computational complexity, self-attention layers are faster than recurrent layers when the sequence length n is smaller than the representation dimensionality d, which is most often the case with sentence representations used by state-of-the-art models in machine translations, such as <font color=orangered>word-piece</font> [38] and byte-pair [31] representations.<span style="font-size:80%;opacity:0.8"> 在计算复杂性方面，当序列长度n 小于表示维度d 时，self-attention层比循环层快，这是机器翻译中最先进的模型最常见情况，例如单词[38]表示法和字节对[31]表示法。</span></li><li>For English-French, we used the significantly larger WMT 2014 English-French dataset consisting of 36M sentences and split tokens into a 32000 <font color=orangered>word-piece</font> vocabulary [38].<span style="font-size:80%;opacity:0.8"> 对于英语-法语翻译，我们使用大得多的WMT 2014英法数据集，它包含3600万个句子，并将词符分成32000个word-piece词汇表[38]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 44 </td> <td> separable<br>(2) </td> <td> [ˈsepərəbl] </td> <td> 
<ul><li><font color=orangered>Separable</font> convolutions [6], however, decrease the complexity considerably, to $O(k\cdot n \cdot d + n\cdot d^2)$.<span style="font-size:80%;opacity:0.8">然而，可分卷积[6]大幅减少复杂度到O(k ⋅n⋅d + n⋅d2)。</span></li><li>Even with $k = n$, however, the complexity of a <font color=orangered>separable</font> convolution is equal to the combination of a self-attention layer and a point-wise feed-forward layer, the approach we take in our model.<span style="font-size:80%;opacity:0.8"> 然而，即使k = n，一个可分卷积的复杂度等同于self-attention层和point-wise前向层的组合，即我们的模型采用的方法。</span></li></ul>
 </td>
</tr>
<tr>
<td> 45 </td> <td> English-French<br>(2) </td> <td> [!≈ 'iŋgliʃ frentʃ] </td> <td> 
<ul><li>For <font color=orangered>English-French</font>, we used the significantly larger WMT 2014 English-French dataset consisting of 36M sentences and split tokens into a 32000 word-piece vocabulary [38].<span style="font-size:80%;opacity:0.8"> 对于英语-法语翻译，我们使用大得多的WMT 2014英法数据集，它包含3600万个句子，并将词符分成32000个word-piece词汇表[38]。</span></li><li>For English-French, we used the significantly larger WMT 2014 <font color=orangered>English-French</font> dataset consisting of 36M sentences and split tokens into a 32000 word-piece vocabulary [38].<span style="font-size:80%;opacity:0.8"> 对于英语-法语翻译，我们使用大得多的WMT 2014英法数据集，它包含3600万个句子，并将词符分成32000个word-piece词汇表[38]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 46 </td> <td> hyperparameters<br>(2) </td> <td>  </td> <td> 
<ul><li>For our base models using the <font color=forestgreen>hyperparameters</font> described throughout the paper, each training step took about 0.4 seconds.<span style="font-size:80%;opacity:0.8"> 使用本文描述的超参数的基础模型，每个训练步骤耗时约0.4秒。</span></li><li>These <font color=forestgreen>hyperparameters</font> were chosen after experimentation on the development set.<span style="font-size:80%;opacity:0.8"> 这些超参数是在开发集上进行实验后选定的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 47 </td> <td> optimizer<br>(2) </td> <td> ['ɑ:ptɪmaɪzər] </td> <td> 
<ul><li>5.3 <font color=orangered>Optimizer</font><span style="font-size:80%;opacity:0.8">5.3 优化器</span></li><li>We used the Adam <font color=orangered>optimizer</font> [20] with $\beta_1 = 0.9$, $\beta_2 = 0.98$ and $\epsilon = 10^{-9}$.<span style="font-size:80%;opacity:0.8">我们使用Adam优化器[20]，其中$\beta_1 = 0.9$, $\beta_2 = 0.98$及$\epsilon = 10^{-9}$。</span></li></ul>
 </td>
</tr>
<tr>
<td> 48 </td> <td> semi-supervised<br>(2) </td> <td> [!≈ ˈsemi 'sju:pəvaɪzd] </td> <td> 
<ul><li>We also trained it in a <font color=orangered>semi-supervised</font> setting, using the larger high-confidence and BerkleyParser corpora from with approximately 17M sentences [37].<span style="font-size:80%;opacity:0.8"> 我们还使用更大的高置信度和BerkleyParser语料库，在半监督环境中对其进行了训练，大约17M个句子[37]。</span></li><li>We used a vocabulary of 16K tokens for the WSJ only setting and a vocabulary of 32K tokens for the <font color=orangered>semi-supervised</font> setting.<span style="font-size:80%;opacity:0.8"> 我们使用了一个16K词符的词汇表作为WSJ唯一设置，和一个32K词符的词汇表用于半监督设置。</span></li></ul>
 </td>
</tr>
<tr>
<td> 49 </td> <td> nip<br>(1) </td> <td> [nɪp] </td> <td> 
<ul><li>31st Conference on Neural Information Processing Systems (<font color=orangered>NIPS</font> 2017), Long Beach, CA, USA.<span style="font-size:80%;opacity:0.8">第31届神经网络信息处理系统会议（NIPS 2017），美国加州长滩市。</span></li></ul>
 </td>
</tr>
<tr>
<td> 50 </td> <td> CA<br>(1) </td> <td> [!≈ si: eɪ] </td> <td> 
<ul><li>31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, <font color=orangered>CA</font>, USA.<span style="font-size:80%;opacity:0.8">第31届神经网络信息处理系统会议（NIPS 2017），美国加州长滩市。</span></li></ul>
 </td>
</tr>
<tr>
<td> 51 </td> <td> USA<br>(1) </td> <td> [ju: es 'ei] </td> <td> 
<ul><li>31st Conference on Neural Information Processing Systems (NIPS 2017), Long Beach, CA, <font color=orangered>USA</font>.<span style="font-size:80%;opacity:0.8">第31届神经网络信息处理系统会议（NIPS 2017），美国加州长滩市。</span></li></ul>
 </td>
</tr>
<tr>
<td> 52 </td> <td> Jakob<br>(1) </td> <td>  </td> <td> 
<ul><li><font color=forestgreen>Jakob</font> proposed replacing RNNs with self-attention and started the effort to evaluate this idea.<span style="font-size:80%;opacity:0.8"> Jakob提出用self-attention替换RNN并开始努力验证这个想法。</span></li></ul>
 </td>
</tr>
<tr>
<td> 53 </td> <td> Ashish<br>(1) </td> <td>  </td> <td> 
<ul><li><font color=forestgreen>Ashish</font>, with Illia, designed and implemented the first Transformer models and has been crucially involved in every aspect of this work.<span style="font-size:80%;opacity:0.8"> Ashish和Illia设计并实现第一个Transformer模型，并在这项工作中的各个方面起着至关重要的作用。</span></li></ul>
 </td>
</tr>
<tr>
<td> 54 </td> <td> Illia<br>(1) </td> <td>  </td> <td> 
<ul><li>Ashish, with <font color=forestgreen>Illia</font>, designed and implemented the first Transformer models and has been crucially involved in every aspect of this work.<span style="font-size:80%;opacity:0.8"> Ashish和Illia设计并实现第一个Transformer模型，并在这项工作中的各个方面起着至关重要的作用。</span></li></ul>
 </td>
</tr>
<tr>
<td> 55 </td> <td> crucially<br>(1) </td> <td> [ˈkru:ʃɪəlɪ] </td> <td> 
<ul><li>Ashish, with Illia, designed and implemented the first Transformer models and has been <font color=orangered>crucially</font> involved in every aspect of this work.<span style="font-size:80%;opacity:0.8"> Ashish和Illia设计并实现第一个Transformer模型，并在这项工作中的各个方面起着至关重要的作用。</span></li></ul>
 </td>
</tr>
<tr>
<td> 56 </td> <td> Noam<br>(1) </td> <td> [ˈnəuəm] </td> <td> 
<ul><li><font color=orangered>Noam</font> proposed scaled dot-product attention, multi-head attention and the parameter-free position representation and became the other person involved in nearly every detail.<span style="font-size:80%;opacity:0.8"> Noam提出缩放版的点积attention、multi-head attention和与参数无关的位置表示，并成为在几乎每个细节中都涉及的另外一个人。</span></li></ul>
 </td>
</tr>
<tr>
<td> 57 </td> <td> Niki<br>(1) </td> <td>  </td> <td> 
<ul><li><font color=forestgreen>Niki</font> designed, implemented, tuned and evaluated countless model variants in our original codebase and tensor2tensor.<span style="font-size:80%;opacity:0.8"> Niki在我们最初的代码库和tensor2tensor中设计、实现、调优和评估了无数的模型变体。</span></li></ul>
 </td>
</tr>
<tr>
<td> 58 </td> <td> Llion<br>(1) </td> <td>  </td> <td> 
<ul><li><font color=forestgreen>Llion</font> also experimented with novel model variants, was responsible for our initial codebase, and efficient inference and visualizations.<span style="font-size:80%;opacity:0.8"> Llion还尝试了新的模型变体，负责我们的初始代码库，以及高效的推断和可视化。</span></li></ul>
 </td>
</tr>
<tr>
<td> 59 </td> <td> visualization<br>(1) </td> <td> [ˌvɪʒʊəlaɪ'zeɪʃn] </td> <td> 
<ul><li>Llion also experimented with novel model variants, was responsible for our initial codebase, and efficient inference and <font color=orangered>visualizations</font>.<span style="font-size:80%;opacity:0.8"> Llion还尝试了新的模型变体，负责我们的初始代码库，以及高效的推断和可视化。</span></li></ul>
 </td>
</tr>
<tr>
<td> 60 </td> <td> Lukasz<br>(1) </td> <td>  </td> <td> 
<ul><li><font color=forestgreen>Lukasz</font> and Aidan spent countless long days designing various parts of and implementing tensor2tensor, replacing our earlier codebase, greatly improving results and massively accelerating our research.<span style="font-size:80%;opacity:0.8"> Lukasz和Aidan花费了无数的时间来设计tensor2tensor的各个部分，取代了我们之前的代码库，极大地改进了结果并大大加快了我们的研究。 </span></li></ul>
 </td>
</tr>
<tr>
<td> 61 </td> <td> Aidan<br>(1) </td> <td>  </td> <td> 
<ul><li>Lukasz and <font color=forestgreen>Aidan</font> spent countless long days designing various parts of and implementing tensor2tensor, replacing our earlier codebase, greatly improving results and massively accelerating our research.<span style="font-size:80%;opacity:0.8"> Lukasz和Aidan花费了无数的时间来设计tensor2tensor的各个部分，取代了我们之前的代码库，极大地改进了结果并大大加快了我们的研究。 </span></li></ul>
 </td>
</tr>
<tr>
<td> 62 </td> <td> massively<br>(1) </td> <td> ['mæsɪvlɪ] </td> <td> 
<ul><li>Lukasz and Aidan spent countless long days designing various parts of and implementing tensor2tensor, replacing our earlier codebase, greatly improving results and <font color=orangered>massively</font> accelerating our research.<span style="font-size:80%;opacity:0.8"> Lukasz和Aidan花费了无数的时间来设计tensor2tensor的各个部分，取代了我们之前的代码库，极大地改进了结果并大大加快了我们的研究。 </span></li></ul>
 </td>
</tr>
<tr>
<td> 63 </td> <td> dispense<br>(1) </td> <td> [dɪˈspens] </td> <td> 
<ul><li>We propose a new simple network architecture, the Transformer, based solely on attention mechanisms, <font color=orangered>dispensing</font> with recurrence and convolutions entirely.<span style="font-size:80%;opacity:0.8"> 我们提出一种新的简单的网络架构Transformer，仅基于attention机制并完全避免循环和卷积。</span></li></ul>
 </td>
</tr>
<tr>
<td> 64 </td> <td> parallelizable<br>(1) </td> <td>  </td> <td> 
<ul><li>Experiments on two machine translation tasks show these models to be superior in quality while being more <font color=forestgreen>parallelizable</font> and requiring significantly less time to train.<span style="font-size:80%;opacity:0.8"> 对两个机器翻译任务的实验表明，这些模型在质量上更加优越、并行性更好并且需要的训练时间显著减少。</span></li></ul>
 </td>
</tr>
<tr>
<td> 65 </td> <td> align<br>(1) </td> <td> [əˈlaɪn] </td> <td> 
<ul><li><font color=orangered>Aligning</font> the positions to steps in computation time, they generate a sequence of hidden states ht, as a function of the previous hidden state ht-1 and the input for position t.<span style="font-size:80%;opacity:0.8"> 通过在计算期间将位置与步骤对齐，它们根据前一步的隐藏状态ht-1和输入产生位置t的隐藏状态序列ht。</span></li></ul>
 </td>
</tr>
<tr>
<td> 66 </td> <td> inherently<br>(1) </td> <td> [ɪnˈhɪərəntlɪ] </td> <td> 
<ul><li>This <font color=orangered>inherently</font> sequential nature precludes parallelization within training examples, which becomes critical at longer sequence lengths, as memory constraints limit batching across examples.<span style="font-size:80%;opacity:0.8">这种固有的顺序特性阻碍样本训练的并行化，这在更长的序列长度上变得至关重要，因为有限的内存限制样本的批次大小。</span></li></ul>
 </td>
</tr>
<tr>
<td> 67 </td> <td> factorization<br>(1) </td> <td> [ˌfæktəraiˈzeiʃən] </td> <td> 
<ul><li>Recent work has achieved significant improvements in computational efficiency through <font color=orangered>factorization</font> tricks [21] and conditional computation [32], while also improving model performance in case of the latter.<span style="font-size:80%;opacity:0.8"> 最近的工作通过巧妙的因子分解[21]和条件计算[32]在计算效率方面取得重大进展，后者还同时提高了模型性能。</span></li></ul>
 </td>
</tr>
<tr>
<td> 68 </td> <td> conditional<br>(1) </td> <td> [kənˈdɪʃənl] </td> <td> 
<ul><li>Recent work has achieved significant improvements in computational efficiency through factorization tricks [21] and <font color=orangered>conditional</font> computation [32], while also improving model performance in case of the latter.<span style="font-size:80%;opacity:0.8"> 最近的工作通过巧妙的因子分解[21]和条件计算[32]在计算效率方面取得重大进展，后者还同时提高了模型性能。</span></li></ul>
 </td>
</tr>
<tr>
<td> 69 </td> <td> integral<br>(1) </td> <td> [ˈɪntɪgrəl] </td> <td> 
<ul><li>Attention mechanisms have become an <font color=orangered>integral</font> part of compelling sequence modeling and transduction models in various tasks, allowing modeling of dependencies without regard to their distance in the input or output sequences [2, 19].<span style="font-size:80%;opacity:0.8">在各种任务中，attention机制已经成为序列建模和转导模型不可或缺的一部分，它可以建模依赖关系而不考虑其在输入或输出序列中的距离[2, 19]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 70 </td> <td> conjunction<br>(1) </td> <td> [kənˈdʒʌŋkʃn] </td> <td> 
<ul><li>In all but a few cases [27], however, such attention mechanisms are used in <font color=orangered>conjunction</font> with a recurrent network.<span style="font-size:80%;opacity:0.8"> 除少数情况外[27]，这种attention机制都与循环网络一起使用。</span></li></ul>
 </td>
</tr>
<tr>
<td> 71 </td> <td> eschew<br>(1) </td> <td> [ɪsˈtʃu:] </td> <td> 
<ul><li>In this work we propose the Transformer, a model architecture <font color=orangered>eschewing</font> recurrence and instead relying entirely on an attention mechanism to draw global dependencies between input and output.<span style="font-size:80%;opacity:0.8">在这项工作中我们提出Transformer，这种模型架构避免循环并完全依赖于attention机制来绘制输入和输出之间的全局依赖关系。</span></li></ul>
 </td>
</tr>
<tr>
<td> 72 </td> <td> arbitrary<br>(1) </td> <td> [ˈɑ:bɪtrəri] </td> <td> 
<ul><li>In these models, the number of operations required to relate signals from two <font color=orangered>arbitrary</font> input or output positions grows in the distance between positions, linearly for ConvS2S and logarithmically for ByteNet.<span style="font-size:80%;opacity:0.8"> 在这些模型中，关联任意两个输入和输出位置的信号所需的操作次数会随着位置之间的距离而增加，ConvS2S是线性增加，而ByteNet是对数增加。</span></li></ul>
 </td>
</tr>
<tr>
<td> 73 </td> <td> logarithmically<br>(1) </td> <td> ['lɒɡərɪðmɪklɪ] </td> <td> 
<ul><li>In these models, the number of operations required to relate signals from two arbitrary input or output positions grows in the distance between positions, linearly for ConvS2S and <font color=orangered>logarithmically</font> for ByteNet.<span style="font-size:80%;opacity:0.8"> 在这些模型中，关联任意两个输入和输出位置的信号所需的操作次数会随着位置之间的距离而增加，ConvS2S是线性增加，而ByteNet是对数增加。</span></li></ul>
 </td>
</tr>
<tr>
<td> 74 </td> <td> albeit<br>(1) </td> <td> [ˌɔ:lˈbi:ɪt] </td> <td> 
<ul><li>In the Transformer this is reduced to a constant number of operations, <font color=orangered>albeit</font> at the cost of reduced effective resolution due to averaging attention-weighted positions, an effect we counteract with Multi-Head Attention as described in section 3.2.<span style="font-size:80%;opacity:0.8"> 在Transformer中，这种操作减少到固定的次数，尽管由于对用attention权重化的位置取平均降低了效果，但是我使用Multi-Head Attention进行抵消，具体描述见 3.2。</span></li></ul>
 </td>
</tr>
<tr>
<td> 75 </td> <td> attention-weighted<br>(1) </td> <td> [!≈ əˈtenʃn ˈweɪtɪd] </td> <td> 
<ul><li>In the Transformer this is reduced to a constant number of operations, albeit at the cost of reduced effective resolution due to averaging <font color=orangered>attention-weighted</font> positions, an effect we counteract with Multi-Head Attention as described in section 3.2.<span style="font-size:80%;opacity:0.8"> 在Transformer中，这种操作减少到固定的次数，尽管由于对用attention权重化的位置取平均降低了效果，但是我使用Multi-Head Attention进行抵消，具体描述见 3.2。</span></li></ul>
 </td>
</tr>
<tr>
<td> 76 </td> <td> intra-attention<br>(1) </td> <td> [!≈ 'ɪntrə əˈtenʃn] </td> <td> 
<ul><li>Self-attention, sometimes called <font color=orangered>intra-attention</font> is an attention mechanism relating different positions of a single sequence in order to compute a representation of the sequence.<span style="font-size:80%;opacity:0.8">Self-attention，有时称为intra-attention，是一种attention机制，它关联单个序列的不同位置以计算序列的表示。</span></li></ul>
 </td>
</tr>
<tr>
<td> 77 </td> <td> abstractive<br>(1) </td> <td> [æb'strækәtiv] </td> <td> 
<ul><li>Self-attention has been used successfully in a variety of tasks including reading comprehension, <font color=orangered>abstractive</font> summarization, textual entailment and learning task-independent sentence representations [4, 27, 28, 22].<span style="font-size:80%;opacity:0.8"> Self-attention已成功用于各种任务，包括阅读理解、摘要概括、文本蕴涵和学习与任务无关的句子表征[4, 27, 28, 22]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 78 </td> <td> summarization<br>(1) </td> <td> [ˌsʌmərɪ'zeɪʃən] </td> <td> 
<ul><li>Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive <font color=orangered>summarization</font>, textual entailment and learning task-independent sentence representations [4, 27, 28, 22].<span style="font-size:80%;opacity:0.8"> Self-attention已成功用于各种任务，包括阅读理解、摘要概括、文本蕴涵和学习与任务无关的句子表征[4, 27, 28, 22]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 79 </td> <td> textual<br>(1) </td> <td> [ˈtekstʃuəl] </td> <td> 
<ul><li>Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive summarization, <font color=orangered>textual</font> entailment and learning task-independent sentence representations [4, 27, 28, 22].<span style="font-size:80%;opacity:0.8"> Self-attention已成功用于各种任务，包括阅读理解、摘要概括、文本蕴涵和学习与任务无关的句子表征[4, 27, 28, 22]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 80 </td> <td> entailment<br>(1) </td> <td> [en'teɪlmənt] </td> <td> 
<ul><li>Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive summarization, textual <font color=orangered>entailment</font> and learning task-independent sentence representations [4, 27, 28, 22].<span style="font-size:80%;opacity:0.8"> Self-attention已成功用于各种任务，包括阅读理解、摘要概括、文本蕴涵和学习与任务无关的句子表征[4, 27, 28, 22]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 81 </td> <td> task-independent<br>(1) </td> <td> [!≈ tɑ:sk ˌɪndɪˈpendənt] </td> <td> 
<ul><li>Self-attention has been used successfully in a variety of tasks including reading comprehension, abstractive summarization, textual entailment and learning <font color=orangered>task-independent</font> sentence representations [4, 27, 28, 22].<span style="font-size:80%;opacity:0.8"> Self-attention已成功用于各种任务，包括阅读理解、摘要概括、文本蕴涵和学习与任务无关的句子表征[4, 27, 28, 22]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 82 </td> <td> simple-language<br>(1) </td> <td> [!≈ ˈsɪmpl ˈlæŋgwɪdʒ] </td> <td> 
<ul><li>End-to-end memory networks are based on a recurrent attention mechanism instead of sequence-aligned recurrence and have been shown to perform well on <font color=orangered>simple-language</font> question answering and language modeling tasks [34].<span style="font-size:80%;opacity:0.8">端到端的记忆网络基于循环attention机制，而不是序列对齐的循环，并且已被证明在简单语言的问答和语言建模任务中表现良好[34]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 83 </td> <td> xn<br>(1) </td> <td>  </td> <td> 
<ul><li>Here, the encoder maps an input sequence of symbol representations (x1,..., <font color=forestgreen>xn</font>) to a sequence of continuous representations z = (z1,..., zn).<span style="font-size:80%;opacity:0.8"> 这里，编码器映射一个用符号表示的输入序列(x1,...,xn) 到一个连续的表示z = (z1,...,zn)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 84 </td> <td> zn<br>(1) </td> <td>  </td> <td> 
<ul><li>Here, the encoder maps an input sequence of symbol representations (x1,..., xn) to a sequence of continuous representations z = (z1,..., <font color=forestgreen>zn</font>).<span style="font-size:80%;opacity:0.8"> 这里，编码器映射一个用符号表示的输入序列(x1,...,xn) 到一个连续的表示z = (z1,...,zn)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 85 </td> <td> ym<br>(1) </td> <td>  </td> <td> 
<ul><li>Given z, the decoder then generates an output sequence (y1,..., <font color=forestgreen>ym</font>) of symbols one element at a time.<span style="font-size:80%;opacity:0.8"> 根据z，解码器生成符号的一个输出序列(y1,...,ym) ，一次一个元素。</span></li></ul>
 </td>
</tr>
<tr>
<td> 86 </td> <td> LayerNorm<br>(1) </td> <td>  </td> <td> 
<ul><li>That is, the output of each sub-layer is <font color=forestgreen>LayerNorm</font>(x + Sublayer(x)), where Sublayer(x) is the function implemented by the sub-layer itself.<span style="font-size:80%;opacity:0.8"> 也就是说，每个子层的输出是LayerNorm(x + Sublayer(x))，其中Sublayer(x) 是由子层本身实现的函数。</span></li></ul>
 </td>
</tr>
<tr>
<td> 87 </td> <td> key-value<br>(1) </td> <td> [!≈ ki: ˈvælju:] </td> <td> 
<ul><li>An attention function can be described as mapping a query and a set of <font color=orangered>key-value</font> pairs to an output, where the query, keys, values, and output are all vectors.<span style="font-size:80%;opacity:0.8">Attention函数可以描述为将query和一组key-value对映射到输出，其中query、key、value和输出都是向量。</span></li></ul>
 </td>
</tr>
<tr>
<td> 88 </td> <td> multiplicative<br>(1) </td> <td> ['mʌltɪplɪkeɪtɪv] </td> <td> 
<ul><li>The two most commonly used attention functions are additive attention [2], and dot-product (<font color=orangered>multiplicative</font>) attention.<span style="font-size:80%;opacity:0.8">两个最常用的attention函数是加法attention[2]和点积（乘法）attention。</span></li></ul>
 </td>
</tr>
<tr>
<td> 89 </td> <td> space-efficient<br>(1) </td> <td> [!≈ speɪs ɪˈfɪʃnt] </td> <td> 
<ul><li>While the two are similar in theoretical complexity, dot-product attention is much faster and more <font color=orangered>space-efficient</font> in practice, since it can be implemented using highly optimized matrix multiplication code.<span style="font-size:80%;opacity:0.8"> 虽然两者在理论上的复杂性相似，但在实践中点积attention的速度更快、更节省空间，因为它可以使用高度优化的矩阵乘法代码来实现。</span></li></ul>
 </td>
</tr>
<tr>
<td> 90 </td> <td> multiplication<br>(1) </td> <td> [ˌmʌltɪplɪˈkeɪʃn] </td> <td> 
<ul><li>While the two are similar in theoretical complexity, dot-product attention is much faster and more space-efficient in practice, since it can be implemented using highly optimized matrix <font color=orangered>multiplication</font> code.<span style="font-size:80%;opacity:0.8"> 虽然两者在理论上的复杂性相似，但在实践中点积attention的速度更快、更节省空间，因为它可以使用高度优化的矩阵乘法代码来实现。</span></li></ul>
 </td>
</tr>
<tr>
<td> 91 </td> <td> qiki<br>(1) </td> <td>  </td> <td> 
<ul><li>Then their dot product, q ⋅ k = ∑ i=1dk <font color=forestgreen>qiki</font>, has mean 0 and variance dk).<span style="font-size:80%;opacity:0.8"> 那么它们的点积q ⋅ k = ∑ i=1dk qi ki 的均值为0，方差为dk)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 92 </td> <td> model-dimensional<br>(1) </td> <td> [!≈ ˈmɒdl dɪ'menʃənəl] </td> <td> 
<ul><li>Instead of performing a single attention function with $d$ <font color=orangered>model-dimensional</font> keys, values and queries, we found it beneficial to linearly project the queries, keys and values $h$ times with different, learned linear projections to $d_k$, $d_k$ and $d_v$ dimensions, respectively.<span style="font-size:80%;opacity:0.8">我们发现将query、key和value分别用不同的、学到的线性映射h倍到dk、dk和dv维效果更好，而不是用d model维的query、key和value执行单个attention函数。</span></li></ul>
 </td>
</tr>
<tr>
<td> 93 </td> <td> concatenate<br>(1) </td> <td> [kɒn'kætɪneɪt] </td> <td> 
<ul><li>These are <font color=orangered>concatenated</font> and once again projected, resulting in the final values, as depicted in Figure 2.<span style="font-size:80%;opacity:0.8"> 将它们连接并再次映射，产生最终值，如图所示 2。</span></li></ul>
 </td>
</tr>
<tr>
<td> 94 </td> <td> jointly<br>(1) </td> <td> [dʒɔɪntlɪ] </td> <td> 
<ul><li>Multi-head attention allows the model to <font color=orangered>jointly</font> attend to information from different representation subspaces at different positions.<span style="font-size:80%;opacity:0.8">Multi-head attention允许模型的不同表示子空间联合关注不同位置的信息。</span></li></ul>
 </td>
</tr>
<tr>
<td> 95 </td> <td> mimic<br>(1) </td> <td> [ˈmɪmɪk] </td> <td> 
<ul><li>This <font color=orangered>mimics</font> the typical encoder-decoder attention mechanisms in sequence-to-sequence models such as [38, 2, 9].<span style="font-size:80%;opacity:0.8"> 这模仿序列到序列模型中典型的编码器—解码器的attention机制，例如[38, 2, 9]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 96 </td> <td> leftward<br>(1) </td> <td> [ˈleftwəd] </td> <td> 
<ul><li>We need to prevent <font color=orangered>leftward</font> information flow in the decoder to preserve the auto-regressive property.<span style="font-size:80%;opacity:0.8"> 我们需要防止解码器中的向左信息流来保持自回归属性。</span></li></ul>
 </td>
</tr>
<tr>
<td> 97 </td> <td> identically<br>(1) </td> <td> [aɪ'dentɪklɪ] </td> <td> 
<ul><li>In addition to attention sub-layers, each of the layers in our encoder and decoder contains a fully connected feed-forward network, which is applied to each position separately and <font color=orangered>identically</font>.<span style="font-size:80%;opacity:0.8">除了attention子层之外，我们的编码器和解码器中的每个层都包含一个完全连接的前馈网络，该前馈网络单独且相同地应用于每个位置。</span></li></ul>
 </td>
</tr>
<tr>
<td> 98 </td> <td> inner-layer<br>(1) </td> <td> [!≈ ˈɪnə(r) ˈleɪə(r)] </td> <td> 
<ul><li>The dimensionality of input and output is $d_{model} = 512$, and the <font color=orangered>inner-layer</font> has dimensionality $d_{ff} = 2048$.<span style="font-size:80%;opacity:0.8"> 输入和输出的维度为dmodel = 512，内部层的维度为dff = 2048。</span></li></ul>
 </td>
</tr>
<tr>
<td> 99 </td> <td> next-token<br>(1) </td> <td> [!≈ nekst ˈtəʊkən] </td> <td> 
<ul><li>We also use the usual learned linear transformation and softmax function to convert the decoder output to predicted <font color=orangered>next-token</font> probabilities.<span style="font-size:80%;opacity:0.8"> 我们还使用普通的线性变换和softmax函数将解码器输出转换为预测的下一个词符的概率。</span></li></ul>
 </td>
</tr>
<tr>
<td> 100 </td> <td> sine<br>(1) </td> <td> [saɪn] </td> <td> 
<ul><li>In this work, we use <font color=orangered>sine</font> and cosine functions of different frequencies:<span style="font-size:80%;opacity:0.8">在这项工作中，我们使用不同频率的正弦和余弦函数：</span></li></ul>
 </td>
</tr>
<tr>
<td> 101 </td> <td> cosine<br>(1) </td> <td> [ˈkəʊsaɪn] </td> <td> 
<ul><li>In this work, we use sine and <font color=orangered>cosine</font> functions of different frequencies:<span style="font-size:80%;opacity:0.8">在这项工作中，我们使用不同频率的正弦和余弦函数：</span></li></ul>
 </td>
</tr>
<tr>
<td> 102 </td> <td> sinusoid<br>(1) </td> <td> ['saɪnəsɔɪd] </td> <td> 
<ul><li>That is, each dimension of the positional encoding corresponds to a <font color=orangered>sinusoid</font>.<span style="font-size:80%;opacity:0.8"> 也就是说，位置编码的每个维度对应于一个正弦曲线。</span></li></ul>
 </td>
</tr>
<tr>
<td> 103 </td> <td> geometric<br>(1) </td> <td> [ˌdʒi:əˈmetrɪk] </td> <td> 
<ul><li>The wavelengths form a <font color=orangered>geometric</font> progression from $2\pi$ to $10000 \cdot 2\pi$.<span style="font-size:80%;opacity:0.8"> 这些波长形成一个几何级数，从2π 到10000 ⋅ 2π。</span></li></ul>
 </td>
</tr>
<tr>
<td> 104 </td> <td> progression<br>(1) </td> <td> [prəˈgreʃn] </td> <td> 
<ul><li>The wavelengths form a geometric <font color=orangered>progression</font> from $2\pi$ to $10000 \cdot 2\pi$.<span style="font-size:80%;opacity:0.8"> 这些波长形成一个几何级数，从2π 到10000 ⋅ 2π。</span></li></ul>
 </td>
</tr>
<tr>
<td> 105 </td> <td> hypothesize<br>(1) </td> <td> [haɪˈpɒθəsaɪz] </td> <td> 
<ul><li>We chose this function because we <font color=orangered>hypothesized</font> it would allow the model to easily learn to attend by relative positions, since for any fixed offset $k$, $PE_{pos+k}$ can be represented as a linear function of $PE_{pos}$.<span style="font-size:80%;opacity:0.8"> 我们选择这个函数是因为我们假设它允许模型很容易学习对相对位置的关注，因为对任意确定的偏移k, PEpos+k可以表示为PEpos的线性函数。</span></li></ul>
 </td>
</tr>
<tr>
<td> 106 </td> <td> extrapolate<br>(1) </td> <td> [ɪkˈstræpəleɪt] </td> <td> 
<ul><li>We chose the sinusoidal version because it may allow the model to <font color=orangered>extrapolate</font> to sequence lengths longer than the ones encountered during training.<span style="font-size:80%;opacity:0.8"> 我们选择了正弦曲线，因为它可以允许模型推断比训练期间遇到的更长的序列。</span></li></ul>
 </td>
</tr>
<tr>
<td> 107 </td> <td> variable-length<br>(1) </td> <td> ['veərɪəbll'eŋθ] </td> <td> 
<ul><li>In this section we compare various aspects of self-attention layers to the recurrent and convolutional layers commonly used for mapping one <font color=orangered>variable-length</font> sequence of symbol representations $(x_1,\cdots,x_n)$ to another sequence of equal length $(z_1,\cdots,z_n)$, with $x_i$, $z_i \in \mathbb R^d$, such as a hidden layer in a typical sequence transduction encoder or decoder.<span style="font-size:80%;opacity:0.8">本节，我们比较self-attention与循环层和卷积层的各个方面，它们通常用于映射变长的符号序列表示(x1,...,xn) 到另一个等长的序列(z1,...,zn)，其中xi,zi ∈ ℝd，例如一个典型的序列转导编码器或解码器中的隐藏层。</span></li></ul>
 </td>
</tr>
<tr>
<td> 108 </td> <td> desiderata<br>(1) </td> <td> [dɪˌzɪdə'reɪtə] </td> <td> 
<ul><li>Motivating our use of self-attention we consider three <font color=orangered>desiderata</font>.<span style="font-size:80%;opacity:0.8"> 我们使用self-attention是考虑到解决三个问题。</span></li></ul>
 </td>
</tr>
<tr>
<td> 109 </td> <td> parallelized<br>(1) </td> <td> ['pærəlelaɪz] </td> <td> 
<ul><li>Another is the amount of computation that can be <font color=orangered>parallelized</font>, as measured by the minimum number of sequential operations required.<span style="font-size:80%;opacity:0.8"> 另一个是可以并行的计算量，以所需的最小顺序操作的数量来衡量。</span></li></ul>
 </td>
</tr>
<tr>
<td> 110 </td> <td> traverse<br>(1) </td> <td> [trəˈvɜ:s] </td> <td> 
<ul><li>One key factor affecting the ability to learn such dependencies is the length of the paths forward and backward signals have to <font color=orangered>traverse</font> in the network.<span style="font-size:80%;opacity:0.8"> 影响学习这种依赖性能力的一个关键因素是前向和后向信号必须在网络中传播的路径长度。</span></li></ul>
 </td>
</tr>
<tr>
<td> 111 </td> <td> sequentially<br>(1) </td> <td> [sɪ'kwenʃəlɪ] </td> <td> 
<ul><li>As noted in Table 1, a self-attention layer connects all positions with a constant number of <font color=orangered>sequentially</font> executed operations, whereas a recurrent layer requires $O(n)$ sequential operations.<span style="font-size:80%;opacity:0.8">如表1所示，self-attention层将所有位置连接到恒定数量的顺序执行的操作，而循环层需要O(n) 顺序操作。</span></li></ul>
 </td>
</tr>
<tr>
<td> 112 </td> <td> contiguous<br>(1) </td> <td> [kənˈtɪgjuəs] </td> <td> 
<ul><li>Doing so requires a stack of $O(n/k)$ convolutional layers in the case of <font color=orangered>contiguous</font> kernels, or O(logk(n)) in the case of dilated convolutions [18], increasing the length of the longest paths between any two positions in the network.<span style="font-size:80%;opacity:0.8"> 要这么做，在邻近核的情况下需要O(n∕k) 个卷积层， 在扩展卷积的情况下需要O(logk(n)) 个层[18]，它们增加了网络中任意两个位置之间的最长路径的长度。</span></li></ul>
 </td>
</tr>
<tr>
<td> 113 </td> <td> logk<br>(1) </td> <td>  </td> <td> 
<ul><li>Doing so requires a stack of $O(n/k)$ convolutional layers in the case of contiguous kernels, or O(<font color=forestgreen>logk</font>(n)) in the case of dilated convolutions [18], increasing the length of the longest paths between any two positions in the network.<span style="font-size:80%;opacity:0.8"> 要这么做，在邻近核的情况下需要O(n∕k) 个卷积层， 在扩展卷积的情况下需要O(logk(n)) 个层[18]，它们增加了网络中任意两个位置之间的最长路径的长度。</span></li></ul>
 </td>
</tr>
<tr>
<td> 114 </td> <td> dilate<br>(1) </td> <td> [daɪˈleɪt] </td> <td> 
<ul><li>Doing so requires a stack of $O(n/k)$ convolutional layers in the case of contiguous kernels, or O(logk(n)) in the case of <font color=orangered>dilated</font> convolutions [18], increasing the length of the longest paths between any two positions in the network.<span style="font-size:80%;opacity:0.8"> 要这么做，在邻近核的情况下需要O(n∕k) 个卷积层， 在扩展卷积的情况下需要O(logk(n)) 个层[18]，它们增加了网络中任意两个位置之间的最长路径的长度。</span></li></ul>
 </td>
</tr>
<tr>
<td> 115 </td> <td> interpretable<br>(1) </td> <td> [ɪn'tɜ:prɪtəbl] </td> <td> 
<ul><li>As side benefit, self-attention could yield more <font color=orangered>interpretable</font> models.<span style="font-size:80%;opacity:0.8">间接的好处是self-attention可以产生更可解释的模型。</span></li></ul>
 </td>
</tr>
<tr>
<td> 116 </td> <td> syntactic<br>(1) </td> <td> [sɪnˈtæktɪk] </td> <td> 
<ul><li>Not only do individual attention heads clearly learn to perform different tasks, many appear to exhibit behavior related to the <font color=orangered>syntactic</font> and semantic structure of the sentences.<span style="font-size:80%;opacity:0.8"> 每个attention head不仅清楚地学习到执行不同的任务，许多似乎展现与句子的句法和语义结构的行为。</span></li></ul>
 </td>
</tr>
<tr>
<td> 117 </td> <td> semantic<br>(1) </td> <td> [sɪˈmæntɪk] </td> <td> 
<ul><li>Not only do individual attention heads clearly learn to perform different tasks, many appear to exhibit behavior related to the syntactic and <font color=orangered>semantic</font> structure of the sentences.<span style="font-size:80%;opacity:0.8"> 每个attention head不仅清楚地学习到执行不同的任务，许多似乎展现与句子的句法和语义结构的行为。</span></li></ul>
 </td>
</tr>
<tr>
<td> 118 </td> <td> English-German<br>(1) </td> <td> [!≈ 'iŋgliʃ ˈdʒɜ:mən] </td> <td> 
<ul><li>We trained on the standard WMT 2014 <font color=orangered>English-German</font> dataset consisting of about 4.5 million sentence pairs.<span style="font-size:80%;opacity:0.8">我们在标准的WMT 2014英语-德语数据集上进行了训练，其中包含约450万个句子对。</span></li></ul>
 </td>
</tr>
<tr>
<td> 119 </td> <td> source-target<br>(1) </td> <td> [!≈ sɔ:s ˈtɑ:gɪt] </td> <td> 
<ul><li>Sentences were encoded using byte-pair encoding [3], which has a shared <font color=orangered>source-target</font> vocabulary of about 37000 tokens.<span style="font-size:80%;opacity:0.8"> 这些句子使用字节对编码[3]进行编码，源语句和目标语句共享大约37000个词符的词汇表。</span></li></ul>
 </td>
</tr>
<tr>
<td> 120 </td> <td> NVIDIA<br>(1) </td> <td> [ɪn'vɪdɪə] </td> <td> 
<ul><li>We trained our models on one machine with 8 <font color=orangered>NVIDIA</font> P100 GPUs.<span style="font-size:80%;opacity:0.8">我们在一台具有8个NVIDIA P100 GPU的机器上训练我们的模型。</span></li></ul>
 </td>
</tr>
<tr>
<td> 121 </td> <td> proportionally<br>(1) </td> <td> [prə'pɔ:ʃənlɪ] </td> <td> 
<ul><li>This corresponds to increasing the learning rate linearly for the first warmup_steps training steps, and decreasing it thereafter <font color=orangered>proportionally</font> to the inverse square root of the step number.<span style="font-size:80%;opacity:0.8">这对应于在第一次warmup_steps 步骤中线性地增加学习速率，并且随后将其与步骤数的平方根成比例地减小。</span></li></ul>
 </td>
</tr>
<tr>
<td> 122 </td> <td> inverse<br>(1) </td> <td> [ˌɪnˈvɜ:s] </td> <td> 
<ul><li>This corresponds to increasing the learning rate linearly for the first warmup_steps training steps, and decreasing it thereafter proportionally to the <font color=orangered>inverse</font> square root of the step number.<span style="font-size:80%;opacity:0.8">这对应于在第一次warmup_steps 步骤中线性地增加学习速率，并且随后将其与步骤数的平方根成比例地减小。</span></li></ul>
 </td>
</tr>
<tr>
<td> 123 </td> <td> normalize<br>(1) </td> <td> [ˈnɔ:məlaɪz] </td> <td> 
<ul><li>Residual Dropout We apply dropout [33] to the output of each sub-layer, before it is added to the sub-layer input and <font color=orangered>normalized</font>.<span style="font-size:80%;opacity:0.8">残差丢弃 我们将丢弃[33]应用到每个子层的输出，在将它与子层的输入相加和规范化之前。</span></li></ul>
 </td>
</tr>
<tr>
<td> 124 </td> <td> surpass<br>(1) </td> <td> [səˈpɑ:s] </td> <td> 
<ul><li>Even our base model <font color=orangered>surpasses</font> all previously published models and ensembles, at a fraction of the training cost of any of the competitive models.<span style="font-size:80%;opacity:0.8"> 即使我们的基础模型也超过了以前发布的所有模型和整合模型，且训练成本只是这些模型的一小部分。</span></li></ul>
 </td>
</tr>
<tr>
<td> 125 </td> <td> Pdrop<br>(1) </td> <td>  </td> <td> 
<ul><li>The Transformer (big) model trained for English-to-French used dropout rate <font color=forestgreen>Pdrop</font> = 0.1, instead of 0.3.<span style="font-size:80%;opacity:0.8"> 英语-法语的Transformer (big) 模型使用丢弃率为Pdrop = 0.1，而不是0.3。</span></li></ul>
 </td>
</tr>
<tr>
<td> 126 </td> <td> experimentation<br>(1) </td> <td> [ɪkˌsperɪmenˈteɪʃn] </td> <td> 
<ul><li>These hyperparameters were chosen after <font color=orangered>experimentation</font> on the development set.<span style="font-size:80%;opacity:0.8"> 这些超参数是在开发集上进行实验后选定的。</span></li></ul>
 </td>
</tr>
<tr>
<td> 127 </td> <td> floating-point<br>(1) </td> <td> ['fləʊtɪŋ'pɔɪnt] </td> <td> 
<ul><li>We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision <font color=orangered>floating-point</font> capacity of each GPU (We used values of 2.8, 3.7, 6.0 and 9.5 TFLOPS for K80, K40, M40 and P100, respectively).<span style="font-size:80%;opacity:0.8"> 我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量(对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 128 </td> <td> TFLOPS<br>(1) </td> <td> [!≈ ti: ef el əu pi: es] </td> <td> 
<ul><li>We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision floating-point capacity of each GPU (We used values of 2.8, 3.7, 6.0 and 9.5 <font color=orangered>TFLOPS</font> for K80, K40, M40 and P100, respectively).<span style="font-size:80%;opacity:0.8"> 我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量(对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 129 </td> <td> K80<br>(1) </td> <td>  </td> <td> 
<ul><li>We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision floating-point capacity of each GPU (We used values of 2.8, 3.7, 6.0 and 9.5 TFLOPS for <font color=forestgreen>K80</font>, K40, M40 and P100, respectively).<span style="font-size:80%;opacity:0.8"> 我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量(对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 130 </td> <td> K40<br>(1) </td> <td>  </td> <td> 
<ul><li>We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision floating-point capacity of each GPU (We used values of 2.8, 3.7, 6.0 and 9.5 TFLOPS for K80, <font color=forestgreen>K40</font>, M40 and P100, respectively).<span style="font-size:80%;opacity:0.8"> 我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量(对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 131 </td> <td> M40<br>(1) </td> <td>  </td> <td> 
<ul><li>We estimate the number of floating point operations used to train a model by multiplying the training time, the number of GPUs used, and an estimate of the sustained single-precision floating-point capacity of each GPU (We used values of 2.8, 3.7, 6.0 and 9.5 TFLOPS for K80, K40, <font color=forestgreen>M40</font> and P100, respectively).<span style="font-size:80%;opacity:0.8"> 我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量(对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值)。</span></li></ul>
 </td>
</tr>
<tr>
<td> 132 </td> <td> Unlisted<br>(1) </td> <td> [ˌʌnˈlɪstɪd] </td> <td> 
<ul><li><font color=orangered>Unlisted</font> values are identical to those of the base model.<span style="font-size:80%;opacity:0.8"> 未列出的值与基本模型的值相同。 所有指标都基于英文到德文翻译开发集newstest2013。</span></li></ul>
 </td>
</tr>
<tr>
<td> 133 </td> <td> per-wordpiece<br>(1) </td> <td>  </td> <td> 
<ul><li>All metrics are on the English-to-German translation development set, newstest2013. Listed perplexities are <font color=forestgreen>per-wordpiece</font>, according to our byte-pair encoding, and should not be compared to per-word perplexities.<span style="font-size:80%;opacity:0.8"> Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.</span></li></ul>
 </td>
</tr>
<tr>
<td> 134 </td> <td> over-fitting<br>(1) </td> <td> [!≈ ˈəʊvə(r) ˈfɪtɪŋ] </td> <td> 
<ul><li>We further observe in rows (C) and (D) that, as expected, bigger models are better, and dropout is very helpful in avoiding <font color=orangered>over-fitting</font>.<span style="font-size:80%;opacity:0.8"> 我们在行（C）和（D）中进一步观察到，如预期的那样，更大的模型更好，并且丢弃对避免过度拟合非常有帮助。</span></li></ul>
 </td>
</tr>
<tr>
<td> 135 </td> <td> small-data<br>(1) </td> <td> [!≈ smɔ:l ˈdeɪtə] </td> <td> 
<ul><li>Furthermore, RNN sequence-to-sequence models have not been able to attain state-of-the-art results in <font color=orangered>small-data</font> regimes [37].<span style="font-size:80%;opacity:0.8"> 此外，RNN序列到序列模型还没有能够在小数据[37]中获得最好的结果。</span></li></ul>
 </td>
</tr>
<tr>
<td> 136 </td> <td> Penn<br>(1) </td> <td> [pen] </td> <td> 
<ul><li>We trained a 4-layer transformer with dmodel = 1024 on the Wall Street Journal (WSJ) portion of the <font color=orangered>Penn</font> Treebank [25], about 40K training sentences.<span style="font-size:80%;opacity:0.8">我们用dmodel = 1024 在Penn Treebank[25]的Wall Street Journal（WSJ）部分训练了一个4层transformer，约40K个训练句子。</span></li></ul>
 </td>
</tr>
<tr>
<td> 137 </td> <td> Treebank<br>(1) </td> <td> [ˈtri:bænk] </td> <td> 
<ul><li>We trained a 4-layer transformer with dmodel = 1024 on the Wall Street Journal (WSJ) portion of the Penn <font color=orangered>Treebank</font> [25], about 40K training sentences.<span style="font-size:80%;opacity:0.8">我们用dmodel = 1024 在Penn Treebank[25]的Wall Street Journal（WSJ）部分训练了一个4层transformer，约40K个训练句子。</span></li></ul>
 </td>
</tr>
<tr>
<td> 138 </td> <td> BerkleyParser<br>(1) </td> <td>  </td> <td> 
<ul><li>We also trained it in a semi-supervised setting, using the larger high-confidence and <font color=forestgreen>BerkleyParser</font> corpora from with approximately 17M sentences [37].<span style="font-size:80%;opacity:0.8"> 我们还使用更大的高置信度和BerkleyParser语料库，在半监督环境中对其进行了训练，大约17M个句子[37]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 139 </td> <td> corpora<br>(1) </td> <td> [ˈkɔ:pərə] </td> <td> 
<ul><li>We also trained it in a semi-supervised setting, using the larger high-confidence and BerkleyParser <font color=orangered>corpora</font> from with approximately 17M sentences [37].<span style="font-size:80%;opacity:0.8"> 我们还使用更大的高置信度和BerkleyParser语料库，在半监督环境中对其进行了训练，大约17M个句子[37]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 140 </td> <td> BerkeleyParser<br>(1) </td> <td>  </td> <td> 
<ul><li>In contrast to RNN sequence-to-sequence models [37], the Transformer outperforms the <font color=forestgreen>BerkeleyParser</font> [29] even when training only on the WSJ training set of 40K sentences.<span style="font-size:80%;opacity:0.8">与RNN序列到序列模型[37]相比，即使仅在WSJ训练40K句子组训练时，Transformer也胜过BerkeleyParser [29]。</span></li></ul>
 </td>
</tr>
<tr>
<td> 141 </td> <td> modality<br>(1) </td> <td> [məʊˈdæləti] </td> <td> 
<ul><li>We plan to extend the Transformer to problems involving input and output <font color=orangered>modalities</font> other than text and to investigate local, restricted attention mechanisms to efficiently handle large inputs and outputs such as images, audio and video.<span style="font-size:80%;opacity:0.8"> 我们计划将Transformer扩展到除文本之外的涉及输入和输出模式的问题，并调查局部的、受限attention机制以有效处理大型输入和输出，如图像、音频和视频。</span></li></ul>
 </td>
</tr>
<tr>
<td> 142 </td> <td> Nal<br>(1) </td> <td>  </td> <td> 
<ul><li>Acknowledgements We are grateful to <font color=forestgreen>Nal</font> Kalchbrenner and Stephan Gouws for their fruitful comments, corrections and inspiration.<span style="font-size:80%;opacity:0.8">致谢 我们感谢Nal Kalchbrenner和Stephan Gouws富有成效的评论、更正和灵感。</span></li></ul>
 </td>
</tr>
<tr>
<td> 143 </td> <td> Kalchbrenner<br>(1) </td> <td>  </td> <td> 
<ul><li>Acknowledgements We are grateful to Nal <font color=forestgreen>Kalchbrenner</font> and Stephan Gouws for their fruitful comments, corrections and inspiration.<span style="font-size:80%;opacity:0.8">致谢 我们感谢Nal Kalchbrenner和Stephan Gouws富有成效的评论、更正和灵感。</span></li></ul>
 </td>
</tr>
<tr>
<td> 144 </td> <td> Stephan<br>(1) </td> <td>  </td> <td> 
<ul><li>Acknowledgements We are grateful to Nal Kalchbrenner and <font color=forestgreen>Stephan</font> Gouws for their fruitful comments, corrections and inspiration.<span style="font-size:80%;opacity:0.8">致谢 我们感谢Nal Kalchbrenner和Stephan Gouws富有成效的评论、更正和灵感。</span></li></ul>
 </td>
</tr>
<tr>
<td> 145 </td> <td> Gouws<br>(1) </td> <td>  </td> <td> 
<ul><li>Acknowledgements We are grateful to Nal Kalchbrenner and Stephan <font color=forestgreen>Gouws</font> for their fruitful comments, corrections and inspiration.<span style="font-size:80%;opacity:0.8">致谢 我们感谢Nal Kalchbrenner和Stephan Gouws富有成效的评论、更正和灵感。</span></li></ul>
 </td>
</tr>
</table>
</div>
</div>
</div>
</body>
</html>